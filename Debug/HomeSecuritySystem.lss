
HomeSecuritySystem.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000003c  00800100  00001244  000012d8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001244  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000061c  0080013c  0080013c  00001314  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00001314  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000210  00000000  00000000  00001370  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00002239  00000000  00000000  00001580  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000009e8  00000000  00000000  000037b9  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00000d25  00000000  00000000  000041a1  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000005c8  00000000  00000000  00004ec8  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00000c48  00000000  00000000  00005490  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00001db5  00000000  00000000  000060d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000001f8  00000000  00000000  00007e8d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 8f 02 	jmp	0x51e	; 0x51e <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e4 e4       	ldi	r30, 0x44	; 68
      7c:	f2 e1       	ldi	r31, 0x12	; 18
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	ac 33       	cpi	r26, 0x3C	; 60
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	27 e0       	ldi	r18, 0x07	; 7
      8c:	ac e3       	ldi	r26, 0x3C	; 60
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a8 35       	cpi	r26, 0x58	; 88
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 76 00 	call	0xec	; 0xec <main>
      9e:	0c 94 20 09 	jmp	0x1240	; 0x1240 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vLEDInit>:
#define MYUBRR						F_CPU/8/BAUD-1

void vLEDInit(void)
{
	// Set LED_O as output pin
	DDRB |= _BV(PB5);
      a6:	25 9a       	sbi	0x04, 5	; 4
      a8:	08 95       	ret

000000aa <vLEDToggle>:
}

void vLEDToggle(void)
{
	PORTB ^= _BV(PB5);
      aa:	95 b1       	in	r25, 0x05	; 5
      ac:	80 e2       	ldi	r24, 0x20	; 32
      ae:	89 27       	eor	r24, r25
      b0:	85 b9       	out	0x05, r24	; 5
      b2:	08 95       	ret

000000b4 <vLEDFlashTask>:
}

void vLEDFlashTask( void *pvParameters )
{
      b4:	cf 93       	push	r28
      b6:	df 93       	push	r29
      b8:	00 d0       	rcall	.+0      	; 0xba <vLEDFlashTask+0x6>
      ba:	cd b7       	in	r28, 0x3d	; 61
      bc:	de b7       	in	r29, 0x3e	; 62
	printf("Initializing LED task");
      be:	8c e1       	ldi	r24, 0x1C	; 28
      c0:	91 e0       	ldi	r25, 0x01	; 1
      c2:	9f 93       	push	r25
      c4:	8f 93       	push	r24
      c6:	0e 94 5d 06 	call	0xcba	; 0xcba <printf>
	vLEDInit();
      ca:	0e 94 53 00 	call	0xa6	; 0xa6 <vLEDInit>
	portTickType xLastWakeTime;
	portTickType xFrequency = 1000;
	xLastWakeTime=xTaskGetTickCount();
      ce:	0e 94 32 04 	call	0x864	; 0x864 <xTaskGetTickCount>
      d2:	9a 83       	std	Y+2, r25	; 0x02
      d4:	89 83       	std	Y+1, r24	; 0x01
      d6:	0f 90       	pop	r0
      d8:	0f 90       	pop	r0
	for( ;; )
	{
		vLEDToggle();
      da:	0e 94 55 00 	call	0xaa	; 0xaa <vLEDToggle>
		vTaskDelayUntil(&xLastWakeTime, xFrequency);
      de:	68 ee       	ldi	r22, 0xE8	; 232
      e0:	73 e0       	ldi	r23, 0x03	; 3
      e2:	ce 01       	movw	r24, r28
      e4:	01 96       	adiw	r24, 0x01	; 1
      e6:	0e 94 9a 05 	call	0xb34	; 0xb34 <vTaskDelayUntil>
      ea:	f7 cf       	rjmp	.-18     	; 0xda <vLEDFlashTask+0x26>

000000ec <main>:
	}
	
}

int main(void)
{
      ec:	af 92       	push	r10
      ee:	bf 92       	push	r11
      f0:	cf 92       	push	r12
      f2:	df 92       	push	r13
      f4:	ef 92       	push	r14
      f6:	ff 92       	push	r15
      f8:	0f 93       	push	r16
	USART_Init(MYUBRR);
      fa:	87 e6       	ldi	r24, 0x67	; 103
      fc:	90 e0       	ldi	r25, 0x00	; 0
      fe:	0e 94 3a 06 	call	0xc74	; 0xc74 <USART_Init>
	stdout = &uart_output;
     102:	8e e0       	ldi	r24, 0x0E	; 14
     104:	91 e0       	ldi	r25, 0x01	; 1
     106:	90 93 55 07 	sts	0x0755, r25
     10a:	80 93 54 07 	sts	0x0754, r24
	stdin = &uart_input;
     10e:	80 e0       	ldi	r24, 0x00	; 0
     110:	91 e0       	ldi	r25, 0x01	; 1
     112:	90 93 53 07 	sts	0x0753, r25
     116:	80 93 52 07 	sts	0x0752, r24
	
	xTaskCreate( vLEDFlashTask, ( signed char * ) "LED", configMINIMAL_STACK_SIZE, NULL, mainLED_TASK_PRIORITY, NULL );
     11a:	a1 2c       	mov	r10, r1
     11c:	b1 2c       	mov	r11, r1
     11e:	c1 2c       	mov	r12, r1
     120:	d1 2c       	mov	r13, r1
     122:	e1 2c       	mov	r14, r1
     124:	f1 2c       	mov	r15, r1
     126:	00 e0       	ldi	r16, 0x00	; 0
     128:	20 e0       	ldi	r18, 0x00	; 0
     12a:	30 e0       	ldi	r19, 0x00	; 0
     12c:	45 e5       	ldi	r20, 0x55	; 85
     12e:	50 e0       	ldi	r21, 0x00	; 0
     130:	62 e3       	ldi	r22, 0x32	; 50
     132:	71 e0       	ldi	r23, 0x01	; 1
     134:	8a e5       	ldi	r24, 0x5A	; 90
     136:	90 e0       	ldi	r25, 0x00	; 0
     138:	0e 94 08 03 	call	0x610	; 0x610 <xTaskGenericCreate>
	vTaskStartScheduler();
     13c:	0e 94 fa 03 	call	0x7f4	; 0x7f4 <vTaskStartScheduler>
     140:	80 e0       	ldi	r24, 0x00	; 0
     142:	90 e0       	ldi	r25, 0x00	; 0
     144:	0f 91       	pop	r16
     146:	ff 90       	pop	r15
     148:	ef 90       	pop	r14
     14a:	df 90       	pop	r13
     14c:	cf 90       	pop	r12
     14e:	bf 90       	pop	r11
     150:	af 90       	pop	r10
     152:	08 95       	ret

00000154 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     154:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     156:	03 96       	adiw	r24, 0x03	; 3
     158:	92 83       	std	Z+2, r25	; 0x02
     15a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     15c:	2f ef       	ldi	r18, 0xFF	; 255
     15e:	3f ef       	ldi	r19, 0xFF	; 255
     160:	34 83       	std	Z+4, r19	; 0x04
     162:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     164:	96 83       	std	Z+6, r25	; 0x06
     166:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     168:	90 87       	std	Z+8, r25	; 0x08
     16a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     16c:	10 82       	st	Z, r1
     16e:	08 95       	ret

00000170 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     170:	fc 01       	movw	r30, r24
     172:	11 86       	std	Z+9, r1	; 0x09
     174:	10 86       	std	Z+8, r1	; 0x08
     176:	08 95       	ret

00000178 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     178:	cf 93       	push	r28
     17a:	df 93       	push	r29
     17c:	9c 01       	movw	r18, r24
     17e:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     180:	dc 01       	movw	r26, r24
     182:	11 96       	adiw	r26, 0x01	; 1
     184:	cd 91       	ld	r28, X+
     186:	dc 91       	ld	r29, X
     188:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     18a:	d3 83       	std	Z+3, r29	; 0x03
     18c:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     18e:	8c 81       	ldd	r24, Y+4	; 0x04
     190:	9d 81       	ldd	r25, Y+5	; 0x05
     192:	95 83       	std	Z+5, r25	; 0x05
     194:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     196:	8c 81       	ldd	r24, Y+4	; 0x04
     198:	9d 81       	ldd	r25, Y+5	; 0x05
     19a:	dc 01       	movw	r26, r24
     19c:	13 96       	adiw	r26, 0x03	; 3
     19e:	7c 93       	st	X, r23
     1a0:	6e 93       	st	-X, r22
     1a2:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     1a4:	7d 83       	std	Y+5, r23	; 0x05
     1a6:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     1a8:	31 87       	std	Z+9, r19	; 0x09
     1aa:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     1ac:	f9 01       	movw	r30, r18
     1ae:	80 81       	ld	r24, Z
     1b0:	8f 5f       	subi	r24, 0xFF	; 255
     1b2:	80 83       	st	Z, r24
}
     1b4:	df 91       	pop	r29
     1b6:	cf 91       	pop	r28
     1b8:	08 95       	ret

000001ba <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     1ba:	cf 93       	push	r28
     1bc:	df 93       	push	r29
     1be:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     1c0:	48 81       	ld	r20, Y
     1c2:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     1c4:	4f 3f       	cpi	r20, 0xFF	; 255
     1c6:	2f ef       	ldi	r18, 0xFF	; 255
     1c8:	52 07       	cpc	r21, r18
     1ca:	21 f4       	brne	.+8      	; 0x1d4 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     1cc:	fc 01       	movw	r30, r24
     1ce:	a7 81       	ldd	r26, Z+7	; 0x07
     1d0:	b0 85       	ldd	r27, Z+8	; 0x08
     1d2:	0d c0       	rjmp	.+26     	; 0x1ee <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     1d4:	dc 01       	movw	r26, r24
     1d6:	13 96       	adiw	r26, 0x03	; 3
     1d8:	12 96       	adiw	r26, 0x02	; 2
     1da:	ed 91       	ld	r30, X+
     1dc:	fc 91       	ld	r31, X
     1de:	13 97       	sbiw	r26, 0x03	; 3
     1e0:	20 81       	ld	r18, Z
     1e2:	31 81       	ldd	r19, Z+1	; 0x01
     1e4:	42 17       	cp	r20, r18
     1e6:	53 07       	cpc	r21, r19
     1e8:	10 f0       	brcs	.+4      	; 0x1ee <vListInsert+0x34>
     1ea:	df 01       	movw	r26, r30
     1ec:	f5 cf       	rjmp	.-22     	; 0x1d8 <vListInsert+0x1e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     1ee:	12 96       	adiw	r26, 0x02	; 2
     1f0:	ed 91       	ld	r30, X+
     1f2:	fc 91       	ld	r31, X
     1f4:	13 97       	sbiw	r26, 0x03	; 3
     1f6:	fb 83       	std	Y+3, r31	; 0x03
     1f8:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     1fa:	d5 83       	std	Z+5, r29	; 0x05
     1fc:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     1fe:	bd 83       	std	Y+5, r27	; 0x05
     200:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     202:	13 96       	adiw	r26, 0x03	; 3
     204:	dc 93       	st	X, r29
     206:	ce 93       	st	-X, r28
     208:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     20a:	99 87       	std	Y+9, r25	; 0x09
     20c:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     20e:	fc 01       	movw	r30, r24
     210:	20 81       	ld	r18, Z
     212:	2f 5f       	subi	r18, 0xFF	; 255
     214:	20 83       	st	Z, r18
}
     216:	df 91       	pop	r29
     218:	cf 91       	pop	r28
     21a:	08 95       	ret

0000021c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     21c:	cf 93       	push	r28
     21e:	df 93       	push	r29
     220:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     222:	a0 85       	ldd	r26, Z+8	; 0x08
     224:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     226:	c2 81       	ldd	r28, Z+2	; 0x02
     228:	d3 81       	ldd	r29, Z+3	; 0x03
     22a:	84 81       	ldd	r24, Z+4	; 0x04
     22c:	95 81       	ldd	r25, Z+5	; 0x05
     22e:	9d 83       	std	Y+5, r25	; 0x05
     230:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     232:	c4 81       	ldd	r28, Z+4	; 0x04
     234:	d5 81       	ldd	r29, Z+5	; 0x05
     236:	82 81       	ldd	r24, Z+2	; 0x02
     238:	93 81       	ldd	r25, Z+3	; 0x03
     23a:	9b 83       	std	Y+3, r25	; 0x03
     23c:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     23e:	11 96       	adiw	r26, 0x01	; 1
     240:	cd 91       	ld	r28, X+
     242:	dc 91       	ld	r29, X
     244:	12 97       	sbiw	r26, 0x02	; 2
     246:	ce 17       	cp	r28, r30
     248:	df 07       	cpc	r29, r31
     24a:	31 f4       	brne	.+12     	; 0x258 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     24c:	8c 81       	ldd	r24, Y+4	; 0x04
     24e:	9d 81       	ldd	r25, Y+5	; 0x05
     250:	12 96       	adiw	r26, 0x02	; 2
     252:	9c 93       	st	X, r25
     254:	8e 93       	st	-X, r24
     256:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     258:	11 86       	std	Z+9, r1	; 0x09
     25a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     25c:	8c 91       	ld	r24, X
     25e:	81 50       	subi	r24, 0x01	; 1
     260:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     262:	df 91       	pop	r29
     264:	cf 91       	pop	r28
     266:	08 95       	ret

00000268 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     268:	31 e1       	ldi	r19, 0x11	; 17
     26a:	fc 01       	movw	r30, r24
     26c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     26e:	31 97       	sbiw	r30, 0x01	; 1
     270:	22 e2       	ldi	r18, 0x22	; 34
     272:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     274:	31 97       	sbiw	r30, 0x01	; 1
     276:	a3 e3       	ldi	r26, 0x33	; 51
     278:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     27a:	31 97       	sbiw	r30, 0x01	; 1
     27c:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     27e:	31 97       	sbiw	r30, 0x01	; 1
     280:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     282:	31 97       	sbiw	r30, 0x01	; 1
     284:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     286:	31 97       	sbiw	r30, 0x01	; 1
     288:	60 e8       	ldi	r22, 0x80	; 128
     28a:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     28c:	31 97       	sbiw	r30, 0x01	; 1
     28e:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     290:	31 97       	sbiw	r30, 0x01	; 1
     292:	62 e0       	ldi	r22, 0x02	; 2
     294:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     296:	31 97       	sbiw	r30, 0x01	; 1
     298:	63 e0       	ldi	r22, 0x03	; 3
     29a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     29c:	31 97       	sbiw	r30, 0x01	; 1
     29e:	64 e0       	ldi	r22, 0x04	; 4
     2a0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     2a2:	31 97       	sbiw	r30, 0x01	; 1
     2a4:	65 e0       	ldi	r22, 0x05	; 5
     2a6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     2a8:	31 97       	sbiw	r30, 0x01	; 1
     2aa:	66 e0       	ldi	r22, 0x06	; 6
     2ac:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     2ae:	31 97       	sbiw	r30, 0x01	; 1
     2b0:	67 e0       	ldi	r22, 0x07	; 7
     2b2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     2b4:	31 97       	sbiw	r30, 0x01	; 1
     2b6:	68 e0       	ldi	r22, 0x08	; 8
     2b8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     2ba:	31 97       	sbiw	r30, 0x01	; 1
     2bc:	69 e0       	ldi	r22, 0x09	; 9
     2be:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     2c0:	31 97       	sbiw	r30, 0x01	; 1
     2c2:	60 e1       	ldi	r22, 0x10	; 16
     2c4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     2c6:	31 97       	sbiw	r30, 0x01	; 1
     2c8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     2ca:	31 97       	sbiw	r30, 0x01	; 1
     2cc:	32 e1       	ldi	r19, 0x12	; 18
     2ce:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     2d0:	31 97       	sbiw	r30, 0x01	; 1
     2d2:	33 e1       	ldi	r19, 0x13	; 19
     2d4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     2d6:	31 97       	sbiw	r30, 0x01	; 1
     2d8:	34 e1       	ldi	r19, 0x14	; 20
     2da:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     2dc:	31 97       	sbiw	r30, 0x01	; 1
     2de:	35 e1       	ldi	r19, 0x15	; 21
     2e0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     2e2:	31 97       	sbiw	r30, 0x01	; 1
     2e4:	36 e1       	ldi	r19, 0x16	; 22
     2e6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     2e8:	31 97       	sbiw	r30, 0x01	; 1
     2ea:	37 e1       	ldi	r19, 0x17	; 23
     2ec:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     2ee:	31 97       	sbiw	r30, 0x01	; 1
     2f0:	38 e1       	ldi	r19, 0x18	; 24
     2f2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     2f4:	31 97       	sbiw	r30, 0x01	; 1
     2f6:	39 e1       	ldi	r19, 0x19	; 25
     2f8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     2fa:	31 97       	sbiw	r30, 0x01	; 1
     2fc:	30 e2       	ldi	r19, 0x20	; 32
     2fe:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     300:	31 97       	sbiw	r30, 0x01	; 1
     302:	31 e2       	ldi	r19, 0x21	; 33
     304:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     306:	31 97       	sbiw	r30, 0x01	; 1
     308:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     30a:	31 97       	sbiw	r30, 0x01	; 1
     30c:	23 e2       	ldi	r18, 0x23	; 35
     30e:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     310:	31 97       	sbiw	r30, 0x01	; 1
     312:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     314:	31 97       	sbiw	r30, 0x01	; 1
     316:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     318:	31 97       	sbiw	r30, 0x01	; 1
     31a:	26 e2       	ldi	r18, 0x26	; 38
     31c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     31e:	31 97       	sbiw	r30, 0x01	; 1
     320:	27 e2       	ldi	r18, 0x27	; 39
     322:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     324:	31 97       	sbiw	r30, 0x01	; 1
     326:	28 e2       	ldi	r18, 0x28	; 40
     328:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     32a:	31 97       	sbiw	r30, 0x01	; 1
     32c:	29 e2       	ldi	r18, 0x29	; 41
     32e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     330:	31 97       	sbiw	r30, 0x01	; 1
     332:	20 e3       	ldi	r18, 0x30	; 48
     334:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     336:	31 97       	sbiw	r30, 0x01	; 1
     338:	21 e3       	ldi	r18, 0x31	; 49
     33a:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     33c:	86 97       	sbiw	r24, 0x26	; 38
     33e:	08 95       	ret

00000340 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
     340:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
     344:	8c e7       	ldi	r24, 0x7C	; 124
     346:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     34a:	8b e0       	ldi	r24, 0x0B	; 11
     34c:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
     350:	ef e6       	ldi	r30, 0x6F	; 111
     352:	f0 e0       	ldi	r31, 0x00	; 0
     354:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     356:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
     358:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     35a:	a0 91 50 07 	lds	r26, 0x0750
     35e:	b0 91 51 07 	lds	r27, 0x0751
     362:	cd 91       	ld	r28, X+
     364:	cd bf       	out	0x3d, r28	; 61
     366:	dd 91       	ld	r29, X+
     368:	de bf       	out	0x3e, r29	; 62
     36a:	ff 91       	pop	r31
     36c:	ef 91       	pop	r30
     36e:	df 91       	pop	r29
     370:	cf 91       	pop	r28
     372:	bf 91       	pop	r27
     374:	af 91       	pop	r26
     376:	9f 91       	pop	r25
     378:	8f 91       	pop	r24
     37a:	7f 91       	pop	r23
     37c:	6f 91       	pop	r22
     37e:	5f 91       	pop	r21
     380:	4f 91       	pop	r20
     382:	3f 91       	pop	r19
     384:	2f 91       	pop	r18
     386:	1f 91       	pop	r17
     388:	0f 91       	pop	r16
     38a:	ff 90       	pop	r15
     38c:	ef 90       	pop	r14
     38e:	df 90       	pop	r13
     390:	cf 90       	pop	r12
     392:	bf 90       	pop	r11
     394:	af 90       	pop	r10
     396:	9f 90       	pop	r9
     398:	8f 90       	pop	r8
     39a:	7f 90       	pop	r7
     39c:	6f 90       	pop	r6
     39e:	5f 90       	pop	r5
     3a0:	4f 90       	pop	r4
     3a2:	3f 90       	pop	r3
     3a4:	2f 90       	pop	r2
     3a6:	1f 90       	pop	r1
     3a8:	0f 90       	pop	r0
     3aa:	0f be       	out	0x3f, r0	; 63
     3ac:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     3ae:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     3b0:	81 e0       	ldi	r24, 0x01	; 1
     3b2:	08 95       	ret

000003b4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     3b4:	0f 92       	push	r0
     3b6:	0f b6       	in	r0, 0x3f	; 63
     3b8:	f8 94       	cli
     3ba:	0f 92       	push	r0
     3bc:	1f 92       	push	r1
     3be:	11 24       	eor	r1, r1
     3c0:	2f 92       	push	r2
     3c2:	3f 92       	push	r3
     3c4:	4f 92       	push	r4
     3c6:	5f 92       	push	r5
     3c8:	6f 92       	push	r6
     3ca:	7f 92       	push	r7
     3cc:	8f 92       	push	r8
     3ce:	9f 92       	push	r9
     3d0:	af 92       	push	r10
     3d2:	bf 92       	push	r11
     3d4:	cf 92       	push	r12
     3d6:	df 92       	push	r13
     3d8:	ef 92       	push	r14
     3da:	ff 92       	push	r15
     3dc:	0f 93       	push	r16
     3de:	1f 93       	push	r17
     3e0:	2f 93       	push	r18
     3e2:	3f 93       	push	r19
     3e4:	4f 93       	push	r20
     3e6:	5f 93       	push	r21
     3e8:	6f 93       	push	r22
     3ea:	7f 93       	push	r23
     3ec:	8f 93       	push	r24
     3ee:	9f 93       	push	r25
     3f0:	af 93       	push	r26
     3f2:	bf 93       	push	r27
     3f4:	cf 93       	push	r28
     3f6:	df 93       	push	r29
     3f8:	ef 93       	push	r30
     3fa:	ff 93       	push	r31
     3fc:	a0 91 50 07 	lds	r26, 0x0750
     400:	b0 91 51 07 	lds	r27, 0x0751
     404:	0d b6       	in	r0, 0x3d	; 61
     406:	0d 92       	st	X+, r0
     408:	0e b6       	in	r0, 0x3e	; 62
     40a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     40c:	0e 94 dc 05 	call	0xbb8	; 0xbb8 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     410:	a0 91 50 07 	lds	r26, 0x0750
     414:	b0 91 51 07 	lds	r27, 0x0751
     418:	cd 91       	ld	r28, X+
     41a:	cd bf       	out	0x3d, r28	; 61
     41c:	dd 91       	ld	r29, X+
     41e:	de bf       	out	0x3e, r29	; 62
     420:	ff 91       	pop	r31
     422:	ef 91       	pop	r30
     424:	df 91       	pop	r29
     426:	cf 91       	pop	r28
     428:	bf 91       	pop	r27
     42a:	af 91       	pop	r26
     42c:	9f 91       	pop	r25
     42e:	8f 91       	pop	r24
     430:	7f 91       	pop	r23
     432:	6f 91       	pop	r22
     434:	5f 91       	pop	r21
     436:	4f 91       	pop	r20
     438:	3f 91       	pop	r19
     43a:	2f 91       	pop	r18
     43c:	1f 91       	pop	r17
     43e:	0f 91       	pop	r16
     440:	ff 90       	pop	r15
     442:	ef 90       	pop	r14
     444:	df 90       	pop	r13
     446:	cf 90       	pop	r12
     448:	bf 90       	pop	r11
     44a:	af 90       	pop	r10
     44c:	9f 90       	pop	r9
     44e:	8f 90       	pop	r8
     450:	7f 90       	pop	r7
     452:	6f 90       	pop	r6
     454:	5f 90       	pop	r5
     456:	4f 90       	pop	r4
     458:	3f 90       	pop	r3
     45a:	2f 90       	pop	r2
     45c:	1f 90       	pop	r1
     45e:	0f 90       	pop	r0
     460:	0f be       	out	0x3f, r0	; 63
     462:	0f 90       	pop	r0

	asm volatile ( "ret" );
     464:	08 95       	ret

00000466 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     466:	0f 92       	push	r0
     468:	0f b6       	in	r0, 0x3f	; 63
     46a:	f8 94       	cli
     46c:	0f 92       	push	r0
     46e:	1f 92       	push	r1
     470:	11 24       	eor	r1, r1
     472:	2f 92       	push	r2
     474:	3f 92       	push	r3
     476:	4f 92       	push	r4
     478:	5f 92       	push	r5
     47a:	6f 92       	push	r6
     47c:	7f 92       	push	r7
     47e:	8f 92       	push	r8
     480:	9f 92       	push	r9
     482:	af 92       	push	r10
     484:	bf 92       	push	r11
     486:	cf 92       	push	r12
     488:	df 92       	push	r13
     48a:	ef 92       	push	r14
     48c:	ff 92       	push	r15
     48e:	0f 93       	push	r16
     490:	1f 93       	push	r17
     492:	2f 93       	push	r18
     494:	3f 93       	push	r19
     496:	4f 93       	push	r20
     498:	5f 93       	push	r21
     49a:	6f 93       	push	r22
     49c:	7f 93       	push	r23
     49e:	8f 93       	push	r24
     4a0:	9f 93       	push	r25
     4a2:	af 93       	push	r26
     4a4:	bf 93       	push	r27
     4a6:	cf 93       	push	r28
     4a8:	df 93       	push	r29
     4aa:	ef 93       	push	r30
     4ac:	ff 93       	push	r31
     4ae:	a0 91 50 07 	lds	r26, 0x0750
     4b2:	b0 91 51 07 	lds	r27, 0x0751
     4b6:	0d b6       	in	r0, 0x3d	; 61
     4b8:	0d 92       	st	X+, r0
     4ba:	0e b6       	in	r0, 0x3e	; 62
     4bc:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     4be:	0e 94 3c 04 	call	0x878	; 0x878 <xTaskIncrementTick>
     4c2:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     4c4:	0e 94 dc 05 	call	0xbb8	; 0xbb8 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     4c8:	a0 91 50 07 	lds	r26, 0x0750
     4cc:	b0 91 51 07 	lds	r27, 0x0751
     4d0:	cd 91       	ld	r28, X+
     4d2:	cd bf       	out	0x3d, r28	; 61
     4d4:	dd 91       	ld	r29, X+
     4d6:	de bf       	out	0x3e, r29	; 62
     4d8:	ff 91       	pop	r31
     4da:	ef 91       	pop	r30
     4dc:	df 91       	pop	r29
     4de:	cf 91       	pop	r28
     4e0:	bf 91       	pop	r27
     4e2:	af 91       	pop	r26
     4e4:	9f 91       	pop	r25
     4e6:	8f 91       	pop	r24
     4e8:	7f 91       	pop	r23
     4ea:	6f 91       	pop	r22
     4ec:	5f 91       	pop	r21
     4ee:	4f 91       	pop	r20
     4f0:	3f 91       	pop	r19
     4f2:	2f 91       	pop	r18
     4f4:	1f 91       	pop	r17
     4f6:	0f 91       	pop	r16
     4f8:	ff 90       	pop	r15
     4fa:	ef 90       	pop	r14
     4fc:	df 90       	pop	r13
     4fe:	cf 90       	pop	r12
     500:	bf 90       	pop	r11
     502:	af 90       	pop	r10
     504:	9f 90       	pop	r9
     506:	8f 90       	pop	r8
     508:	7f 90       	pop	r7
     50a:	6f 90       	pop	r6
     50c:	5f 90       	pop	r5
     50e:	4f 90       	pop	r4
     510:	3f 90       	pop	r3
     512:	2f 90       	pop	r2
     514:	1f 90       	pop	r1
     516:	0f 90       	pop	r0
     518:	0f be       	out	0x3f, r0	; 63
     51a:	0f 90       	pop	r0

	asm volatile ( "ret" );
     51c:	08 95       	ret

0000051e <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     51e:	0e 94 33 02 	call	0x466	; 0x466 <vPortYieldFromTick>
		asm volatile ( "reti" );
     522:	18 95       	reti

00000524 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     524:	cf 93       	push	r28
     526:	df 93       	push	r29
     528:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     52a:	0e 94 2c 04 	call	0x858	; 0x858 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     52e:	80 91 3c 01 	lds	r24, 0x013C
     532:	90 91 3d 01 	lds	r25, 0x013D
     536:	89 2b       	or	r24, r25
     538:	31 f4       	brne	.+12     	; 0x546 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     53a:	81 e4       	ldi	r24, 0x41	; 65
     53c:	91 e0       	ldi	r25, 0x01	; 1
     53e:	90 93 3d 01 	sts	0x013D, r25
     542:	80 93 3c 01 	sts	0x013C, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     546:	40 91 3e 01 	lds	r20, 0x013E
     54a:	50 91 3f 01 	lds	r21, 0x013F
     54e:	9e 01       	movw	r18, r28
     550:	24 0f       	add	r18, r20
     552:	35 1f       	adc	r19, r21
     554:	2b 3d       	cpi	r18, 0xDB	; 219
     556:	85 e0       	ldi	r24, 0x05	; 5
     558:	38 07       	cpc	r19, r24
     55a:	70 f4       	brcc	.+28     	; 0x578 <pvPortMalloc+0x54>
     55c:	42 17       	cp	r20, r18
     55e:	53 07       	cpc	r21, r19
     560:	70 f4       	brcc	.+28     	; 0x57e <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     562:	c0 91 3c 01 	lds	r28, 0x013C
     566:	d0 91 3d 01 	lds	r29, 0x013D
     56a:	c4 0f       	add	r28, r20
     56c:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     56e:	30 93 3f 01 	sts	0x013F, r19
     572:	20 93 3e 01 	sts	0x013E, r18
     576:	05 c0       	rjmp	.+10     	; 0x582 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     578:	c0 e0       	ldi	r28, 0x00	; 0
     57a:	d0 e0       	ldi	r29, 0x00	; 0
     57c:	02 c0       	rjmp	.+4      	; 0x582 <pvPortMalloc+0x5e>
     57e:	c0 e0       	ldi	r28, 0x00	; 0
     580:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     582:	0e 94 17 05 	call	0xa2e	; 0xa2e <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     586:	ce 01       	movw	r24, r28
     588:	df 91       	pop	r29
     58a:	cf 91       	pop	r28
     58c:	08 95       	ret

0000058e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     58e:	08 95       	ret

00000590 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     590:	c7 e4       	ldi	r28, 0x47	; 71
     592:	d7 e0       	ldi	r29, 0x07	; 7
     594:	88 81       	ld	r24, Y
     596:	82 30       	cpi	r24, 0x02	; 2
     598:	08 f4       	brcc	.+2      	; 0x59c <prvIdleTask+0xc>
     59a:	ff cf       	rjmp	.-2      	; 0x59a <prvIdleTask+0xa>
			{
				taskYIELD();
     59c:	0e 94 da 01 	call	0x3b4	; 0x3b4 <vPortYield>
     5a0:	f9 cf       	rjmp	.-14     	; 0x594 <prvIdleTask+0x4>

000005a2 <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
     5a2:	cf 93       	push	r28
     5a4:	df 93       	push	r29
     5a6:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
     5a8:	e0 91 50 07 	lds	r30, 0x0750
     5ac:	f0 91 51 07 	lds	r31, 0x0751
     5b0:	93 83       	std	Z+3, r25	; 0x03
     5b2:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
     5b4:	80 91 25 07 	lds	r24, 0x0725
     5b8:	90 91 26 07 	lds	r25, 0x0726
     5bc:	c8 17       	cp	r28, r24
     5be:	d9 07       	cpc	r29, r25
     5c0:	68 f4       	brcc	.+26     	; 0x5dc <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     5c2:	60 91 50 07 	lds	r22, 0x0750
     5c6:	70 91 51 07 	lds	r23, 0x0751
     5ca:	80 91 31 07 	lds	r24, 0x0731
     5ce:	90 91 32 07 	lds	r25, 0x0732
     5d2:	6e 5f       	subi	r22, 0xFE	; 254
     5d4:	7f 4f       	sbci	r23, 0xFF	; 255
     5d6:	0e 94 dd 00 	call	0x1ba	; 0x1ba <vListInsert>
     5da:	17 c0       	rjmp	.+46     	; 0x60a <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     5dc:	60 91 50 07 	lds	r22, 0x0750
     5e0:	70 91 51 07 	lds	r23, 0x0751
     5e4:	80 91 33 07 	lds	r24, 0x0733
     5e8:	90 91 34 07 	lds	r25, 0x0734
     5ec:	6e 5f       	subi	r22, 0xFE	; 254
     5ee:	7f 4f       	sbci	r23, 0xFF	; 255
     5f0:	0e 94 dd 00 	call	0x1ba	; 0x1ba <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
     5f4:	80 91 1d 07 	lds	r24, 0x071D
     5f8:	90 91 1e 07 	lds	r25, 0x071E
     5fc:	c8 17       	cp	r28, r24
     5fe:	d9 07       	cpc	r29, r25
     600:	20 f4       	brcc	.+8      	; 0x60a <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
     602:	d0 93 1e 07 	sts	0x071E, r29
     606:	c0 93 1d 07 	sts	0x071D, r28
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     60a:	df 91       	pop	r29
     60c:	cf 91       	pop	r28
     60e:	08 95       	ret

00000610 <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
     610:	5f 92       	push	r5
     612:	6f 92       	push	r6
     614:	7f 92       	push	r7
     616:	8f 92       	push	r8
     618:	9f 92       	push	r9
     61a:	af 92       	push	r10
     61c:	bf 92       	push	r11
     61e:	cf 92       	push	r12
     620:	df 92       	push	r13
     622:	ef 92       	push	r14
     624:	ff 92       	push	r15
     626:	0f 93       	push	r16
     628:	1f 93       	push	r17
     62a:	cf 93       	push	r28
     62c:	df 93       	push	r29
     62e:	4c 01       	movw	r8, r24
     630:	eb 01       	movw	r28, r22
     632:	3a 01       	movw	r6, r20
     634:	59 01       	movw	r10, r18
     636:	50 2e       	mov	r5, r16
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     638:	c1 14       	cp	r12, r1
     63a:	d1 04       	cpc	r13, r1
     63c:	39 f4       	brne	.+14     	; 0x64c <xTaskGenericCreate+0x3c>
     63e:	ca 01       	movw	r24, r20
     640:	0e 94 92 02 	call	0x524	; 0x524 <pvPortMalloc>
     644:	6c 01       	movw	r12, r24

		if( pxStack != NULL )
     646:	00 97       	sbiw	r24, 0x00	; 0
     648:	09 f4       	brne	.+2      	; 0x64c <xTaskGenericCreate+0x3c>
     64a:	a5 c0       	rjmp	.+330    	; 0x796 <xTaskGenericCreate+0x186>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
     64c:	86 e2       	ldi	r24, 0x26	; 38
     64e:	90 e0       	ldi	r25, 0x00	; 0
     650:	0e 94 92 02 	call	0x524	; 0x524 <pvPortMalloc>
     654:	8c 01       	movw	r16, r24

			if( pxNewTCB != NULL )
     656:	00 97       	sbiw	r24, 0x00	; 0
     658:	79 f0       	breq	.+30     	; 0x678 <xTaskGenericCreate+0x68>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
     65a:	fc 01       	movw	r30, r24
     65c:	d0 8e       	std	Z+24, r13	; 0x18
     65e:	c7 8a       	std	Z+23, r12	; 0x17
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
     660:	f1 e0       	ldi	r31, 0x01	; 1
     662:	6f 1a       	sub	r6, r31
     664:	71 08       	sbc	r7, r1
     666:	c6 0c       	add	r12, r6
     668:	d7 1c       	adc	r13, r7
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
     66a:	88 81       	ld	r24, Y
     66c:	f8 01       	movw	r30, r16
     66e:	81 8f       	std	Z+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     670:	88 81       	ld	r24, Y
     672:	81 11       	cpse	r24, r1
     674:	05 c0       	rjmp	.+10     	; 0x680 <xTaskGenericCreate+0x70>
     676:	10 c0       	rjmp	.+32     	; 0x698 <xTaskGenericCreate+0x88>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
     678:	c6 01       	movw	r24, r12
     67a:	0e 94 c7 02 	call	0x58e	; 0x58e <vPortFree>
     67e:	8b c0       	rjmp	.+278    	; 0x796 <xTaskGenericCreate+0x186>
     680:	f8 01       	movw	r30, r16
     682:	7a 96       	adiw	r30, 0x1a	; 26
     684:	21 96       	adiw	r28, 0x01	; 1
		pxTCB->pcTaskName[ x ] = pcName[ x ];

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     686:	87 e0       	ldi	r24, 0x07	; 7
     688:	de 01       	movw	r26, r28
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
     68a:	99 91       	ld	r25, Y+
     68c:	91 93       	st	Z+, r25

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     68e:	9c 91       	ld	r25, X
     690:	99 23       	and	r25, r25
     692:	11 f0       	breq	.+4      	; 0x698 <xTaskGenericCreate+0x88>
     694:	81 50       	subi	r24, 0x01	; 1
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     696:	c1 f7       	brne	.-16     	; 0x688 <xTaskGenericCreate+0x78>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     698:	f8 01       	movw	r30, r16
     69a:	10 a2       	std	Z+32, r1	; 0x20
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
     69c:	16 8a       	std	Z+22, r1	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
     69e:	e8 01       	movw	r28, r16
     6a0:	22 96       	adiw	r28, 0x02	; 2
     6a2:	ce 01       	movw	r24, r28
     6a4:	0e 94 b8 00 	call	0x170	; 0x170 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
     6a8:	c8 01       	movw	r24, r16
     6aa:	0c 96       	adiw	r24, 0x0c	; 12
     6ac:	0e 94 b8 00 	call	0x170	; 0x170 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
     6b0:	f8 01       	movw	r30, r16
     6b2:	11 87       	std	Z+9, r17	; 0x09
     6b4:	00 87       	std	Z+8, r16	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     6b6:	81 e0       	ldi	r24, 0x01	; 1
     6b8:	90 e0       	ldi	r25, 0x00	; 0
     6ba:	95 87       	std	Z+13, r25	; 0x0d
     6bc:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
     6be:	13 8b       	std	Z+19, r17	; 0x13
     6c0:	02 8b       	std	Z+18, r16	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
     6c2:	11 a2       	std	Z+33, r1	; 0x21
     6c4:	12 a2       	std	Z+34, r1	; 0x22
     6c6:	13 a2       	std	Z+35, r1	; 0x23
     6c8:	14 a2       	std	Z+36, r1	; 0x24
		pxTCB->eNotifyState = eNotWaitingNotification;
     6ca:	15 a2       	std	Z+37, r1	; 0x25
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     6cc:	a5 01       	movw	r20, r10
     6ce:	b4 01       	movw	r22, r8
     6d0:	c6 01       	movw	r24, r12
     6d2:	0e 94 34 01 	call	0x268	; 0x268 <pxPortInitialiseStack>
     6d6:	f8 01       	movw	r30, r16
     6d8:	91 83       	std	Z+1, r25	; 0x01
     6da:	80 83       	st	Z, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
     6dc:	e1 14       	cp	r14, r1
     6de:	f1 04       	cpc	r15, r1
     6e0:	19 f0       	breq	.+6      	; 0x6e8 <xTaskGenericCreate+0xd8>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     6e2:	f7 01       	movw	r30, r14
     6e4:	11 83       	std	Z+1, r17	; 0x01
     6e6:	00 83       	st	Z, r16
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
     6e8:	0f b6       	in	r0, 0x3f	; 63
     6ea:	f8 94       	cli
     6ec:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
     6ee:	80 91 27 07 	lds	r24, 0x0727
     6f2:	8f 5f       	subi	r24, 0xFF	; 255
     6f4:	80 93 27 07 	sts	0x0727, r24
			if( pxCurrentTCB == NULL )
     6f8:	80 91 50 07 	lds	r24, 0x0750
     6fc:	90 91 51 07 	lds	r25, 0x0751
     700:	89 2b       	or	r24, r25
     702:	49 f4       	brne	.+18     	; 0x716 <xTaskGenericCreate+0x106>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
     704:	10 93 51 07 	sts	0x0751, r17
     708:	00 93 50 07 	sts	0x0750, r16

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     70c:	80 91 27 07 	lds	r24, 0x0727
     710:	81 30       	cpi	r24, 0x01	; 1
     712:	81 f4       	brne	.+32     	; 0x734 <xTaskGenericCreate+0x124>
     714:	42 c0       	rjmp	.+132    	; 0x79a <xTaskGenericCreate+0x18a>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
     716:	80 91 23 07 	lds	r24, 0x0723
     71a:	81 11       	cpse	r24, r1
     71c:	0b c0       	rjmp	.+22     	; 0x734 <xTaskGenericCreate+0x124>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
     71e:	e0 91 50 07 	lds	r30, 0x0750
     722:	f0 91 51 07 	lds	r31, 0x0751
     726:	86 89       	ldd	r24, Z+22	; 0x16
     728:	58 16       	cp	r5, r24
     72a:	20 f0       	brcs	.+8      	; 0x734 <xTaskGenericCreate+0x124>
					{
						pxCurrentTCB = pxNewTCB;
     72c:	10 93 51 07 	sts	0x0751, r17
     730:	00 93 50 07 	sts	0x0750, r16
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
     734:	80 91 1f 07 	lds	r24, 0x071F
     738:	8f 5f       	subi	r24, 0xFF	; 255
     73a:	80 93 1f 07 	sts	0x071F, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
     73e:	f8 01       	movw	r30, r16
     740:	86 89       	ldd	r24, Z+22	; 0x16
     742:	90 91 24 07 	lds	r25, 0x0724
     746:	98 17       	cp	r25, r24
     748:	10 f4       	brcc	.+4      	; 0x74e <xTaskGenericCreate+0x13e>
     74a:	80 93 24 07 	sts	0x0724, r24
     74e:	90 e0       	ldi	r25, 0x00	; 0
     750:	9c 01       	movw	r18, r24
     752:	22 0f       	add	r18, r18
     754:	33 1f       	adc	r19, r19
     756:	22 0f       	add	r18, r18
     758:	33 1f       	adc	r19, r19
     75a:	22 0f       	add	r18, r18
     75c:	33 1f       	adc	r19, r19
     75e:	82 0f       	add	r24, r18
     760:	93 1f       	adc	r25, r19
     762:	be 01       	movw	r22, r28
     764:	89 5b       	subi	r24, 0xB9	; 185
     766:	98 4f       	sbci	r25, 0xF8	; 248
     768:	0e 94 bc 00 	call	0x178	; 0x178 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
     76c:	0f 90       	pop	r0
     76e:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
     770:	80 91 23 07 	lds	r24, 0x0723
     774:	88 23       	and	r24, r24
     776:	59 f0       	breq	.+22     	; 0x78e <xTaskGenericCreate+0x17e>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
     778:	e0 91 50 07 	lds	r30, 0x0750
     77c:	f0 91 51 07 	lds	r31, 0x0751
     780:	86 89       	ldd	r24, Z+22	; 0x16
     782:	85 15       	cp	r24, r5
     784:	30 f4       	brcc	.+12     	; 0x792 <xTaskGenericCreate+0x182>
			{
				taskYIELD_IF_USING_PREEMPTION();
     786:	0e 94 da 01 	call	0x3b4	; 0x3b4 <vPortYield>
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );

			xReturn = pdPASS;
     78a:	81 e0       	ldi	r24, 0x01	; 1
     78c:	23 c0       	rjmp	.+70     	; 0x7d4 <xTaskGenericCreate+0x1c4>
     78e:	81 e0       	ldi	r24, 0x01	; 1
     790:	21 c0       	rjmp	.+66     	; 0x7d4 <xTaskGenericCreate+0x1c4>
     792:	81 e0       	ldi	r24, 0x01	; 1
     794:	1f c0       	rjmp	.+62     	; 0x7d4 <xTaskGenericCreate+0x1c4>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     796:	8f ef       	ldi	r24, 0xFF	; 255
     798:	1d c0       	rjmp	.+58     	; 0x7d4 <xTaskGenericCreate+0x1c4>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     79a:	87 e4       	ldi	r24, 0x47	; 71
     79c:	97 e0       	ldi	r25, 0x07	; 7
     79e:	0e 94 aa 00 	call	0x154	; 0x154 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     7a2:	8e e3       	ldi	r24, 0x3E	; 62
     7a4:	97 e0       	ldi	r25, 0x07	; 7
     7a6:	0e 94 aa 00 	call	0x154	; 0x154 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     7aa:	85 e3       	ldi	r24, 0x35	; 53
     7ac:	97 e0       	ldi	r25, 0x07	; 7
     7ae:	0e 94 aa 00 	call	0x154	; 0x154 <vListInitialise>
	vListInitialise( &xPendingReadyList );
     7b2:	88 e2       	ldi	r24, 0x28	; 40
     7b4:	97 e0       	ldi	r25, 0x07	; 7
     7b6:	0e 94 aa 00 	call	0x154	; 0x154 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     7ba:	8e e3       	ldi	r24, 0x3E	; 62
     7bc:	97 e0       	ldi	r25, 0x07	; 7
     7be:	90 93 34 07 	sts	0x0734, r25
     7c2:	80 93 33 07 	sts	0x0733, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     7c6:	85 e3       	ldi	r24, 0x35	; 53
     7c8:	97 e0       	ldi	r25, 0x07	; 7
     7ca:	90 93 32 07 	sts	0x0732, r25
     7ce:	80 93 31 07 	sts	0x0731, r24
     7d2:	b0 cf       	rjmp	.-160    	; 0x734 <xTaskGenericCreate+0x124>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
     7d4:	df 91       	pop	r29
     7d6:	cf 91       	pop	r28
     7d8:	1f 91       	pop	r17
     7da:	0f 91       	pop	r16
     7dc:	ff 90       	pop	r15
     7de:	ef 90       	pop	r14
     7e0:	df 90       	pop	r13
     7e2:	cf 90       	pop	r12
     7e4:	bf 90       	pop	r11
     7e6:	af 90       	pop	r10
     7e8:	9f 90       	pop	r9
     7ea:	8f 90       	pop	r8
     7ec:	7f 90       	pop	r7
     7ee:	6f 90       	pop	r6
     7f0:	5f 90       	pop	r5
     7f2:	08 95       	ret

000007f4 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     7f4:	af 92       	push	r10
     7f6:	bf 92       	push	r11
     7f8:	cf 92       	push	r12
     7fa:	df 92       	push	r13
     7fc:	ef 92       	push	r14
     7fe:	ff 92       	push	r15
     800:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
     802:	a1 2c       	mov	r10, r1
     804:	b1 2c       	mov	r11, r1
     806:	c1 2c       	mov	r12, r1
     808:	d1 2c       	mov	r13, r1
     80a:	e1 2c       	mov	r14, r1
     80c:	f1 2c       	mov	r15, r1
     80e:	00 e0       	ldi	r16, 0x00	; 0
     810:	20 e0       	ldi	r18, 0x00	; 0
     812:	30 e0       	ldi	r19, 0x00	; 0
     814:	45 e5       	ldi	r20, 0x55	; 85
     816:	50 e0       	ldi	r21, 0x00	; 0
     818:	66 e3       	ldi	r22, 0x36	; 54
     81a:	71 e0       	ldi	r23, 0x01	; 1
     81c:	88 ec       	ldi	r24, 0xC8	; 200
     81e:	92 e0       	ldi	r25, 0x02	; 2
     820:	0e 94 08 03 	call	0x610	; 0x610 <xTaskGenericCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     824:	81 30       	cpi	r24, 0x01	; 1
     826:	81 f4       	brne	.+32     	; 0x848 <vTaskStartScheduler+0x54>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     828:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
     82a:	8f ef       	ldi	r24, 0xFF	; 255
     82c:	9f ef       	ldi	r25, 0xFF	; 255
     82e:	90 93 1e 07 	sts	0x071E, r25
     832:	80 93 1d 07 	sts	0x071D, r24
		xSchedulerRunning = pdTRUE;
     836:	81 e0       	ldi	r24, 0x01	; 1
     838:	80 93 23 07 	sts	0x0723, r24
		xTickCount = ( TickType_t ) 0U;
     83c:	10 92 26 07 	sts	0x0726, r1
     840:	10 92 25 07 	sts	0x0725, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     844:	0e 94 a0 01 	call	0x340	; 0x340 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
     848:	0f 91       	pop	r16
     84a:	ff 90       	pop	r15
     84c:	ef 90       	pop	r14
     84e:	df 90       	pop	r13
     850:	cf 90       	pop	r12
     852:	bf 90       	pop	r11
     854:	af 90       	pop	r10
     856:	08 95       	ret

00000858 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     858:	80 91 1c 07 	lds	r24, 0x071C
     85c:	8f 5f       	subi	r24, 0xFF	; 255
     85e:	80 93 1c 07 	sts	0x071C, r24
     862:	08 95       	ret

00000864 <xTaskGetTickCount>:
TickType_t xTaskGetTickCount( void )
{
TickType_t xTicks;

	/* Critical section required if running on a 16 bit processor. */
	portTICK_TYPE_ENTER_CRITICAL();
     864:	0f b6       	in	r0, 0x3f	; 63
     866:	f8 94       	cli
     868:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     86a:	80 91 25 07 	lds	r24, 0x0725
     86e:	90 91 26 07 	lds	r25, 0x0726
	}
	portTICK_TYPE_EXIT_CRITICAL();
     872:	0f 90       	pop	r0
     874:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     876:	08 95       	ret

00000878 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     878:	cf 92       	push	r12
     87a:	df 92       	push	r13
     87c:	ef 92       	push	r14
     87e:	ff 92       	push	r15
     880:	0f 93       	push	r16
     882:	1f 93       	push	r17
     884:	cf 93       	push	r28
     886:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     888:	80 91 1c 07 	lds	r24, 0x071C
     88c:	81 11       	cpse	r24, r1
     88e:	b6 c0       	rjmp	.+364    	; 0x9fc <__stack+0xfd>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
     890:	80 91 25 07 	lds	r24, 0x0725
     894:	90 91 26 07 	lds	r25, 0x0726
     898:	01 96       	adiw	r24, 0x01	; 1
     89a:	90 93 26 07 	sts	0x0726, r25
     89e:	80 93 25 07 	sts	0x0725, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     8a2:	e0 90 25 07 	lds	r14, 0x0725
     8a6:	f0 90 26 07 	lds	r15, 0x0726

			if( xConstTickCount == ( TickType_t ) 0U )
     8aa:	e1 14       	cp	r14, r1
     8ac:	f1 04       	cpc	r15, r1
     8ae:	99 f5       	brne	.+102    	; 0x916 <__stack+0x17>
			{
				taskSWITCH_DELAYED_LISTS();
     8b0:	80 91 33 07 	lds	r24, 0x0733
     8b4:	90 91 34 07 	lds	r25, 0x0734
     8b8:	20 91 31 07 	lds	r18, 0x0731
     8bc:	30 91 32 07 	lds	r19, 0x0732
     8c0:	30 93 34 07 	sts	0x0734, r19
     8c4:	20 93 33 07 	sts	0x0733, r18
     8c8:	90 93 32 07 	sts	0x0732, r25
     8cc:	80 93 31 07 	sts	0x0731, r24
     8d0:	80 91 20 07 	lds	r24, 0x0720
     8d4:	8f 5f       	subi	r24, 0xFF	; 255
     8d6:	80 93 20 07 	sts	0x0720, r24

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     8da:	e0 91 33 07 	lds	r30, 0x0733
     8de:	f0 91 34 07 	lds	r31, 0x0734
     8e2:	80 81       	ld	r24, Z
     8e4:	81 11       	cpse	r24, r1
     8e6:	07 c0       	rjmp	.+14     	; 0x8f6 <xTaskIncrementTick+0x7e>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     8e8:	8f ef       	ldi	r24, 0xFF	; 255
     8ea:	9f ef       	ldi	r25, 0xFF	; 255
     8ec:	90 93 1e 07 	sts	0x071E, r25
     8f0:	80 93 1d 07 	sts	0x071D, r24
     8f4:	10 c0       	rjmp	.+32     	; 0x916 <__stack+0x17>
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     8f6:	e0 91 33 07 	lds	r30, 0x0733
     8fa:	f0 91 34 07 	lds	r31, 0x0734
     8fe:	05 80       	ldd	r0, Z+5	; 0x05
     900:	f6 81       	ldd	r31, Z+6	; 0x06
     902:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
     904:	06 80       	ldd	r0, Z+6	; 0x06
     906:	f7 81       	ldd	r31, Z+7	; 0x07
     908:	e0 2d       	mov	r30, r0
     90a:	82 81       	ldd	r24, Z+2	; 0x02
     90c:	93 81       	ldd	r25, Z+3	; 0x03
     90e:	90 93 1e 07 	sts	0x071E, r25
     912:	80 93 1d 07 	sts	0x071D, r24

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
     916:	80 91 1d 07 	lds	r24, 0x071D
     91a:	90 91 1e 07 	lds	r25, 0x071E
     91e:	e8 16       	cp	r14, r24
     920:	f9 06       	cpc	r15, r25
     922:	08 f4       	brcc	.+2      	; 0x926 <__stack+0x27>
     924:	54 c0       	rjmp	.+168    	; 0x9ce <__stack+0xcf>
     926:	d1 2c       	mov	r13, r1
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
							{
								xSwitchRequired = pdTRUE;
     928:	cc 24       	eor	r12, r12
     92a:	c3 94       	inc	r12
     92c:	01 c0       	rjmp	.+2      	; 0x930 <__stack+0x31>
     92e:	dc 2c       	mov	r13, r12
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     930:	e0 91 33 07 	lds	r30, 0x0733
     934:	f0 91 34 07 	lds	r31, 0x0734
     938:	80 81       	ld	r24, Z
     93a:	81 11       	cpse	r24, r1
     93c:	07 c0       	rjmp	.+14     	; 0x94c <__stack+0x4d>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
     93e:	8f ef       	ldi	r24, 0xFF	; 255
     940:	9f ef       	ldi	r25, 0xFF	; 255
     942:	90 93 1e 07 	sts	0x071E, r25
     946:	80 93 1d 07 	sts	0x071D, r24
						break;
     94a:	42 c0       	rjmp	.+132    	; 0x9d0 <__stack+0xd1>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     94c:	e0 91 33 07 	lds	r30, 0x0733
     950:	f0 91 34 07 	lds	r31, 0x0734
     954:	05 80       	ldd	r0, Z+5	; 0x05
     956:	f6 81       	ldd	r31, Z+6	; 0x06
     958:	e0 2d       	mov	r30, r0
     95a:	c6 81       	ldd	r28, Z+6	; 0x06
     95c:	d7 81       	ldd	r29, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
     95e:	2a 81       	ldd	r18, Y+2	; 0x02
     960:	3b 81       	ldd	r19, Y+3	; 0x03

						if( xConstTickCount < xItemValue )
     962:	e2 16       	cp	r14, r18
     964:	f3 06       	cpc	r15, r19
     966:	28 f4       	brcc	.+10     	; 0x972 <__stack+0x73>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
     968:	30 93 1e 07 	sts	0x071E, r19
     96c:	20 93 1d 07 	sts	0x071D, r18
							break;
     970:	2f c0       	rjmp	.+94     	; 0x9d0 <__stack+0xd1>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     972:	8e 01       	movw	r16, r28
     974:	0e 5f       	subi	r16, 0xFE	; 254
     976:	1f 4f       	sbci	r17, 0xFF	; 255
     978:	c8 01       	movw	r24, r16
     97a:	0e 94 0e 01 	call	0x21c	; 0x21c <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     97e:	8c 89       	ldd	r24, Y+20	; 0x14
     980:	9d 89       	ldd	r25, Y+21	; 0x15
     982:	89 2b       	or	r24, r25
     984:	21 f0       	breq	.+8      	; 0x98e <__stack+0x8f>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     986:	ce 01       	movw	r24, r28
     988:	0c 96       	adiw	r24, 0x0c	; 12
     98a:	0e 94 0e 01 	call	0x21c	; 0x21c <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
     98e:	2e 89       	ldd	r18, Y+22	; 0x16
     990:	80 91 24 07 	lds	r24, 0x0724
     994:	82 17       	cp	r24, r18
     996:	10 f4       	brcc	.+4      	; 0x99c <__stack+0x9d>
     998:	20 93 24 07 	sts	0x0724, r18
     99c:	30 e0       	ldi	r19, 0x00	; 0
     99e:	c9 01       	movw	r24, r18
     9a0:	88 0f       	add	r24, r24
     9a2:	99 1f       	adc	r25, r25
     9a4:	88 0f       	add	r24, r24
     9a6:	99 1f       	adc	r25, r25
     9a8:	88 0f       	add	r24, r24
     9aa:	99 1f       	adc	r25, r25
     9ac:	82 0f       	add	r24, r18
     9ae:	93 1f       	adc	r25, r19
     9b0:	b8 01       	movw	r22, r16
     9b2:	89 5b       	subi	r24, 0xB9	; 185
     9b4:	98 4f       	sbci	r25, 0xF8	; 248
     9b6:	0e 94 bc 00 	call	0x178	; 0x178 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     9ba:	e0 91 50 07 	lds	r30, 0x0750
     9be:	f0 91 51 07 	lds	r31, 0x0751
     9c2:	9e 89       	ldd	r25, Y+22	; 0x16
     9c4:	86 89       	ldd	r24, Z+22	; 0x16
     9c6:	98 17       	cp	r25, r24
     9c8:	08 f0       	brcs	.+2      	; 0x9cc <__stack+0xcd>
     9ca:	b1 cf       	rjmp	.-158    	; 0x92e <__stack+0x2f>
     9cc:	b1 cf       	rjmp	.-158    	; 0x930 <__stack+0x31>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     9ce:	d1 2c       	mov	r13, r1
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     9d0:	e0 91 50 07 	lds	r30, 0x0750
     9d4:	f0 91 51 07 	lds	r31, 0x0751
     9d8:	86 89       	ldd	r24, Z+22	; 0x16
     9da:	90 e0       	ldi	r25, 0x00	; 0
     9dc:	fc 01       	movw	r30, r24
     9de:	ee 0f       	add	r30, r30
     9e0:	ff 1f       	adc	r31, r31
     9e2:	ee 0f       	add	r30, r30
     9e4:	ff 1f       	adc	r31, r31
     9e6:	ee 0f       	add	r30, r30
     9e8:	ff 1f       	adc	r31, r31
     9ea:	8e 0f       	add	r24, r30
     9ec:	9f 1f       	adc	r25, r31
     9ee:	fc 01       	movw	r30, r24
     9f0:	e9 5b       	subi	r30, 0xB9	; 185
     9f2:	f8 4f       	sbci	r31, 0xF8	; 248
     9f4:	80 81       	ld	r24, Z
     9f6:	82 30       	cpi	r24, 0x02	; 2
     9f8:	40 f4       	brcc	.+16     	; 0xa0a <__stack+0x10b>
     9fa:	09 c0       	rjmp	.+18     	; 0xa0e <__stack+0x10f>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     9fc:	80 91 22 07 	lds	r24, 0x0722
     a00:	8f 5f       	subi	r24, 0xFF	; 255
     a02:	80 93 22 07 	sts	0x0722, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     a06:	d1 2c       	mov	r13, r1
     a08:	02 c0       	rjmp	.+4      	; 0xa0e <__stack+0x10f>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
     a0a:	dd 24       	eor	r13, r13
     a0c:	d3 94       	inc	r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     a0e:	80 91 21 07 	lds	r24, 0x0721
     a12:	88 23       	and	r24, r24
     a14:	11 f0       	breq	.+4      	; 0xa1a <__stack+0x11b>
		{
			xSwitchRequired = pdTRUE;
     a16:	dd 24       	eor	r13, r13
     a18:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     a1a:	8d 2d       	mov	r24, r13
     a1c:	df 91       	pop	r29
     a1e:	cf 91       	pop	r28
     a20:	1f 91       	pop	r17
     a22:	0f 91       	pop	r16
     a24:	ff 90       	pop	r15
     a26:	ef 90       	pop	r14
     a28:	df 90       	pop	r13
     a2a:	cf 90       	pop	r12
     a2c:	08 95       	ret

00000a2e <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     a2e:	df 92       	push	r13
     a30:	ef 92       	push	r14
     a32:	ff 92       	push	r15
     a34:	0f 93       	push	r16
     a36:	1f 93       	push	r17
     a38:	cf 93       	push	r28
     a3a:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     a3c:	0f b6       	in	r0, 0x3f	; 63
     a3e:	f8 94       	cli
     a40:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     a42:	80 91 1c 07 	lds	r24, 0x071C
     a46:	81 50       	subi	r24, 0x01	; 1
     a48:	80 93 1c 07 	sts	0x071C, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     a4c:	80 91 1c 07 	lds	r24, 0x071C
     a50:	81 11       	cpse	r24, r1
     a52:	61 c0       	rjmp	.+194    	; 0xb16 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     a54:	80 91 27 07 	lds	r24, 0x0727
     a58:	88 23       	and	r24, r24
     a5a:	09 f4       	brne	.+2      	; 0xa5e <xTaskResumeAll+0x30>
     a5c:	5e c0       	rjmp	.+188    	; 0xb1a <xTaskResumeAll+0xec>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     a5e:	0f 2e       	mov	r0, r31
     a60:	f8 e2       	ldi	r31, 0x28	; 40
     a62:	ef 2e       	mov	r14, r31
     a64:	f7 e0       	ldi	r31, 0x07	; 7
     a66:	ff 2e       	mov	r15, r31
     a68:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     a6a:	dd 24       	eor	r13, r13
     a6c:	d3 94       	inc	r13
     a6e:	30 c0       	rjmp	.+96     	; 0xad0 <xTaskResumeAll+0xa2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     a70:	e0 91 2d 07 	lds	r30, 0x072D
     a74:	f0 91 2e 07 	lds	r31, 0x072E
     a78:	c6 81       	ldd	r28, Z+6	; 0x06
     a7a:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     a7c:	ce 01       	movw	r24, r28
     a7e:	0c 96       	adiw	r24, 0x0c	; 12
     a80:	0e 94 0e 01 	call	0x21c	; 0x21c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     a84:	8e 01       	movw	r16, r28
     a86:	0e 5f       	subi	r16, 0xFE	; 254
     a88:	1f 4f       	sbci	r17, 0xFF	; 255
     a8a:	c8 01       	movw	r24, r16
     a8c:	0e 94 0e 01 	call	0x21c	; 0x21c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     a90:	8e 89       	ldd	r24, Y+22	; 0x16
     a92:	90 91 24 07 	lds	r25, 0x0724
     a96:	98 17       	cp	r25, r24
     a98:	10 f4       	brcc	.+4      	; 0xa9e <xTaskResumeAll+0x70>
     a9a:	80 93 24 07 	sts	0x0724, r24
     a9e:	90 e0       	ldi	r25, 0x00	; 0
     aa0:	9c 01       	movw	r18, r24
     aa2:	22 0f       	add	r18, r18
     aa4:	33 1f       	adc	r19, r19
     aa6:	22 0f       	add	r18, r18
     aa8:	33 1f       	adc	r19, r19
     aaa:	22 0f       	add	r18, r18
     aac:	33 1f       	adc	r19, r19
     aae:	82 0f       	add	r24, r18
     ab0:	93 1f       	adc	r25, r19
     ab2:	b8 01       	movw	r22, r16
     ab4:	89 5b       	subi	r24, 0xB9	; 185
     ab6:	98 4f       	sbci	r25, 0xF8	; 248
     ab8:	0e 94 bc 00 	call	0x178	; 0x178 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     abc:	e0 91 50 07 	lds	r30, 0x0750
     ac0:	f0 91 51 07 	lds	r31, 0x0751
     ac4:	9e 89       	ldd	r25, Y+22	; 0x16
     ac6:	86 89       	ldd	r24, Z+22	; 0x16
     ac8:	98 17       	cp	r25, r24
     aca:	10 f0       	brcs	.+4      	; 0xad0 <xTaskResumeAll+0xa2>
					{
						xYieldPending = pdTRUE;
     acc:	d0 92 21 07 	sts	0x0721, r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     ad0:	f7 01       	movw	r30, r14
     ad2:	80 81       	ld	r24, Z
     ad4:	81 11       	cpse	r24, r1
     ad6:	cc cf       	rjmp	.-104    	; 0xa70 <xTaskResumeAll+0x42>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
     ad8:	80 91 22 07 	lds	r24, 0x0722
     adc:	88 23       	and	r24, r24
     ade:	99 f0       	breq	.+38     	; 0xb06 <xTaskResumeAll+0xd8>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
     ae0:	80 91 22 07 	lds	r24, 0x0722
     ae4:	88 23       	and	r24, r24
     ae6:	79 f0       	breq	.+30     	; 0xb06 <xTaskResumeAll+0xd8>
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
     ae8:	c1 e0       	ldi	r28, 0x01	; 1
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
     aea:	0e 94 3c 04 	call	0x878	; 0x878 <xTaskIncrementTick>
     aee:	81 11       	cpse	r24, r1
						{
							xYieldPending = pdTRUE;
     af0:	c0 93 21 07 	sts	0x0721, r28
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
     af4:	80 91 22 07 	lds	r24, 0x0722
     af8:	81 50       	subi	r24, 0x01	; 1
     afa:	80 93 22 07 	sts	0x0722, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
     afe:	80 91 22 07 	lds	r24, 0x0722
     b02:	81 11       	cpse	r24, r1
     b04:	f2 cf       	rjmp	.-28     	; 0xaea <xTaskResumeAll+0xbc>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
     b06:	80 91 21 07 	lds	r24, 0x0721
     b0a:	81 30       	cpi	r24, 0x01	; 1
     b0c:	41 f4       	brne	.+16     	; 0xb1e <xTaskResumeAll+0xf0>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     b0e:	0e 94 da 01 	call	0x3b4	; 0x3b4 <vPortYield>

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     b12:	81 e0       	ldi	r24, 0x01	; 1
     b14:	05 c0       	rjmp	.+10     	; 0xb20 <xTaskResumeAll+0xf2>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
     b16:	80 e0       	ldi	r24, 0x00	; 0
     b18:	03 c0       	rjmp	.+6      	; 0xb20 <xTaskResumeAll+0xf2>
     b1a:	80 e0       	ldi	r24, 0x00	; 0
     b1c:	01 c0       	rjmp	.+2      	; 0xb20 <xTaskResumeAll+0xf2>
     b1e:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     b20:	0f 90       	pop	r0
     b22:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     b24:	df 91       	pop	r29
     b26:	cf 91       	pop	r28
     b28:	1f 91       	pop	r17
     b2a:	0f 91       	pop	r16
     b2c:	ff 90       	pop	r15
     b2e:	ef 90       	pop	r14
     b30:	df 90       	pop	r13
     b32:	08 95       	ret

00000b34 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
	{
     b34:	0f 93       	push	r16
     b36:	1f 93       	push	r17
     b38:	cf 93       	push	r28
     b3a:	df 93       	push	r29
     b3c:	8c 01       	movw	r16, r24
     b3e:	eb 01       	movw	r28, r22

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );
		configASSERT( uxSchedulerSuspended == 0 );

		vTaskSuspendAll();
     b40:	0e 94 2c 04 	call	0x858	; 0x858 <vTaskSuspendAll>
		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     b44:	80 91 25 07 	lds	r24, 0x0725
     b48:	90 91 26 07 	lds	r25, 0x0726

			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     b4c:	f8 01       	movw	r30, r16
     b4e:	20 81       	ld	r18, Z
     b50:	31 81       	ldd	r19, Z+1	; 0x01
     b52:	c2 0f       	add	r28, r18
     b54:	d3 1f       	adc	r29, r19

			if( xConstTickCount < *pxPreviousWakeTime )
     b56:	82 17       	cp	r24, r18
     b58:	93 07       	cpc	r25, r19
     b5a:	48 f4       	brcc	.+18     	; 0xb6e <vTaskDelayUntil+0x3a>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
     b5c:	c2 17       	cp	r28, r18
     b5e:	d3 07       	cpc	r29, r19
     b60:	10 f5       	brcc	.+68     	; 0xba6 <vTaskDelayUntil+0x72>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     b62:	d1 83       	std	Z+1, r29	; 0x01
     b64:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
     b66:	8c 17       	cp	r24, r28
     b68:	9d 07       	cpc	r25, r29
     b6a:	90 f4       	brcc	.+36     	; 0xb90 <vTaskDelayUntil+0x5c>
     b6c:	07 c0       	rjmp	.+14     	; 0xb7c <vTaskDelayUntil+0x48>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
     b6e:	c2 17       	cp	r28, r18
     b70:	d3 07       	cpc	r29, r19
     b72:	a8 f0       	brcs	.+42     	; 0xb9e <vTaskDelayUntil+0x6a>
     b74:	8c 17       	cp	r24, r28
     b76:	9d 07       	cpc	r25, r29
     b78:	90 f0       	brcs	.+36     	; 0xb9e <vTaskDelayUntil+0x6a>
     b7a:	15 c0       	rjmp	.+42     	; 0xba6 <vTaskDelayUntil+0x72>
			{
				traceTASK_DELAY_UNTIL();

				/* Remove the task from the ready list before adding it to the
				blocked list as the same list item is used for both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
     b7c:	80 91 50 07 	lds	r24, 0x0750
     b80:	90 91 51 07 	lds	r25, 0x0751
     b84:	02 96       	adiw	r24, 0x02	; 2
     b86:	0e 94 0e 01 	call	0x21c	; 0x21c <uxListRemove>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
     b8a:	ce 01       	movw	r24, r28
     b8c:	0e 94 d1 02 	call	0x5a2	; 0x5a2 <prvAddCurrentTaskToDelayedList>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     b90:	0e 94 17 05 	call	0xa2e	; 0xa2e <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     b94:	81 11       	cpse	r24, r1
     b96:	0b c0       	rjmp	.+22     	; 0xbae <vTaskDelayUntil+0x7a>
		{
			portYIELD_WITHIN_API();
     b98:	0e 94 da 01 	call	0x3b4	; 0x3b4 <vPortYield>
     b9c:	08 c0       	rjmp	.+16     	; 0xbae <vTaskDelayUntil+0x7a>
					mtCOVERAGE_TEST_MARKER();
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     b9e:	f8 01       	movw	r30, r16
     ba0:	d1 83       	std	Z+1, r29	; 0x01
     ba2:	c0 83       	st	Z, r28
     ba4:	eb cf       	rjmp	.-42     	; 0xb7c <vTaskDelayUntil+0x48>
     ba6:	f8 01       	movw	r30, r16
     ba8:	d1 83       	std	Z+1, r29	; 0x01
     baa:	c0 83       	st	Z, r28
     bac:	f1 cf       	rjmp	.-30     	; 0xb90 <vTaskDelayUntil+0x5c>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
     bae:	df 91       	pop	r29
     bb0:	cf 91       	pop	r28
     bb2:	1f 91       	pop	r17
     bb4:	0f 91       	pop	r16
     bb6:	08 95       	ret

00000bb8 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     bb8:	80 91 1c 07 	lds	r24, 0x071C
     bbc:	88 23       	and	r24, r24
     bbe:	21 f0       	breq	.+8      	; 0xbc8 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     bc0:	81 e0       	ldi	r24, 0x01	; 1
     bc2:	80 93 21 07 	sts	0x0721, r24
     bc6:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     bc8:	10 92 21 07 	sts	0x0721, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     bcc:	80 91 24 07 	lds	r24, 0x0724
     bd0:	90 e0       	ldi	r25, 0x00	; 0
     bd2:	fc 01       	movw	r30, r24
     bd4:	ee 0f       	add	r30, r30
     bd6:	ff 1f       	adc	r31, r31
     bd8:	ee 0f       	add	r30, r30
     bda:	ff 1f       	adc	r31, r31
     bdc:	ee 0f       	add	r30, r30
     bde:	ff 1f       	adc	r31, r31
     be0:	8e 0f       	add	r24, r30
     be2:	9f 1f       	adc	r25, r31
     be4:	fc 01       	movw	r30, r24
     be6:	e9 5b       	subi	r30, 0xB9	; 185
     be8:	f8 4f       	sbci	r31, 0xF8	; 248
     bea:	80 81       	ld	r24, Z
     bec:	81 11       	cpse	r24, r1
     bee:	17 c0       	rjmp	.+46     	; 0xc1e <vTaskSwitchContext+0x66>
     bf0:	80 91 24 07 	lds	r24, 0x0724
     bf4:	81 50       	subi	r24, 0x01	; 1
     bf6:	80 93 24 07 	sts	0x0724, r24
     bfa:	80 91 24 07 	lds	r24, 0x0724
     bfe:	90 e0       	ldi	r25, 0x00	; 0
     c00:	fc 01       	movw	r30, r24
     c02:	ee 0f       	add	r30, r30
     c04:	ff 1f       	adc	r31, r31
     c06:	ee 0f       	add	r30, r30
     c08:	ff 1f       	adc	r31, r31
     c0a:	ee 0f       	add	r30, r30
     c0c:	ff 1f       	adc	r31, r31
     c0e:	8e 0f       	add	r24, r30
     c10:	9f 1f       	adc	r25, r31
     c12:	fc 01       	movw	r30, r24
     c14:	e9 5b       	subi	r30, 0xB9	; 185
     c16:	f8 4f       	sbci	r31, 0xF8	; 248
     c18:	80 81       	ld	r24, Z
     c1a:	88 23       	and	r24, r24
     c1c:	49 f3       	breq	.-46     	; 0xbf0 <vTaskSwitchContext+0x38>
     c1e:	e0 91 24 07 	lds	r30, 0x0724
     c22:	f0 e0       	ldi	r31, 0x00	; 0
     c24:	cf 01       	movw	r24, r30
     c26:	88 0f       	add	r24, r24
     c28:	99 1f       	adc	r25, r25
     c2a:	88 0f       	add	r24, r24
     c2c:	99 1f       	adc	r25, r25
     c2e:	88 0f       	add	r24, r24
     c30:	99 1f       	adc	r25, r25
     c32:	e8 0f       	add	r30, r24
     c34:	f9 1f       	adc	r31, r25
     c36:	e9 5b       	subi	r30, 0xB9	; 185
     c38:	f8 4f       	sbci	r31, 0xF8	; 248
     c3a:	a1 81       	ldd	r26, Z+1	; 0x01
     c3c:	b2 81       	ldd	r27, Z+2	; 0x02
     c3e:	12 96       	adiw	r26, 0x02	; 2
     c40:	0d 90       	ld	r0, X+
     c42:	bc 91       	ld	r27, X
     c44:	a0 2d       	mov	r26, r0
     c46:	b2 83       	std	Z+2, r27	; 0x02
     c48:	a1 83       	std	Z+1, r26	; 0x01
     c4a:	cf 01       	movw	r24, r30
     c4c:	03 96       	adiw	r24, 0x03	; 3
     c4e:	a8 17       	cp	r26, r24
     c50:	b9 07       	cpc	r27, r25
     c52:	31 f4       	brne	.+12     	; 0xc60 <vTaskSwitchContext+0xa8>
     c54:	12 96       	adiw	r26, 0x02	; 2
     c56:	8d 91       	ld	r24, X+
     c58:	9c 91       	ld	r25, X
     c5a:	13 97       	sbiw	r26, 0x03	; 3
     c5c:	92 83       	std	Z+2, r25	; 0x02
     c5e:	81 83       	std	Z+1, r24	; 0x01
     c60:	01 80       	ldd	r0, Z+1	; 0x01
     c62:	f2 81       	ldd	r31, Z+2	; 0x02
     c64:	e0 2d       	mov	r30, r0
     c66:	86 81       	ldd	r24, Z+6	; 0x06
     c68:	97 81       	ldd	r25, Z+7	; 0x07
     c6a:	90 93 51 07 	sts	0x0751, r25
     c6e:	80 93 50 07 	sts	0x0750, r24
     c72:	08 95       	ret

00000c74 <USART_Init>:
#include <avr/io.h>
#include <stdio.h>

void USART_Init(unsigned int ubrr) {
	/* set baud rate */
	UBRR0H = (unsigned char)(ubrr>>8);
     c74:	90 93 c5 00 	sts	0x00C5, r25
	UBRR0L = (unsigned char)ubrr;
     c78:	80 93 c4 00 	sts	0x00C4, r24

	UCSR0C = _BV(USBS0) | _BV(UCSZ01) | _BV(UCSZ00); /* 8-bit data, 2 stop bits */
     c7c:	8e e0       	ldi	r24, 0x0E	; 14
     c7e:	80 93 c2 00 	sts	0x00C2, r24
	UCSR0B = _BV(RXEN0) | _BV(TXEN0);   /* Enable RX and TX */
     c82:	88 e1       	ldi	r24, 0x18	; 24
     c84:	80 93 c1 00 	sts	0x00C1, r24
     c88:	08 95       	ret

00000c8a <USART_Transmit>:
}

void USART_Transmit(char c, FILE *stream) {
     c8a:	cf 93       	push	r28
     c8c:	c8 2f       	mov	r28, r24
	if (c == '\n') {
     c8e:	8a 30       	cpi	r24, 0x0A	; 10
     c90:	19 f4       	brne	.+6      	; 0xc98 <USART_Transmit+0xe>
		USART_Transmit('\r', stream); /* transmit carriage return with new line */
     c92:	8d e0       	ldi	r24, 0x0D	; 13
     c94:	0e 94 45 06 	call	0xc8a	; 0xc8a <USART_Transmit>
	}
	/* Wait for empty transmit buffer */
	while ( !( UCSR0A & (1<<UDRE0)) )
     c98:	e0 ec       	ldi	r30, 0xC0	; 192
     c9a:	f0 e0       	ldi	r31, 0x00	; 0
     c9c:	90 81       	ld	r25, Z
     c9e:	95 ff       	sbrs	r25, 5
     ca0:	fd cf       	rjmp	.-6      	; 0xc9c <USART_Transmit+0x12>
	;
	/* Put data into buffer, sends the data */
	UDR0 = c;
     ca2:	c0 93 c6 00 	sts	0x00C6, r28
}
     ca6:	cf 91       	pop	r28
     ca8:	08 95       	ret

00000caa <USART_Receive>:

char USART_Receive(FILE *stream) {
	/* Wait for data to be received */
	while ( !(UCSR0A & (1<<RXC0)) )
     caa:	e0 ec       	ldi	r30, 0xC0	; 192
     cac:	f0 e0       	ldi	r31, 0x00	; 0
     cae:	80 81       	ld	r24, Z
     cb0:	88 23       	and	r24, r24
     cb2:	ec f7       	brge	.-6      	; 0xcae <USART_Receive+0x4>
	;
	/* Get and return received data from buffer */
	return UDR0;
     cb4:	80 91 c6 00 	lds	r24, 0x00C6
}
     cb8:	08 95       	ret

00000cba <printf>:
     cba:	a0 e0       	ldi	r26, 0x00	; 0
     cbc:	b0 e0       	ldi	r27, 0x00	; 0
     cbe:	e3 e6       	ldi	r30, 0x63	; 99
     cc0:	f6 e0       	ldi	r31, 0x06	; 6
     cc2:	0c 94 f9 08 	jmp	0x11f2	; 0x11f2 <__prologue_saves__+0x20>
     cc6:	fe 01       	movw	r30, r28
     cc8:	35 96       	adiw	r30, 0x05	; 5
     cca:	61 91       	ld	r22, Z+
     ccc:	71 91       	ld	r23, Z+
     cce:	af 01       	movw	r20, r30
     cd0:	80 91 54 07 	lds	r24, 0x0754
     cd4:	90 91 55 07 	lds	r25, 0x0755
     cd8:	0e 94 71 06 	call	0xce2	; 0xce2 <vfprintf>
     cdc:	e2 e0       	ldi	r30, 0x02	; 2
     cde:	0c 94 15 09 	jmp	0x122a	; 0x122a <__epilogue_restores__+0x20>

00000ce2 <vfprintf>:
     ce2:	ac e0       	ldi	r26, 0x0C	; 12
     ce4:	b0 e0       	ldi	r27, 0x00	; 0
     ce6:	e7 e7       	ldi	r30, 0x77	; 119
     ce8:	f6 e0       	ldi	r31, 0x06	; 6
     cea:	0c 94 e9 08 	jmp	0x11d2	; 0x11d2 <__prologue_saves__>
     cee:	7c 01       	movw	r14, r24
     cf0:	6b 01       	movw	r12, r22
     cf2:	8a 01       	movw	r16, r20
     cf4:	fc 01       	movw	r30, r24
     cf6:	17 82       	std	Z+7, r1	; 0x07
     cf8:	16 82       	std	Z+6, r1	; 0x06
     cfa:	83 81       	ldd	r24, Z+3	; 0x03
     cfc:	81 ff       	sbrs	r24, 1
     cfe:	bd c1       	rjmp	.+890    	; 0x107a <vfprintf+0x398>
     d00:	ce 01       	movw	r24, r28
     d02:	01 96       	adiw	r24, 0x01	; 1
     d04:	4c 01       	movw	r8, r24
     d06:	f7 01       	movw	r30, r14
     d08:	93 81       	ldd	r25, Z+3	; 0x03
     d0a:	f6 01       	movw	r30, r12
     d0c:	93 fd       	sbrc	r25, 3
     d0e:	85 91       	lpm	r24, Z+
     d10:	93 ff       	sbrs	r25, 3
     d12:	81 91       	ld	r24, Z+
     d14:	6f 01       	movw	r12, r30
     d16:	88 23       	and	r24, r24
     d18:	09 f4       	brne	.+2      	; 0xd1c <vfprintf+0x3a>
     d1a:	ab c1       	rjmp	.+854    	; 0x1072 <vfprintf+0x390>
     d1c:	85 32       	cpi	r24, 0x25	; 37
     d1e:	39 f4       	brne	.+14     	; 0xd2e <vfprintf+0x4c>
     d20:	93 fd       	sbrc	r25, 3
     d22:	85 91       	lpm	r24, Z+
     d24:	93 ff       	sbrs	r25, 3
     d26:	81 91       	ld	r24, Z+
     d28:	6f 01       	movw	r12, r30
     d2a:	85 32       	cpi	r24, 0x25	; 37
     d2c:	29 f4       	brne	.+10     	; 0xd38 <vfprintf+0x56>
     d2e:	b7 01       	movw	r22, r14
     d30:	90 e0       	ldi	r25, 0x00	; 0
     d32:	0e 94 59 08 	call	0x10b2	; 0x10b2 <fputc>
     d36:	e7 cf       	rjmp	.-50     	; 0xd06 <vfprintf+0x24>
     d38:	51 2c       	mov	r5, r1
     d3a:	31 2c       	mov	r3, r1
     d3c:	20 e0       	ldi	r18, 0x00	; 0
     d3e:	20 32       	cpi	r18, 0x20	; 32
     d40:	a0 f4       	brcc	.+40     	; 0xd6a <vfprintf+0x88>
     d42:	8b 32       	cpi	r24, 0x2B	; 43
     d44:	69 f0       	breq	.+26     	; 0xd60 <vfprintf+0x7e>
     d46:	30 f4       	brcc	.+12     	; 0xd54 <vfprintf+0x72>
     d48:	80 32       	cpi	r24, 0x20	; 32
     d4a:	59 f0       	breq	.+22     	; 0xd62 <vfprintf+0x80>
     d4c:	83 32       	cpi	r24, 0x23	; 35
     d4e:	69 f4       	brne	.+26     	; 0xd6a <vfprintf+0x88>
     d50:	20 61       	ori	r18, 0x10	; 16
     d52:	2c c0       	rjmp	.+88     	; 0xdac <vfprintf+0xca>
     d54:	8d 32       	cpi	r24, 0x2D	; 45
     d56:	39 f0       	breq	.+14     	; 0xd66 <vfprintf+0x84>
     d58:	80 33       	cpi	r24, 0x30	; 48
     d5a:	39 f4       	brne	.+14     	; 0xd6a <vfprintf+0x88>
     d5c:	21 60       	ori	r18, 0x01	; 1
     d5e:	26 c0       	rjmp	.+76     	; 0xdac <vfprintf+0xca>
     d60:	22 60       	ori	r18, 0x02	; 2
     d62:	24 60       	ori	r18, 0x04	; 4
     d64:	23 c0       	rjmp	.+70     	; 0xdac <vfprintf+0xca>
     d66:	28 60       	ori	r18, 0x08	; 8
     d68:	21 c0       	rjmp	.+66     	; 0xdac <vfprintf+0xca>
     d6a:	27 fd       	sbrc	r18, 7
     d6c:	27 c0       	rjmp	.+78     	; 0xdbc <vfprintf+0xda>
     d6e:	30 ed       	ldi	r19, 0xD0	; 208
     d70:	38 0f       	add	r19, r24
     d72:	3a 30       	cpi	r19, 0x0A	; 10
     d74:	78 f4       	brcc	.+30     	; 0xd94 <vfprintf+0xb2>
     d76:	26 ff       	sbrs	r18, 6
     d78:	06 c0       	rjmp	.+12     	; 0xd86 <vfprintf+0xa4>
     d7a:	fa e0       	ldi	r31, 0x0A	; 10
     d7c:	5f 9e       	mul	r5, r31
     d7e:	30 0d       	add	r19, r0
     d80:	11 24       	eor	r1, r1
     d82:	53 2e       	mov	r5, r19
     d84:	13 c0       	rjmp	.+38     	; 0xdac <vfprintf+0xca>
     d86:	8a e0       	ldi	r24, 0x0A	; 10
     d88:	38 9e       	mul	r3, r24
     d8a:	30 0d       	add	r19, r0
     d8c:	11 24       	eor	r1, r1
     d8e:	33 2e       	mov	r3, r19
     d90:	20 62       	ori	r18, 0x20	; 32
     d92:	0c c0       	rjmp	.+24     	; 0xdac <vfprintf+0xca>
     d94:	8e 32       	cpi	r24, 0x2E	; 46
     d96:	21 f4       	brne	.+8      	; 0xda0 <vfprintf+0xbe>
     d98:	26 fd       	sbrc	r18, 6
     d9a:	6b c1       	rjmp	.+726    	; 0x1072 <vfprintf+0x390>
     d9c:	20 64       	ori	r18, 0x40	; 64
     d9e:	06 c0       	rjmp	.+12     	; 0xdac <vfprintf+0xca>
     da0:	8c 36       	cpi	r24, 0x6C	; 108
     da2:	11 f4       	brne	.+4      	; 0xda8 <vfprintf+0xc6>
     da4:	20 68       	ori	r18, 0x80	; 128
     da6:	02 c0       	rjmp	.+4      	; 0xdac <vfprintf+0xca>
     da8:	88 36       	cpi	r24, 0x68	; 104
     daa:	41 f4       	brne	.+16     	; 0xdbc <vfprintf+0xda>
     dac:	f6 01       	movw	r30, r12
     dae:	93 fd       	sbrc	r25, 3
     db0:	85 91       	lpm	r24, Z+
     db2:	93 ff       	sbrs	r25, 3
     db4:	81 91       	ld	r24, Z+
     db6:	6f 01       	movw	r12, r30
     db8:	81 11       	cpse	r24, r1
     dba:	c1 cf       	rjmp	.-126    	; 0xd3e <vfprintf+0x5c>
     dbc:	98 2f       	mov	r25, r24
     dbe:	9f 7d       	andi	r25, 0xDF	; 223
     dc0:	95 54       	subi	r25, 0x45	; 69
     dc2:	93 30       	cpi	r25, 0x03	; 3
     dc4:	28 f4       	brcc	.+10     	; 0xdd0 <vfprintf+0xee>
     dc6:	0c 5f       	subi	r16, 0xFC	; 252
     dc8:	1f 4f       	sbci	r17, 0xFF	; 255
     dca:	ff e3       	ldi	r31, 0x3F	; 63
     dcc:	f9 83       	std	Y+1, r31	; 0x01
     dce:	0d c0       	rjmp	.+26     	; 0xdea <vfprintf+0x108>
     dd0:	83 36       	cpi	r24, 0x63	; 99
     dd2:	31 f0       	breq	.+12     	; 0xde0 <vfprintf+0xfe>
     dd4:	83 37       	cpi	r24, 0x73	; 115
     dd6:	71 f0       	breq	.+28     	; 0xdf4 <vfprintf+0x112>
     dd8:	83 35       	cpi	r24, 0x53	; 83
     dda:	09 f0       	breq	.+2      	; 0xdde <vfprintf+0xfc>
     ddc:	5b c0       	rjmp	.+182    	; 0xe94 <vfprintf+0x1b2>
     dde:	22 c0       	rjmp	.+68     	; 0xe24 <vfprintf+0x142>
     de0:	f8 01       	movw	r30, r16
     de2:	80 81       	ld	r24, Z
     de4:	89 83       	std	Y+1, r24	; 0x01
     de6:	0e 5f       	subi	r16, 0xFE	; 254
     de8:	1f 4f       	sbci	r17, 0xFF	; 255
     dea:	44 24       	eor	r4, r4
     dec:	43 94       	inc	r4
     dee:	51 2c       	mov	r5, r1
     df0:	54 01       	movw	r10, r8
     df2:	15 c0       	rjmp	.+42     	; 0xe1e <vfprintf+0x13c>
     df4:	38 01       	movw	r6, r16
     df6:	f2 e0       	ldi	r31, 0x02	; 2
     df8:	6f 0e       	add	r6, r31
     dfa:	71 1c       	adc	r7, r1
     dfc:	f8 01       	movw	r30, r16
     dfe:	a0 80       	ld	r10, Z
     e00:	b1 80       	ldd	r11, Z+1	; 0x01
     e02:	26 ff       	sbrs	r18, 6
     e04:	03 c0       	rjmp	.+6      	; 0xe0c <vfprintf+0x12a>
     e06:	65 2d       	mov	r22, r5
     e08:	70 e0       	ldi	r23, 0x00	; 0
     e0a:	02 c0       	rjmp	.+4      	; 0xe10 <vfprintf+0x12e>
     e0c:	6f ef       	ldi	r22, 0xFF	; 255
     e0e:	7f ef       	ldi	r23, 0xFF	; 255
     e10:	c5 01       	movw	r24, r10
     e12:	2c 87       	std	Y+12, r18	; 0x0c
     e14:	0e 94 4e 08 	call	0x109c	; 0x109c <strnlen>
     e18:	2c 01       	movw	r4, r24
     e1a:	83 01       	movw	r16, r6
     e1c:	2c 85       	ldd	r18, Y+12	; 0x0c
     e1e:	2f 77       	andi	r18, 0x7F	; 127
     e20:	22 2e       	mov	r2, r18
     e22:	17 c0       	rjmp	.+46     	; 0xe52 <vfprintf+0x170>
     e24:	38 01       	movw	r6, r16
     e26:	f2 e0       	ldi	r31, 0x02	; 2
     e28:	6f 0e       	add	r6, r31
     e2a:	71 1c       	adc	r7, r1
     e2c:	f8 01       	movw	r30, r16
     e2e:	a0 80       	ld	r10, Z
     e30:	b1 80       	ldd	r11, Z+1	; 0x01
     e32:	26 ff       	sbrs	r18, 6
     e34:	03 c0       	rjmp	.+6      	; 0xe3c <vfprintf+0x15a>
     e36:	65 2d       	mov	r22, r5
     e38:	70 e0       	ldi	r23, 0x00	; 0
     e3a:	02 c0       	rjmp	.+4      	; 0xe40 <vfprintf+0x15e>
     e3c:	6f ef       	ldi	r22, 0xFF	; 255
     e3e:	7f ef       	ldi	r23, 0xFF	; 255
     e40:	c5 01       	movw	r24, r10
     e42:	2c 87       	std	Y+12, r18	; 0x0c
     e44:	0e 94 43 08 	call	0x1086	; 0x1086 <strnlen_P>
     e48:	2c 01       	movw	r4, r24
     e4a:	2c 85       	ldd	r18, Y+12	; 0x0c
     e4c:	20 68       	ori	r18, 0x80	; 128
     e4e:	22 2e       	mov	r2, r18
     e50:	83 01       	movw	r16, r6
     e52:	23 fc       	sbrc	r2, 3
     e54:	1b c0       	rjmp	.+54     	; 0xe8c <vfprintf+0x1aa>
     e56:	83 2d       	mov	r24, r3
     e58:	90 e0       	ldi	r25, 0x00	; 0
     e5a:	48 16       	cp	r4, r24
     e5c:	59 06       	cpc	r5, r25
     e5e:	b0 f4       	brcc	.+44     	; 0xe8c <vfprintf+0x1aa>
     e60:	b7 01       	movw	r22, r14
     e62:	80 e2       	ldi	r24, 0x20	; 32
     e64:	90 e0       	ldi	r25, 0x00	; 0
     e66:	0e 94 59 08 	call	0x10b2	; 0x10b2 <fputc>
     e6a:	3a 94       	dec	r3
     e6c:	f4 cf       	rjmp	.-24     	; 0xe56 <vfprintf+0x174>
     e6e:	f5 01       	movw	r30, r10
     e70:	27 fc       	sbrc	r2, 7
     e72:	85 91       	lpm	r24, Z+
     e74:	27 fe       	sbrs	r2, 7
     e76:	81 91       	ld	r24, Z+
     e78:	5f 01       	movw	r10, r30
     e7a:	b7 01       	movw	r22, r14
     e7c:	90 e0       	ldi	r25, 0x00	; 0
     e7e:	0e 94 59 08 	call	0x10b2	; 0x10b2 <fputc>
     e82:	31 10       	cpse	r3, r1
     e84:	3a 94       	dec	r3
     e86:	f1 e0       	ldi	r31, 0x01	; 1
     e88:	4f 1a       	sub	r4, r31
     e8a:	51 08       	sbc	r5, r1
     e8c:	41 14       	cp	r4, r1
     e8e:	51 04       	cpc	r5, r1
     e90:	71 f7       	brne	.-36     	; 0xe6e <vfprintf+0x18c>
     e92:	e5 c0       	rjmp	.+458    	; 0x105e <vfprintf+0x37c>
     e94:	84 36       	cpi	r24, 0x64	; 100
     e96:	11 f0       	breq	.+4      	; 0xe9c <vfprintf+0x1ba>
     e98:	89 36       	cpi	r24, 0x69	; 105
     e9a:	39 f5       	brne	.+78     	; 0xeea <vfprintf+0x208>
     e9c:	f8 01       	movw	r30, r16
     e9e:	27 ff       	sbrs	r18, 7
     ea0:	07 c0       	rjmp	.+14     	; 0xeb0 <vfprintf+0x1ce>
     ea2:	60 81       	ld	r22, Z
     ea4:	71 81       	ldd	r23, Z+1	; 0x01
     ea6:	82 81       	ldd	r24, Z+2	; 0x02
     ea8:	93 81       	ldd	r25, Z+3	; 0x03
     eaa:	0c 5f       	subi	r16, 0xFC	; 252
     eac:	1f 4f       	sbci	r17, 0xFF	; 255
     eae:	08 c0       	rjmp	.+16     	; 0xec0 <vfprintf+0x1de>
     eb0:	60 81       	ld	r22, Z
     eb2:	71 81       	ldd	r23, Z+1	; 0x01
     eb4:	88 27       	eor	r24, r24
     eb6:	77 fd       	sbrc	r23, 7
     eb8:	80 95       	com	r24
     eba:	98 2f       	mov	r25, r24
     ebc:	0e 5f       	subi	r16, 0xFE	; 254
     ebe:	1f 4f       	sbci	r17, 0xFF	; 255
     ec0:	2f 76       	andi	r18, 0x6F	; 111
     ec2:	b2 2e       	mov	r11, r18
     ec4:	97 ff       	sbrs	r25, 7
     ec6:	09 c0       	rjmp	.+18     	; 0xeda <vfprintf+0x1f8>
     ec8:	90 95       	com	r25
     eca:	80 95       	com	r24
     ecc:	70 95       	com	r23
     ece:	61 95       	neg	r22
     ed0:	7f 4f       	sbci	r23, 0xFF	; 255
     ed2:	8f 4f       	sbci	r24, 0xFF	; 255
     ed4:	9f 4f       	sbci	r25, 0xFF	; 255
     ed6:	20 68       	ori	r18, 0x80	; 128
     ed8:	b2 2e       	mov	r11, r18
     eda:	2a e0       	ldi	r18, 0x0A	; 10
     edc:	30 e0       	ldi	r19, 0x00	; 0
     ede:	a4 01       	movw	r20, r8
     ee0:	0e 94 8b 08 	call	0x1116	; 0x1116 <__ultoa_invert>
     ee4:	a8 2e       	mov	r10, r24
     ee6:	a8 18       	sub	r10, r8
     ee8:	44 c0       	rjmp	.+136    	; 0xf72 <vfprintf+0x290>
     eea:	85 37       	cpi	r24, 0x75	; 117
     eec:	29 f4       	brne	.+10     	; 0xef8 <vfprintf+0x216>
     eee:	2f 7e       	andi	r18, 0xEF	; 239
     ef0:	b2 2e       	mov	r11, r18
     ef2:	2a e0       	ldi	r18, 0x0A	; 10
     ef4:	30 e0       	ldi	r19, 0x00	; 0
     ef6:	25 c0       	rjmp	.+74     	; 0xf42 <vfprintf+0x260>
     ef8:	f2 2f       	mov	r31, r18
     efa:	f9 7f       	andi	r31, 0xF9	; 249
     efc:	bf 2e       	mov	r11, r31
     efe:	8f 36       	cpi	r24, 0x6F	; 111
     f00:	c1 f0       	breq	.+48     	; 0xf32 <vfprintf+0x250>
     f02:	18 f4       	brcc	.+6      	; 0xf0a <vfprintf+0x228>
     f04:	88 35       	cpi	r24, 0x58	; 88
     f06:	79 f0       	breq	.+30     	; 0xf26 <vfprintf+0x244>
     f08:	b4 c0       	rjmp	.+360    	; 0x1072 <vfprintf+0x390>
     f0a:	80 37       	cpi	r24, 0x70	; 112
     f0c:	19 f0       	breq	.+6      	; 0xf14 <vfprintf+0x232>
     f0e:	88 37       	cpi	r24, 0x78	; 120
     f10:	21 f0       	breq	.+8      	; 0xf1a <vfprintf+0x238>
     f12:	af c0       	rjmp	.+350    	; 0x1072 <vfprintf+0x390>
     f14:	2f 2f       	mov	r18, r31
     f16:	20 61       	ori	r18, 0x10	; 16
     f18:	b2 2e       	mov	r11, r18
     f1a:	b4 fe       	sbrs	r11, 4
     f1c:	0d c0       	rjmp	.+26     	; 0xf38 <vfprintf+0x256>
     f1e:	8b 2d       	mov	r24, r11
     f20:	84 60       	ori	r24, 0x04	; 4
     f22:	b8 2e       	mov	r11, r24
     f24:	09 c0       	rjmp	.+18     	; 0xf38 <vfprintf+0x256>
     f26:	24 ff       	sbrs	r18, 4
     f28:	0a c0       	rjmp	.+20     	; 0xf3e <vfprintf+0x25c>
     f2a:	9f 2f       	mov	r25, r31
     f2c:	96 60       	ori	r25, 0x06	; 6
     f2e:	b9 2e       	mov	r11, r25
     f30:	06 c0       	rjmp	.+12     	; 0xf3e <vfprintf+0x25c>
     f32:	28 e0       	ldi	r18, 0x08	; 8
     f34:	30 e0       	ldi	r19, 0x00	; 0
     f36:	05 c0       	rjmp	.+10     	; 0xf42 <vfprintf+0x260>
     f38:	20 e1       	ldi	r18, 0x10	; 16
     f3a:	30 e0       	ldi	r19, 0x00	; 0
     f3c:	02 c0       	rjmp	.+4      	; 0xf42 <vfprintf+0x260>
     f3e:	20 e1       	ldi	r18, 0x10	; 16
     f40:	32 e0       	ldi	r19, 0x02	; 2
     f42:	f8 01       	movw	r30, r16
     f44:	b7 fe       	sbrs	r11, 7
     f46:	07 c0       	rjmp	.+14     	; 0xf56 <vfprintf+0x274>
     f48:	60 81       	ld	r22, Z
     f4a:	71 81       	ldd	r23, Z+1	; 0x01
     f4c:	82 81       	ldd	r24, Z+2	; 0x02
     f4e:	93 81       	ldd	r25, Z+3	; 0x03
     f50:	0c 5f       	subi	r16, 0xFC	; 252
     f52:	1f 4f       	sbci	r17, 0xFF	; 255
     f54:	06 c0       	rjmp	.+12     	; 0xf62 <vfprintf+0x280>
     f56:	60 81       	ld	r22, Z
     f58:	71 81       	ldd	r23, Z+1	; 0x01
     f5a:	80 e0       	ldi	r24, 0x00	; 0
     f5c:	90 e0       	ldi	r25, 0x00	; 0
     f5e:	0e 5f       	subi	r16, 0xFE	; 254
     f60:	1f 4f       	sbci	r17, 0xFF	; 255
     f62:	a4 01       	movw	r20, r8
     f64:	0e 94 8b 08 	call	0x1116	; 0x1116 <__ultoa_invert>
     f68:	a8 2e       	mov	r10, r24
     f6a:	a8 18       	sub	r10, r8
     f6c:	fb 2d       	mov	r31, r11
     f6e:	ff 77       	andi	r31, 0x7F	; 127
     f70:	bf 2e       	mov	r11, r31
     f72:	b6 fe       	sbrs	r11, 6
     f74:	0b c0       	rjmp	.+22     	; 0xf8c <vfprintf+0x2aa>
     f76:	2b 2d       	mov	r18, r11
     f78:	2e 7f       	andi	r18, 0xFE	; 254
     f7a:	a5 14       	cp	r10, r5
     f7c:	50 f4       	brcc	.+20     	; 0xf92 <vfprintf+0x2b0>
     f7e:	b4 fe       	sbrs	r11, 4
     f80:	0a c0       	rjmp	.+20     	; 0xf96 <vfprintf+0x2b4>
     f82:	b2 fc       	sbrc	r11, 2
     f84:	08 c0       	rjmp	.+16     	; 0xf96 <vfprintf+0x2b4>
     f86:	2b 2d       	mov	r18, r11
     f88:	2e 7e       	andi	r18, 0xEE	; 238
     f8a:	05 c0       	rjmp	.+10     	; 0xf96 <vfprintf+0x2b4>
     f8c:	7a 2c       	mov	r7, r10
     f8e:	2b 2d       	mov	r18, r11
     f90:	03 c0       	rjmp	.+6      	; 0xf98 <vfprintf+0x2b6>
     f92:	7a 2c       	mov	r7, r10
     f94:	01 c0       	rjmp	.+2      	; 0xf98 <vfprintf+0x2b6>
     f96:	75 2c       	mov	r7, r5
     f98:	24 ff       	sbrs	r18, 4
     f9a:	0d c0       	rjmp	.+26     	; 0xfb6 <vfprintf+0x2d4>
     f9c:	fe 01       	movw	r30, r28
     f9e:	ea 0d       	add	r30, r10
     fa0:	f1 1d       	adc	r31, r1
     fa2:	80 81       	ld	r24, Z
     fa4:	80 33       	cpi	r24, 0x30	; 48
     fa6:	11 f4       	brne	.+4      	; 0xfac <vfprintf+0x2ca>
     fa8:	29 7e       	andi	r18, 0xE9	; 233
     faa:	09 c0       	rjmp	.+18     	; 0xfbe <vfprintf+0x2dc>
     fac:	22 ff       	sbrs	r18, 2
     fae:	06 c0       	rjmp	.+12     	; 0xfbc <vfprintf+0x2da>
     fb0:	73 94       	inc	r7
     fb2:	73 94       	inc	r7
     fb4:	04 c0       	rjmp	.+8      	; 0xfbe <vfprintf+0x2dc>
     fb6:	82 2f       	mov	r24, r18
     fb8:	86 78       	andi	r24, 0x86	; 134
     fba:	09 f0       	breq	.+2      	; 0xfbe <vfprintf+0x2dc>
     fbc:	73 94       	inc	r7
     fbe:	23 fd       	sbrc	r18, 3
     fc0:	13 c0       	rjmp	.+38     	; 0xfe8 <vfprintf+0x306>
     fc2:	20 ff       	sbrs	r18, 0
     fc4:	06 c0       	rjmp	.+12     	; 0xfd2 <vfprintf+0x2f0>
     fc6:	5a 2c       	mov	r5, r10
     fc8:	73 14       	cp	r7, r3
     fca:	18 f4       	brcc	.+6      	; 0xfd2 <vfprintf+0x2f0>
     fcc:	53 0c       	add	r5, r3
     fce:	57 18       	sub	r5, r7
     fd0:	73 2c       	mov	r7, r3
     fd2:	73 14       	cp	r7, r3
     fd4:	68 f4       	brcc	.+26     	; 0xff0 <vfprintf+0x30e>
     fd6:	b7 01       	movw	r22, r14
     fd8:	80 e2       	ldi	r24, 0x20	; 32
     fda:	90 e0       	ldi	r25, 0x00	; 0
     fdc:	2c 87       	std	Y+12, r18	; 0x0c
     fde:	0e 94 59 08 	call	0x10b2	; 0x10b2 <fputc>
     fe2:	73 94       	inc	r7
     fe4:	2c 85       	ldd	r18, Y+12	; 0x0c
     fe6:	f5 cf       	rjmp	.-22     	; 0xfd2 <vfprintf+0x2f0>
     fe8:	73 14       	cp	r7, r3
     fea:	10 f4       	brcc	.+4      	; 0xff0 <vfprintf+0x30e>
     fec:	37 18       	sub	r3, r7
     fee:	01 c0       	rjmp	.+2      	; 0xff2 <vfprintf+0x310>
     ff0:	31 2c       	mov	r3, r1
     ff2:	24 ff       	sbrs	r18, 4
     ff4:	12 c0       	rjmp	.+36     	; 0x101a <vfprintf+0x338>
     ff6:	b7 01       	movw	r22, r14
     ff8:	80 e3       	ldi	r24, 0x30	; 48
     ffa:	90 e0       	ldi	r25, 0x00	; 0
     ffc:	2c 87       	std	Y+12, r18	; 0x0c
     ffe:	0e 94 59 08 	call	0x10b2	; 0x10b2 <fputc>
    1002:	2c 85       	ldd	r18, Y+12	; 0x0c
    1004:	22 ff       	sbrs	r18, 2
    1006:	17 c0       	rjmp	.+46     	; 0x1036 <vfprintf+0x354>
    1008:	21 ff       	sbrs	r18, 1
    100a:	03 c0       	rjmp	.+6      	; 0x1012 <vfprintf+0x330>
    100c:	88 e5       	ldi	r24, 0x58	; 88
    100e:	90 e0       	ldi	r25, 0x00	; 0
    1010:	02 c0       	rjmp	.+4      	; 0x1016 <vfprintf+0x334>
    1012:	88 e7       	ldi	r24, 0x78	; 120
    1014:	90 e0       	ldi	r25, 0x00	; 0
    1016:	b7 01       	movw	r22, r14
    1018:	0c c0       	rjmp	.+24     	; 0x1032 <vfprintf+0x350>
    101a:	82 2f       	mov	r24, r18
    101c:	86 78       	andi	r24, 0x86	; 134
    101e:	59 f0       	breq	.+22     	; 0x1036 <vfprintf+0x354>
    1020:	21 fd       	sbrc	r18, 1
    1022:	02 c0       	rjmp	.+4      	; 0x1028 <vfprintf+0x346>
    1024:	80 e2       	ldi	r24, 0x20	; 32
    1026:	01 c0       	rjmp	.+2      	; 0x102a <vfprintf+0x348>
    1028:	8b e2       	ldi	r24, 0x2B	; 43
    102a:	27 fd       	sbrc	r18, 7
    102c:	8d e2       	ldi	r24, 0x2D	; 45
    102e:	b7 01       	movw	r22, r14
    1030:	90 e0       	ldi	r25, 0x00	; 0
    1032:	0e 94 59 08 	call	0x10b2	; 0x10b2 <fputc>
    1036:	a5 14       	cp	r10, r5
    1038:	38 f4       	brcc	.+14     	; 0x1048 <vfprintf+0x366>
    103a:	b7 01       	movw	r22, r14
    103c:	80 e3       	ldi	r24, 0x30	; 48
    103e:	90 e0       	ldi	r25, 0x00	; 0
    1040:	0e 94 59 08 	call	0x10b2	; 0x10b2 <fputc>
    1044:	5a 94       	dec	r5
    1046:	f7 cf       	rjmp	.-18     	; 0x1036 <vfprintf+0x354>
    1048:	aa 94       	dec	r10
    104a:	f4 01       	movw	r30, r8
    104c:	ea 0d       	add	r30, r10
    104e:	f1 1d       	adc	r31, r1
    1050:	80 81       	ld	r24, Z
    1052:	b7 01       	movw	r22, r14
    1054:	90 e0       	ldi	r25, 0x00	; 0
    1056:	0e 94 59 08 	call	0x10b2	; 0x10b2 <fputc>
    105a:	a1 10       	cpse	r10, r1
    105c:	f5 cf       	rjmp	.-22     	; 0x1048 <vfprintf+0x366>
    105e:	33 20       	and	r3, r3
    1060:	09 f4       	brne	.+2      	; 0x1064 <vfprintf+0x382>
    1062:	51 ce       	rjmp	.-862    	; 0xd06 <vfprintf+0x24>
    1064:	b7 01       	movw	r22, r14
    1066:	80 e2       	ldi	r24, 0x20	; 32
    1068:	90 e0       	ldi	r25, 0x00	; 0
    106a:	0e 94 59 08 	call	0x10b2	; 0x10b2 <fputc>
    106e:	3a 94       	dec	r3
    1070:	f6 cf       	rjmp	.-20     	; 0x105e <vfprintf+0x37c>
    1072:	f7 01       	movw	r30, r14
    1074:	86 81       	ldd	r24, Z+6	; 0x06
    1076:	97 81       	ldd	r25, Z+7	; 0x07
    1078:	02 c0       	rjmp	.+4      	; 0x107e <vfprintf+0x39c>
    107a:	8f ef       	ldi	r24, 0xFF	; 255
    107c:	9f ef       	ldi	r25, 0xFF	; 255
    107e:	2c 96       	adiw	r28, 0x0c	; 12
    1080:	e2 e1       	ldi	r30, 0x12	; 18
    1082:	0c 94 05 09 	jmp	0x120a	; 0x120a <__epilogue_restores__>

00001086 <strnlen_P>:
    1086:	fc 01       	movw	r30, r24
    1088:	05 90       	lpm	r0, Z+
    108a:	61 50       	subi	r22, 0x01	; 1
    108c:	70 40       	sbci	r23, 0x00	; 0
    108e:	01 10       	cpse	r0, r1
    1090:	d8 f7       	brcc	.-10     	; 0x1088 <strnlen_P+0x2>
    1092:	80 95       	com	r24
    1094:	90 95       	com	r25
    1096:	8e 0f       	add	r24, r30
    1098:	9f 1f       	adc	r25, r31
    109a:	08 95       	ret

0000109c <strnlen>:
    109c:	fc 01       	movw	r30, r24
    109e:	61 50       	subi	r22, 0x01	; 1
    10a0:	70 40       	sbci	r23, 0x00	; 0
    10a2:	01 90       	ld	r0, Z+
    10a4:	01 10       	cpse	r0, r1
    10a6:	d8 f7       	brcc	.-10     	; 0x109e <strnlen+0x2>
    10a8:	80 95       	com	r24
    10aa:	90 95       	com	r25
    10ac:	8e 0f       	add	r24, r30
    10ae:	9f 1f       	adc	r25, r31
    10b0:	08 95       	ret

000010b2 <fputc>:
    10b2:	0f 93       	push	r16
    10b4:	1f 93       	push	r17
    10b6:	cf 93       	push	r28
    10b8:	df 93       	push	r29
    10ba:	18 2f       	mov	r17, r24
    10bc:	09 2f       	mov	r16, r25
    10be:	eb 01       	movw	r28, r22
    10c0:	8b 81       	ldd	r24, Y+3	; 0x03
    10c2:	81 fd       	sbrc	r24, 1
    10c4:	03 c0       	rjmp	.+6      	; 0x10cc <fputc+0x1a>
    10c6:	8f ef       	ldi	r24, 0xFF	; 255
    10c8:	9f ef       	ldi	r25, 0xFF	; 255
    10ca:	20 c0       	rjmp	.+64     	; 0x110c <fputc+0x5a>
    10cc:	82 ff       	sbrs	r24, 2
    10ce:	10 c0       	rjmp	.+32     	; 0x10f0 <fputc+0x3e>
    10d0:	4e 81       	ldd	r20, Y+6	; 0x06
    10d2:	5f 81       	ldd	r21, Y+7	; 0x07
    10d4:	2c 81       	ldd	r18, Y+4	; 0x04
    10d6:	3d 81       	ldd	r19, Y+5	; 0x05
    10d8:	42 17       	cp	r20, r18
    10da:	53 07       	cpc	r21, r19
    10dc:	7c f4       	brge	.+30     	; 0x10fc <fputc+0x4a>
    10de:	e8 81       	ld	r30, Y
    10e0:	f9 81       	ldd	r31, Y+1	; 0x01
    10e2:	9f 01       	movw	r18, r30
    10e4:	2f 5f       	subi	r18, 0xFF	; 255
    10e6:	3f 4f       	sbci	r19, 0xFF	; 255
    10e8:	39 83       	std	Y+1, r19	; 0x01
    10ea:	28 83       	st	Y, r18
    10ec:	10 83       	st	Z, r17
    10ee:	06 c0       	rjmp	.+12     	; 0x10fc <fputc+0x4a>
    10f0:	e8 85       	ldd	r30, Y+8	; 0x08
    10f2:	f9 85       	ldd	r31, Y+9	; 0x09
    10f4:	81 2f       	mov	r24, r17
    10f6:	09 95       	icall
    10f8:	89 2b       	or	r24, r25
    10fa:	29 f7       	brne	.-54     	; 0x10c6 <fputc+0x14>
    10fc:	2e 81       	ldd	r18, Y+6	; 0x06
    10fe:	3f 81       	ldd	r19, Y+7	; 0x07
    1100:	2f 5f       	subi	r18, 0xFF	; 255
    1102:	3f 4f       	sbci	r19, 0xFF	; 255
    1104:	3f 83       	std	Y+7, r19	; 0x07
    1106:	2e 83       	std	Y+6, r18	; 0x06
    1108:	81 2f       	mov	r24, r17
    110a:	90 2f       	mov	r25, r16
    110c:	df 91       	pop	r29
    110e:	cf 91       	pop	r28
    1110:	1f 91       	pop	r17
    1112:	0f 91       	pop	r16
    1114:	08 95       	ret

00001116 <__ultoa_invert>:
    1116:	fa 01       	movw	r30, r20
    1118:	aa 27       	eor	r26, r26
    111a:	28 30       	cpi	r18, 0x08	; 8
    111c:	51 f1       	breq	.+84     	; 0x1172 <__ultoa_invert+0x5c>
    111e:	20 31       	cpi	r18, 0x10	; 16
    1120:	81 f1       	breq	.+96     	; 0x1182 <__ultoa_invert+0x6c>
    1122:	e8 94       	clt
    1124:	6f 93       	push	r22
    1126:	6e 7f       	andi	r22, 0xFE	; 254
    1128:	6e 5f       	subi	r22, 0xFE	; 254
    112a:	7f 4f       	sbci	r23, 0xFF	; 255
    112c:	8f 4f       	sbci	r24, 0xFF	; 255
    112e:	9f 4f       	sbci	r25, 0xFF	; 255
    1130:	af 4f       	sbci	r26, 0xFF	; 255
    1132:	b1 e0       	ldi	r27, 0x01	; 1
    1134:	3e d0       	rcall	.+124    	; 0x11b2 <__ultoa_invert+0x9c>
    1136:	b4 e0       	ldi	r27, 0x04	; 4
    1138:	3c d0       	rcall	.+120    	; 0x11b2 <__ultoa_invert+0x9c>
    113a:	67 0f       	add	r22, r23
    113c:	78 1f       	adc	r23, r24
    113e:	89 1f       	adc	r24, r25
    1140:	9a 1f       	adc	r25, r26
    1142:	a1 1d       	adc	r26, r1
    1144:	68 0f       	add	r22, r24
    1146:	79 1f       	adc	r23, r25
    1148:	8a 1f       	adc	r24, r26
    114a:	91 1d       	adc	r25, r1
    114c:	a1 1d       	adc	r26, r1
    114e:	6a 0f       	add	r22, r26
    1150:	71 1d       	adc	r23, r1
    1152:	81 1d       	adc	r24, r1
    1154:	91 1d       	adc	r25, r1
    1156:	a1 1d       	adc	r26, r1
    1158:	20 d0       	rcall	.+64     	; 0x119a <__ultoa_invert+0x84>
    115a:	09 f4       	brne	.+2      	; 0x115e <__ultoa_invert+0x48>
    115c:	68 94       	set
    115e:	3f 91       	pop	r19
    1160:	2a e0       	ldi	r18, 0x0A	; 10
    1162:	26 9f       	mul	r18, r22
    1164:	11 24       	eor	r1, r1
    1166:	30 19       	sub	r19, r0
    1168:	30 5d       	subi	r19, 0xD0	; 208
    116a:	31 93       	st	Z+, r19
    116c:	de f6       	brtc	.-74     	; 0x1124 <__ultoa_invert+0xe>
    116e:	cf 01       	movw	r24, r30
    1170:	08 95       	ret
    1172:	46 2f       	mov	r20, r22
    1174:	47 70       	andi	r20, 0x07	; 7
    1176:	40 5d       	subi	r20, 0xD0	; 208
    1178:	41 93       	st	Z+, r20
    117a:	b3 e0       	ldi	r27, 0x03	; 3
    117c:	0f d0       	rcall	.+30     	; 0x119c <__ultoa_invert+0x86>
    117e:	c9 f7       	brne	.-14     	; 0x1172 <__ultoa_invert+0x5c>
    1180:	f6 cf       	rjmp	.-20     	; 0x116e <__ultoa_invert+0x58>
    1182:	46 2f       	mov	r20, r22
    1184:	4f 70       	andi	r20, 0x0F	; 15
    1186:	40 5d       	subi	r20, 0xD0	; 208
    1188:	4a 33       	cpi	r20, 0x3A	; 58
    118a:	18 f0       	brcs	.+6      	; 0x1192 <__ultoa_invert+0x7c>
    118c:	49 5d       	subi	r20, 0xD9	; 217
    118e:	31 fd       	sbrc	r19, 1
    1190:	40 52       	subi	r20, 0x20	; 32
    1192:	41 93       	st	Z+, r20
    1194:	02 d0       	rcall	.+4      	; 0x119a <__ultoa_invert+0x84>
    1196:	a9 f7       	brne	.-22     	; 0x1182 <__ultoa_invert+0x6c>
    1198:	ea cf       	rjmp	.-44     	; 0x116e <__ultoa_invert+0x58>
    119a:	b4 e0       	ldi	r27, 0x04	; 4
    119c:	a6 95       	lsr	r26
    119e:	97 95       	ror	r25
    11a0:	87 95       	ror	r24
    11a2:	77 95       	ror	r23
    11a4:	67 95       	ror	r22
    11a6:	ba 95       	dec	r27
    11a8:	c9 f7       	brne	.-14     	; 0x119c <__ultoa_invert+0x86>
    11aa:	00 97       	sbiw	r24, 0x00	; 0
    11ac:	61 05       	cpc	r22, r1
    11ae:	71 05       	cpc	r23, r1
    11b0:	08 95       	ret
    11b2:	9b 01       	movw	r18, r22
    11b4:	ac 01       	movw	r20, r24
    11b6:	0a 2e       	mov	r0, r26
    11b8:	06 94       	lsr	r0
    11ba:	57 95       	ror	r21
    11bc:	47 95       	ror	r20
    11be:	37 95       	ror	r19
    11c0:	27 95       	ror	r18
    11c2:	ba 95       	dec	r27
    11c4:	c9 f7       	brne	.-14     	; 0x11b8 <__ultoa_invert+0xa2>
    11c6:	62 0f       	add	r22, r18
    11c8:	73 1f       	adc	r23, r19
    11ca:	84 1f       	adc	r24, r20
    11cc:	95 1f       	adc	r25, r21
    11ce:	a0 1d       	adc	r26, r0
    11d0:	08 95       	ret

000011d2 <__prologue_saves__>:
    11d2:	2f 92       	push	r2
    11d4:	3f 92       	push	r3
    11d6:	4f 92       	push	r4
    11d8:	5f 92       	push	r5
    11da:	6f 92       	push	r6
    11dc:	7f 92       	push	r7
    11de:	8f 92       	push	r8
    11e0:	9f 92       	push	r9
    11e2:	af 92       	push	r10
    11e4:	bf 92       	push	r11
    11e6:	cf 92       	push	r12
    11e8:	df 92       	push	r13
    11ea:	ef 92       	push	r14
    11ec:	ff 92       	push	r15
    11ee:	0f 93       	push	r16
    11f0:	1f 93       	push	r17
    11f2:	cf 93       	push	r28
    11f4:	df 93       	push	r29
    11f6:	cd b7       	in	r28, 0x3d	; 61
    11f8:	de b7       	in	r29, 0x3e	; 62
    11fa:	ca 1b       	sub	r28, r26
    11fc:	db 0b       	sbc	r29, r27
    11fe:	0f b6       	in	r0, 0x3f	; 63
    1200:	f8 94       	cli
    1202:	de bf       	out	0x3e, r29	; 62
    1204:	0f be       	out	0x3f, r0	; 63
    1206:	cd bf       	out	0x3d, r28	; 61
    1208:	09 94       	ijmp

0000120a <__epilogue_restores__>:
    120a:	2a 88       	ldd	r2, Y+18	; 0x12
    120c:	39 88       	ldd	r3, Y+17	; 0x11
    120e:	48 88       	ldd	r4, Y+16	; 0x10
    1210:	5f 84       	ldd	r5, Y+15	; 0x0f
    1212:	6e 84       	ldd	r6, Y+14	; 0x0e
    1214:	7d 84       	ldd	r7, Y+13	; 0x0d
    1216:	8c 84       	ldd	r8, Y+12	; 0x0c
    1218:	9b 84       	ldd	r9, Y+11	; 0x0b
    121a:	aa 84       	ldd	r10, Y+10	; 0x0a
    121c:	b9 84       	ldd	r11, Y+9	; 0x09
    121e:	c8 84       	ldd	r12, Y+8	; 0x08
    1220:	df 80       	ldd	r13, Y+7	; 0x07
    1222:	ee 80       	ldd	r14, Y+6	; 0x06
    1224:	fd 80       	ldd	r15, Y+5	; 0x05
    1226:	0c 81       	ldd	r16, Y+4	; 0x04
    1228:	1b 81       	ldd	r17, Y+3	; 0x03
    122a:	aa 81       	ldd	r26, Y+2	; 0x02
    122c:	b9 81       	ldd	r27, Y+1	; 0x01
    122e:	ce 0f       	add	r28, r30
    1230:	d1 1d       	adc	r29, r1
    1232:	0f b6       	in	r0, 0x3f	; 63
    1234:	f8 94       	cli
    1236:	de bf       	out	0x3e, r29	; 62
    1238:	0f be       	out	0x3f, r0	; 63
    123a:	cd bf       	out	0x3d, r28	; 61
    123c:	ed 01       	movw	r28, r26
    123e:	08 95       	ret

00001240 <_exit>:
    1240:	f8 94       	cli

00001242 <__stop_program>:
    1242:	ff cf       	rjmp	.-2      	; 0x1242 <__stop_program>
