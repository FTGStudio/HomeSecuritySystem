
HomeSecuritySystem.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000048  00800100  00001730  000017c4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001730  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000045a  00800148  00800148  0000180c  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  0000180c  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000340  00000000  00000000  00001868  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00003f48  00000000  00000000  00001ba8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000e23  00000000  00000000  00005af0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   000016b6  00000000  00000000  00006913  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000009b0  00000000  00000000  00007fcc  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000121f  00000000  00000000  0000897c  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00003ad3  00000000  00000000  00009b9b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 000002f8  00000000  00000000  0000d66e  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 bf 02 	jmp	0x57e	; 0x57e <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e0 e3       	ldi	r30, 0x30	; 48
      7c:	f7 e1       	ldi	r31, 0x17	; 23
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a8 34       	cpi	r26, 0x48	; 72
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	25 e0       	ldi	r18, 0x05	; 5
      8c:	a8 e4       	ldi	r26, 0x48	; 72
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a2 3a       	cpi	r26, 0xA2	; 162
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 76 00 	call	0xec	; 0xec <main>
      9e:	0c 94 96 0b 	jmp	0x172c	; 0x172c <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vHallEffectTask>:
#include "../Source/include/queue.h"

xQueueHandle hallEffectMsgQ;

void vHallEffectTask(void *pvParameters)
{
      a6:	cf 93       	push	r28
      a8:	df 93       	push	r29
      aa:	00 d0       	rcall	.+0      	; 0xac <vHallEffectTask+0x6>
      ac:	00 d0       	rcall	.+0      	; 0xae <vHallEffectTask+0x8>
      ae:	cd b7       	in	r28, 0x3d	; 61
      b0:	de b7       	in	r29, 0x3e	; 62
	HallEffectMsg_t msg;
	while(1)
	{
		if(xQueueReceive(hallEffectMsgQ, &msg, blockTime))
		{
			printf("Hall effect voltage %d", (int)msg.hallEffectData);
      b2:	0c e1       	ldi	r16, 0x1C	; 28
      b4:	11 e0       	ldi	r17, 0x01	; 1
{
	uint32_t blockTime = portMAX_DELAY;
	HallEffectMsg_t msg;
	while(1)
	{
		if(xQueueReceive(hallEffectMsgQ, &msg, blockTime))
      b6:	20 e0       	ldi	r18, 0x00	; 0
      b8:	4f ef       	ldi	r20, 0xFF	; 255
      ba:	5f ef       	ldi	r21, 0xFF	; 255
      bc:	be 01       	movw	r22, r28
      be:	6f 5f       	subi	r22, 0xFF	; 255
      c0:	7f 4f       	sbci	r23, 0xFF	; 255
      c2:	80 91 98 05 	lds	r24, 0x0598
      c6:	90 91 99 05 	lds	r25, 0x0599
      ca:	0e 94 c7 03 	call	0x78e	; 0x78e <xQueueGenericReceive>
      ce:	88 23       	and	r24, r24
      d0:	91 f3       	breq	.-28     	; 0xb6 <vHallEffectTask+0x10>
		{
			printf("Hall effect voltage %d", (int)msg.hallEffectData);
      d2:	8a 81       	ldd	r24, Y+2	; 0x02
      d4:	8f 93       	push	r24
      d6:	89 81       	ldd	r24, Y+1	; 0x01
      d8:	8f 93       	push	r24
      da:	1f 93       	push	r17
      dc:	0f 93       	push	r16
      de:	0e 94 d3 08 	call	0x11a6	; 0x11a6 <printf>
      e2:	0f 90       	pop	r0
      e4:	0f 90       	pop	r0
      e6:	0f 90       	pop	r0
      e8:	0f 90       	pop	r0
      ea:	e5 cf       	rjmp	.-54     	; 0xb6 <vHallEffectTask+0x10>

000000ec <main>:
#define MYUBRR						F_CPU/8/BAUD-1



int main(void)
{
      ec:	af 92       	push	r10
      ee:	bf 92       	push	r11
      f0:	cf 92       	push	r12
      f2:	df 92       	push	r13
      f4:	ef 92       	push	r14
      f6:	ff 92       	push	r15
      f8:	0f 93       	push	r16
	
	USART_Init(MYUBRR);
      fa:	87 e6       	ldi	r24, 0x67	; 103
      fc:	90 e0       	ldi	r25, 0x00	; 0
      fe:	0e 94 a7 08 	call	0x114e	; 0x114e <USART_Init>
	stdout = &uart_output;
     102:	8e e0       	ldi	r24, 0x0E	; 14
     104:	91 e0       	ldi	r25, 0x01	; 1
     106:	90 93 9f 05 	sts	0x059F, r25
     10a:	80 93 9e 05 	sts	0x059E, r24
	stdin = &uart_input;
     10e:	80 e0       	ldi	r24, 0x00	; 0
     110:	91 e0       	ldi	r25, 0x01	; 1
     112:	90 93 9d 05 	sts	0x059D, r25
     116:	80 93 9c 05 	sts	0x059C, r24
	
	hallEffectMsgQ = xQueueCreate(2, sizeof(HallEffectMsg_t));
     11a:	40 e0       	ldi	r20, 0x00	; 0
     11c:	64 e0       	ldi	r22, 0x04	; 4
     11e:	82 e0       	ldi	r24, 0x02	; 2
     120:	0e 94 99 03 	call	0x732	; 0x732 <xQueueGenericCreate>
     124:	90 93 99 05 	sts	0x0599, r25
     128:	80 93 98 05 	sts	0x0598, r24
	rtcMsgQ = xQueueCreate(2, sizeof(RTCMsg_t));
     12c:	40 e0       	ldi	r20, 0x00	; 0
     12e:	66 e0       	ldi	r22, 0x06	; 6
     130:	82 e0       	ldi	r24, 0x02	; 2
     132:	0e 94 99 03 	call	0x732	; 0x732 <xQueueGenericCreate>
     136:	90 93 9b 05 	sts	0x059B, r25
     13a:	80 93 9a 05 	sts	0x059A, r24
	
	xTaskCreate( vRTCTask, ( signed char * ) "RTC", configMINIMAL_STACK_SIZE, NULL, 1, NULL );
     13e:	a1 2c       	mov	r10, r1
     140:	b1 2c       	mov	r11, r1
     142:	c1 2c       	mov	r12, r1
     144:	d1 2c       	mov	r13, r1
     146:	e1 2c       	mov	r14, r1
     148:	f1 2c       	mov	r15, r1
     14a:	01 e0       	ldi	r16, 0x01	; 1
     14c:	20 e0       	ldi	r18, 0x00	; 0
     14e:	30 e0       	ldi	r19, 0x00	; 0
     150:	45 e5       	ldi	r20, 0x55	; 85
     152:	50 e0       	ldi	r21, 0x00	; 0
     154:	63 e3       	ldi	r22, 0x33	; 51
     156:	71 e0       	ldi	r23, 0x01	; 1
     158:	86 ec       	ldi	r24, 0xC6	; 198
     15a:	90 e0       	ldi	r25, 0x00	; 0
     15c:	0e 94 c9 04 	call	0x992	; 0x992 <xTaskGenericCreate>
	xTaskCreate( vHallEffectTask, ( signed char * ) "HallEffect", configMINIMAL_STACK_SIZE, NULL, 1, NULL );
     160:	20 e0       	ldi	r18, 0x00	; 0
     162:	30 e0       	ldi	r19, 0x00	; 0
     164:	45 e5       	ldi	r20, 0x55	; 85
     166:	50 e0       	ldi	r21, 0x00	; 0
     168:	67 e3       	ldi	r22, 0x37	; 55
     16a:	71 e0       	ldi	r23, 0x01	; 1
     16c:	83 e5       	ldi	r24, 0x53	; 83
     16e:	90 e0       	ldi	r25, 0x00	; 0
     170:	0e 94 c9 04 	call	0x992	; 0x992 <xTaskGenericCreate>
	vTaskStartScheduler();
     174:	0e 94 d7 05 	call	0xbae	; 0xbae <vTaskStartScheduler>
     178:	80 e0       	ldi	r24, 0x00	; 0
     17a:	90 e0       	ldi	r25, 0x00	; 0
     17c:	0f 91       	pop	r16
     17e:	ff 90       	pop	r15
     180:	ef 90       	pop	r14
     182:	df 90       	pop	r13
     184:	cf 90       	pop	r12
     186:	bf 90       	pop	r11
     188:	af 90       	pop	r10
     18a:	08 95       	ret

0000018c <vRTCTask>:
#include "../Source/include/queue.h"

xQueueHandle rtcMsgQ;

void vRTCTask( void *pvParameters )
{
     18c:	cf 93       	push	r28
     18e:	df 93       	push	r29
     190:	00 d0       	rcall	.+0      	; 0x192 <vRTCTask+0x6>
     192:	00 d0       	rcall	.+0      	; 0x194 <vRTCTask+0x8>
     194:	00 d0       	rcall	.+0      	; 0x196 <vRTCTask+0xa>
     196:	cd b7       	in	r28, 0x3d	; 61
     198:	de b7       	in	r29, 0x3e	; 62
	uint32_t blockTime = portMAX_DELAY;
	RTCMsg_t msg;
	while(1)
	{
		if(xQueueReceive(rtcMsgQ, &msg, blockTime))
     19a:	20 e0       	ldi	r18, 0x00	; 0
     19c:	4f ef       	ldi	r20, 0xFF	; 255
     19e:	5f ef       	ldi	r21, 0xFF	; 255
     1a0:	be 01       	movw	r22, r28
     1a2:	6f 5f       	subi	r22, 0xFF	; 255
     1a4:	7f 4f       	sbci	r23, 0xFF	; 255
     1a6:	80 91 9a 05 	lds	r24, 0x059A
     1aa:	90 91 9b 05 	lds	r25, 0x059B
     1ae:	0e 94 c7 03 	call	0x78e	; 0x78e <xQueueGenericReceive>
     1b2:	f3 cf       	rjmp	.-26     	; 0x19a <vRTCTask+0xe>

000001b4 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     1b4:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     1b6:	03 96       	adiw	r24, 0x03	; 3
     1b8:	92 83       	std	Z+2, r25	; 0x02
     1ba:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     1bc:	2f ef       	ldi	r18, 0xFF	; 255
     1be:	3f ef       	ldi	r19, 0xFF	; 255
     1c0:	34 83       	std	Z+4, r19	; 0x04
     1c2:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     1c4:	96 83       	std	Z+6, r25	; 0x06
     1c6:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     1c8:	90 87       	std	Z+8, r25	; 0x08
     1ca:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     1cc:	10 82       	st	Z, r1
     1ce:	08 95       	ret

000001d0 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     1d0:	fc 01       	movw	r30, r24
     1d2:	11 86       	std	Z+9, r1	; 0x09
     1d4:	10 86       	std	Z+8, r1	; 0x08
     1d6:	08 95       	ret

000001d8 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     1d8:	cf 93       	push	r28
     1da:	df 93       	push	r29
     1dc:	9c 01       	movw	r18, r24
     1de:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     1e0:	dc 01       	movw	r26, r24
     1e2:	11 96       	adiw	r26, 0x01	; 1
     1e4:	cd 91       	ld	r28, X+
     1e6:	dc 91       	ld	r29, X
     1e8:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     1ea:	d3 83       	std	Z+3, r29	; 0x03
     1ec:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     1ee:	8c 81       	ldd	r24, Y+4	; 0x04
     1f0:	9d 81       	ldd	r25, Y+5	; 0x05
     1f2:	95 83       	std	Z+5, r25	; 0x05
     1f4:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     1f6:	8c 81       	ldd	r24, Y+4	; 0x04
     1f8:	9d 81       	ldd	r25, Y+5	; 0x05
     1fa:	dc 01       	movw	r26, r24
     1fc:	13 96       	adiw	r26, 0x03	; 3
     1fe:	7c 93       	st	X, r23
     200:	6e 93       	st	-X, r22
     202:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     204:	7d 83       	std	Y+5, r23	; 0x05
     206:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     208:	31 87       	std	Z+9, r19	; 0x09
     20a:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     20c:	f9 01       	movw	r30, r18
     20e:	80 81       	ld	r24, Z
     210:	8f 5f       	subi	r24, 0xFF	; 255
     212:	80 83       	st	Z, r24
}
     214:	df 91       	pop	r29
     216:	cf 91       	pop	r28
     218:	08 95       	ret

0000021a <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     21a:	cf 93       	push	r28
     21c:	df 93       	push	r29
     21e:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     220:	48 81       	ld	r20, Y
     222:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     224:	4f 3f       	cpi	r20, 0xFF	; 255
     226:	2f ef       	ldi	r18, 0xFF	; 255
     228:	52 07       	cpc	r21, r18
     22a:	21 f4       	brne	.+8      	; 0x234 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     22c:	fc 01       	movw	r30, r24
     22e:	a7 81       	ldd	r26, Z+7	; 0x07
     230:	b0 85       	ldd	r27, Z+8	; 0x08
     232:	0d c0       	rjmp	.+26     	; 0x24e <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     234:	dc 01       	movw	r26, r24
     236:	13 96       	adiw	r26, 0x03	; 3
     238:	12 96       	adiw	r26, 0x02	; 2
     23a:	ed 91       	ld	r30, X+
     23c:	fc 91       	ld	r31, X
     23e:	13 97       	sbiw	r26, 0x03	; 3
     240:	20 81       	ld	r18, Z
     242:	31 81       	ldd	r19, Z+1	; 0x01
     244:	42 17       	cp	r20, r18
     246:	53 07       	cpc	r21, r19
     248:	10 f0       	brcs	.+4      	; 0x24e <vListInsert+0x34>
     24a:	df 01       	movw	r26, r30
     24c:	f5 cf       	rjmp	.-22     	; 0x238 <vListInsert+0x1e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     24e:	12 96       	adiw	r26, 0x02	; 2
     250:	ed 91       	ld	r30, X+
     252:	fc 91       	ld	r31, X
     254:	13 97       	sbiw	r26, 0x03	; 3
     256:	fb 83       	std	Y+3, r31	; 0x03
     258:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     25a:	d5 83       	std	Z+5, r29	; 0x05
     25c:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     25e:	bd 83       	std	Y+5, r27	; 0x05
     260:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     262:	13 96       	adiw	r26, 0x03	; 3
     264:	dc 93       	st	X, r29
     266:	ce 93       	st	-X, r28
     268:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     26a:	99 87       	std	Y+9, r25	; 0x09
     26c:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     26e:	fc 01       	movw	r30, r24
     270:	20 81       	ld	r18, Z
     272:	2f 5f       	subi	r18, 0xFF	; 255
     274:	20 83       	st	Z, r18
}
     276:	df 91       	pop	r29
     278:	cf 91       	pop	r28
     27a:	08 95       	ret

0000027c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     27c:	cf 93       	push	r28
     27e:	df 93       	push	r29
     280:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     282:	a0 85       	ldd	r26, Z+8	; 0x08
     284:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     286:	c2 81       	ldd	r28, Z+2	; 0x02
     288:	d3 81       	ldd	r29, Z+3	; 0x03
     28a:	84 81       	ldd	r24, Z+4	; 0x04
     28c:	95 81       	ldd	r25, Z+5	; 0x05
     28e:	9d 83       	std	Y+5, r25	; 0x05
     290:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     292:	c4 81       	ldd	r28, Z+4	; 0x04
     294:	d5 81       	ldd	r29, Z+5	; 0x05
     296:	82 81       	ldd	r24, Z+2	; 0x02
     298:	93 81       	ldd	r25, Z+3	; 0x03
     29a:	9b 83       	std	Y+3, r25	; 0x03
     29c:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     29e:	11 96       	adiw	r26, 0x01	; 1
     2a0:	cd 91       	ld	r28, X+
     2a2:	dc 91       	ld	r29, X
     2a4:	12 97       	sbiw	r26, 0x02	; 2
     2a6:	ce 17       	cp	r28, r30
     2a8:	df 07       	cpc	r29, r31
     2aa:	31 f4       	brne	.+12     	; 0x2b8 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     2ac:	8c 81       	ldd	r24, Y+4	; 0x04
     2ae:	9d 81       	ldd	r25, Y+5	; 0x05
     2b0:	12 96       	adiw	r26, 0x02	; 2
     2b2:	9c 93       	st	X, r25
     2b4:	8e 93       	st	-X, r24
     2b6:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     2b8:	11 86       	std	Z+9, r1	; 0x09
     2ba:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     2bc:	8c 91       	ld	r24, X
     2be:	81 50       	subi	r24, 0x01	; 1
     2c0:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     2c2:	df 91       	pop	r29
     2c4:	cf 91       	pop	r28
     2c6:	08 95       	ret

000002c8 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     2c8:	31 e1       	ldi	r19, 0x11	; 17
     2ca:	fc 01       	movw	r30, r24
     2cc:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     2ce:	31 97       	sbiw	r30, 0x01	; 1
     2d0:	22 e2       	ldi	r18, 0x22	; 34
     2d2:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     2d4:	31 97       	sbiw	r30, 0x01	; 1
     2d6:	a3 e3       	ldi	r26, 0x33	; 51
     2d8:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     2da:	31 97       	sbiw	r30, 0x01	; 1
     2dc:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     2de:	31 97       	sbiw	r30, 0x01	; 1
     2e0:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     2e2:	31 97       	sbiw	r30, 0x01	; 1
     2e4:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     2e6:	31 97       	sbiw	r30, 0x01	; 1
     2e8:	60 e8       	ldi	r22, 0x80	; 128
     2ea:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     2ec:	31 97       	sbiw	r30, 0x01	; 1
     2ee:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     2f0:	31 97       	sbiw	r30, 0x01	; 1
     2f2:	62 e0       	ldi	r22, 0x02	; 2
     2f4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     2f6:	31 97       	sbiw	r30, 0x01	; 1
     2f8:	63 e0       	ldi	r22, 0x03	; 3
     2fa:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     2fc:	31 97       	sbiw	r30, 0x01	; 1
     2fe:	64 e0       	ldi	r22, 0x04	; 4
     300:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     302:	31 97       	sbiw	r30, 0x01	; 1
     304:	65 e0       	ldi	r22, 0x05	; 5
     306:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     308:	31 97       	sbiw	r30, 0x01	; 1
     30a:	66 e0       	ldi	r22, 0x06	; 6
     30c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     30e:	31 97       	sbiw	r30, 0x01	; 1
     310:	67 e0       	ldi	r22, 0x07	; 7
     312:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     314:	31 97       	sbiw	r30, 0x01	; 1
     316:	68 e0       	ldi	r22, 0x08	; 8
     318:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     31a:	31 97       	sbiw	r30, 0x01	; 1
     31c:	69 e0       	ldi	r22, 0x09	; 9
     31e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     320:	31 97       	sbiw	r30, 0x01	; 1
     322:	60 e1       	ldi	r22, 0x10	; 16
     324:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     326:	31 97       	sbiw	r30, 0x01	; 1
     328:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     32a:	31 97       	sbiw	r30, 0x01	; 1
     32c:	32 e1       	ldi	r19, 0x12	; 18
     32e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     330:	31 97       	sbiw	r30, 0x01	; 1
     332:	33 e1       	ldi	r19, 0x13	; 19
     334:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     336:	31 97       	sbiw	r30, 0x01	; 1
     338:	34 e1       	ldi	r19, 0x14	; 20
     33a:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     33c:	31 97       	sbiw	r30, 0x01	; 1
     33e:	35 e1       	ldi	r19, 0x15	; 21
     340:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     342:	31 97       	sbiw	r30, 0x01	; 1
     344:	36 e1       	ldi	r19, 0x16	; 22
     346:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     348:	31 97       	sbiw	r30, 0x01	; 1
     34a:	37 e1       	ldi	r19, 0x17	; 23
     34c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     34e:	31 97       	sbiw	r30, 0x01	; 1
     350:	38 e1       	ldi	r19, 0x18	; 24
     352:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     354:	31 97       	sbiw	r30, 0x01	; 1
     356:	39 e1       	ldi	r19, 0x19	; 25
     358:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     35a:	31 97       	sbiw	r30, 0x01	; 1
     35c:	30 e2       	ldi	r19, 0x20	; 32
     35e:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     360:	31 97       	sbiw	r30, 0x01	; 1
     362:	31 e2       	ldi	r19, 0x21	; 33
     364:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     366:	31 97       	sbiw	r30, 0x01	; 1
     368:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     36a:	31 97       	sbiw	r30, 0x01	; 1
     36c:	23 e2       	ldi	r18, 0x23	; 35
     36e:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     370:	31 97       	sbiw	r30, 0x01	; 1
     372:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     374:	31 97       	sbiw	r30, 0x01	; 1
     376:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     378:	31 97       	sbiw	r30, 0x01	; 1
     37a:	26 e2       	ldi	r18, 0x26	; 38
     37c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     37e:	31 97       	sbiw	r30, 0x01	; 1
     380:	27 e2       	ldi	r18, 0x27	; 39
     382:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     384:	31 97       	sbiw	r30, 0x01	; 1
     386:	28 e2       	ldi	r18, 0x28	; 40
     388:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     38a:	31 97       	sbiw	r30, 0x01	; 1
     38c:	29 e2       	ldi	r18, 0x29	; 41
     38e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     390:	31 97       	sbiw	r30, 0x01	; 1
     392:	20 e3       	ldi	r18, 0x30	; 48
     394:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     396:	31 97       	sbiw	r30, 0x01	; 1
     398:	21 e3       	ldi	r18, 0x31	; 49
     39a:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     39c:	86 97       	sbiw	r24, 0x26	; 38
     39e:	08 95       	ret

000003a0 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
     3a0:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
     3a4:	8c e7       	ldi	r24, 0x7C	; 124
     3a6:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     3aa:	8b e0       	ldi	r24, 0x0B	; 11
     3ac:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
     3b0:	ef e6       	ldi	r30, 0x6F	; 111
     3b2:	f0 e0       	ldi	r31, 0x00	; 0
     3b4:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     3b6:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
     3b8:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     3ba:	a0 91 96 05 	lds	r26, 0x0596
     3be:	b0 91 97 05 	lds	r27, 0x0597
     3c2:	cd 91       	ld	r28, X+
     3c4:	cd bf       	out	0x3d, r28	; 61
     3c6:	dd 91       	ld	r29, X+
     3c8:	de bf       	out	0x3e, r29	; 62
     3ca:	ff 91       	pop	r31
     3cc:	ef 91       	pop	r30
     3ce:	df 91       	pop	r29
     3d0:	cf 91       	pop	r28
     3d2:	bf 91       	pop	r27
     3d4:	af 91       	pop	r26
     3d6:	9f 91       	pop	r25
     3d8:	8f 91       	pop	r24
     3da:	7f 91       	pop	r23
     3dc:	6f 91       	pop	r22
     3de:	5f 91       	pop	r21
     3e0:	4f 91       	pop	r20
     3e2:	3f 91       	pop	r19
     3e4:	2f 91       	pop	r18
     3e6:	1f 91       	pop	r17
     3e8:	0f 91       	pop	r16
     3ea:	ff 90       	pop	r15
     3ec:	ef 90       	pop	r14
     3ee:	df 90       	pop	r13
     3f0:	cf 90       	pop	r12
     3f2:	bf 90       	pop	r11
     3f4:	af 90       	pop	r10
     3f6:	9f 90       	pop	r9
     3f8:	8f 90       	pop	r8
     3fa:	7f 90       	pop	r7
     3fc:	6f 90       	pop	r6
     3fe:	5f 90       	pop	r5
     400:	4f 90       	pop	r4
     402:	3f 90       	pop	r3
     404:	2f 90       	pop	r2
     406:	1f 90       	pop	r1
     408:	0f 90       	pop	r0
     40a:	0f be       	out	0x3f, r0	; 63
     40c:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     40e:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     410:	81 e0       	ldi	r24, 0x01	; 1
     412:	08 95       	ret

00000414 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     414:	0f 92       	push	r0
     416:	0f b6       	in	r0, 0x3f	; 63
     418:	f8 94       	cli
     41a:	0f 92       	push	r0
     41c:	1f 92       	push	r1
     41e:	11 24       	eor	r1, r1
     420:	2f 92       	push	r2
     422:	3f 92       	push	r3
     424:	4f 92       	push	r4
     426:	5f 92       	push	r5
     428:	6f 92       	push	r6
     42a:	7f 92       	push	r7
     42c:	8f 92       	push	r8
     42e:	9f 92       	push	r9
     430:	af 92       	push	r10
     432:	bf 92       	push	r11
     434:	cf 92       	push	r12
     436:	df 92       	push	r13
     438:	ef 92       	push	r14
     43a:	ff 92       	push	r15
     43c:	0f 93       	push	r16
     43e:	1f 93       	push	r17
     440:	2f 93       	push	r18
     442:	3f 93       	push	r19
     444:	4f 93       	push	r20
     446:	5f 93       	push	r21
     448:	6f 93       	push	r22
     44a:	7f 93       	push	r23
     44c:	8f 93       	push	r24
     44e:	9f 93       	push	r25
     450:	af 93       	push	r26
     452:	bf 93       	push	r27
     454:	cf 93       	push	r28
     456:	df 93       	push	r29
     458:	ef 93       	push	r30
     45a:	ff 93       	push	r31
     45c:	a0 91 96 05 	lds	r26, 0x0596
     460:	b0 91 97 05 	lds	r27, 0x0597
     464:	0d b6       	in	r0, 0x3d	; 61
     466:	0d 92       	st	X+, r0
     468:	0e b6       	in	r0, 0x3e	; 62
     46a:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     46c:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     470:	a0 91 96 05 	lds	r26, 0x0596
     474:	b0 91 97 05 	lds	r27, 0x0597
     478:	cd 91       	ld	r28, X+
     47a:	cd bf       	out	0x3d, r28	; 61
     47c:	dd 91       	ld	r29, X+
     47e:	de bf       	out	0x3e, r29	; 62
     480:	ff 91       	pop	r31
     482:	ef 91       	pop	r30
     484:	df 91       	pop	r29
     486:	cf 91       	pop	r28
     488:	bf 91       	pop	r27
     48a:	af 91       	pop	r26
     48c:	9f 91       	pop	r25
     48e:	8f 91       	pop	r24
     490:	7f 91       	pop	r23
     492:	6f 91       	pop	r22
     494:	5f 91       	pop	r21
     496:	4f 91       	pop	r20
     498:	3f 91       	pop	r19
     49a:	2f 91       	pop	r18
     49c:	1f 91       	pop	r17
     49e:	0f 91       	pop	r16
     4a0:	ff 90       	pop	r15
     4a2:	ef 90       	pop	r14
     4a4:	df 90       	pop	r13
     4a6:	cf 90       	pop	r12
     4a8:	bf 90       	pop	r11
     4aa:	af 90       	pop	r10
     4ac:	9f 90       	pop	r9
     4ae:	8f 90       	pop	r8
     4b0:	7f 90       	pop	r7
     4b2:	6f 90       	pop	r6
     4b4:	5f 90       	pop	r5
     4b6:	4f 90       	pop	r4
     4b8:	3f 90       	pop	r3
     4ba:	2f 90       	pop	r2
     4bc:	1f 90       	pop	r1
     4be:	0f 90       	pop	r0
     4c0:	0f be       	out	0x3f, r0	; 63
     4c2:	0f 90       	pop	r0

	asm volatile ( "ret" );
     4c4:	08 95       	ret

000004c6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     4c6:	0f 92       	push	r0
     4c8:	0f b6       	in	r0, 0x3f	; 63
     4ca:	f8 94       	cli
     4cc:	0f 92       	push	r0
     4ce:	1f 92       	push	r1
     4d0:	11 24       	eor	r1, r1
     4d2:	2f 92       	push	r2
     4d4:	3f 92       	push	r3
     4d6:	4f 92       	push	r4
     4d8:	5f 92       	push	r5
     4da:	6f 92       	push	r6
     4dc:	7f 92       	push	r7
     4de:	8f 92       	push	r8
     4e0:	9f 92       	push	r9
     4e2:	af 92       	push	r10
     4e4:	bf 92       	push	r11
     4e6:	cf 92       	push	r12
     4e8:	df 92       	push	r13
     4ea:	ef 92       	push	r14
     4ec:	ff 92       	push	r15
     4ee:	0f 93       	push	r16
     4f0:	1f 93       	push	r17
     4f2:	2f 93       	push	r18
     4f4:	3f 93       	push	r19
     4f6:	4f 93       	push	r20
     4f8:	5f 93       	push	r21
     4fa:	6f 93       	push	r22
     4fc:	7f 93       	push	r23
     4fe:	8f 93       	push	r24
     500:	9f 93       	push	r25
     502:	af 93       	push	r26
     504:	bf 93       	push	r27
     506:	cf 93       	push	r28
     508:	df 93       	push	r29
     50a:	ef 93       	push	r30
     50c:	ff 93       	push	r31
     50e:	a0 91 96 05 	lds	r26, 0x0596
     512:	b0 91 97 05 	lds	r27, 0x0597
     516:	0d b6       	in	r0, 0x3d	; 61
     518:	0d 92       	st	X+, r0
     51a:	0e b6       	in	r0, 0x3e	; 62
     51c:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     51e:	0e 94 0f 06 	call	0xc1e	; 0xc1e <xTaskIncrementTick>
     522:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     524:	0e 94 8d 07 	call	0xf1a	; 0xf1a <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     528:	a0 91 96 05 	lds	r26, 0x0596
     52c:	b0 91 97 05 	lds	r27, 0x0597
     530:	cd 91       	ld	r28, X+
     532:	cd bf       	out	0x3d, r28	; 61
     534:	dd 91       	ld	r29, X+
     536:	de bf       	out	0x3e, r29	; 62
     538:	ff 91       	pop	r31
     53a:	ef 91       	pop	r30
     53c:	df 91       	pop	r29
     53e:	cf 91       	pop	r28
     540:	bf 91       	pop	r27
     542:	af 91       	pop	r26
     544:	9f 91       	pop	r25
     546:	8f 91       	pop	r24
     548:	7f 91       	pop	r23
     54a:	6f 91       	pop	r22
     54c:	5f 91       	pop	r21
     54e:	4f 91       	pop	r20
     550:	3f 91       	pop	r19
     552:	2f 91       	pop	r18
     554:	1f 91       	pop	r17
     556:	0f 91       	pop	r16
     558:	ff 90       	pop	r15
     55a:	ef 90       	pop	r14
     55c:	df 90       	pop	r13
     55e:	cf 90       	pop	r12
     560:	bf 90       	pop	r11
     562:	af 90       	pop	r10
     564:	9f 90       	pop	r9
     566:	8f 90       	pop	r8
     568:	7f 90       	pop	r7
     56a:	6f 90       	pop	r6
     56c:	5f 90       	pop	r5
     56e:	4f 90       	pop	r4
     570:	3f 90       	pop	r3
     572:	2f 90       	pop	r2
     574:	1f 90       	pop	r1
     576:	0f 90       	pop	r0
     578:	0f be       	out	0x3f, r0	; 63
     57a:	0f 90       	pop	r0

	asm volatile ( "ret" );
     57c:	08 95       	ret

0000057e <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     57e:	0e 94 63 02 	call	0x4c6	; 0x4c6 <vPortYieldFromTick>
		asm volatile ( "reti" );
     582:	18 95       	reti

00000584 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     584:	cf 93       	push	r28
     586:	df 93       	push	r29
     588:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     58a:	0e 94 09 06 	call	0xc12	; 0xc12 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     58e:	80 91 48 01 	lds	r24, 0x0148
     592:	90 91 49 01 	lds	r25, 0x0149
     596:	89 2b       	or	r24, r25
     598:	31 f4       	brne	.+12     	; 0x5a6 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     59a:	8d e4       	ldi	r24, 0x4D	; 77
     59c:	91 e0       	ldi	r25, 0x01	; 1
     59e:	90 93 49 01 	sts	0x0149, r25
     5a2:	80 93 48 01 	sts	0x0148, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     5a6:	40 91 4a 01 	lds	r20, 0x014A
     5aa:	50 91 4b 01 	lds	r21, 0x014B
     5ae:	9e 01       	movw	r18, r28
     5b0:	24 0f       	add	r18, r20
     5b2:	35 1f       	adc	r19, r21
     5b4:	27 3e       	cpi	r18, 0xE7	; 231
     5b6:	83 e0       	ldi	r24, 0x03	; 3
     5b8:	38 07       	cpc	r19, r24
     5ba:	70 f4       	brcc	.+28     	; 0x5d8 <pvPortMalloc+0x54>
     5bc:	42 17       	cp	r20, r18
     5be:	53 07       	cpc	r21, r19
     5c0:	70 f4       	brcc	.+28     	; 0x5de <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     5c2:	c0 91 48 01 	lds	r28, 0x0148
     5c6:	d0 91 49 01 	lds	r29, 0x0149
     5ca:	c4 0f       	add	r28, r20
     5cc:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     5ce:	30 93 4b 01 	sts	0x014B, r19
     5d2:	20 93 4a 01 	sts	0x014A, r18
     5d6:	05 c0       	rjmp	.+10     	; 0x5e2 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     5d8:	c0 e0       	ldi	r28, 0x00	; 0
     5da:	d0 e0       	ldi	r29, 0x00	; 0
     5dc:	02 c0       	rjmp	.+4      	; 0x5e2 <pvPortMalloc+0x5e>
     5de:	c0 e0       	ldi	r28, 0x00	; 0
     5e0:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     5e2:	0e 94 ce 06 	call	0xd9c	; 0xd9c <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     5e6:	ce 01       	movw	r24, r28
     5e8:	df 91       	pop	r29
     5ea:	cf 91       	pop	r28
     5ec:	08 95       	ret

000005ee <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     5ee:	08 95       	ret

000005f0 <prvCopyDataFromQueue>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
     5f0:	fc 01       	movw	r30, r24
     5f2:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     5f4:	44 8d       	ldd	r20, Z+28	; 0x1c
     5f6:	44 23       	and	r20, r20
     5f8:	a1 f0       	breq	.+40     	; 0x622 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     5fa:	50 e0       	ldi	r21, 0x00	; 0
     5fc:	26 81       	ldd	r18, Z+6	; 0x06
     5fe:	37 81       	ldd	r19, Z+7	; 0x07
     600:	24 0f       	add	r18, r20
     602:	35 1f       	adc	r19, r21
     604:	37 83       	std	Z+7, r19	; 0x07
     606:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     608:	62 81       	ldd	r22, Z+2	; 0x02
     60a:	73 81       	ldd	r23, Z+3	; 0x03
     60c:	26 17       	cp	r18, r22
     60e:	37 07       	cpc	r19, r23
     610:	20 f0       	brcs	.+8      	; 0x61a <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     612:	20 81       	ld	r18, Z
     614:	31 81       	ldd	r19, Z+1	; 0x01
     616:	37 83       	std	Z+7, r19	; 0x07
     618:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     61a:	66 81       	ldd	r22, Z+6	; 0x06
     61c:	77 81       	ldd	r23, Z+7	; 0x07
     61e:	0e 94 ca 08 	call	0x1194	; 0x1194 <memcpy>
     622:	08 95       	ret

00000624 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
     624:	0f 93       	push	r16
     626:	1f 93       	push	r17
     628:	cf 93       	push	r28
     62a:	df 93       	push	r29
     62c:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     62e:	0f b6       	in	r0, 0x3f	; 63
     630:	f8 94       	cli
     632:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     634:	8e 8d       	ldd	r24, Y+30	; 0x1e
     636:	18 16       	cp	r1, r24
     638:	b4 f4       	brge	.+44     	; 0x666 <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     63a:	89 89       	ldd	r24, Y+17	; 0x11
     63c:	88 23       	and	r24, r24
     63e:	99 f0       	breq	.+38     	; 0x666 <prvUnlockQueue+0x42>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     640:	8e 01       	movw	r16, r28
     642:	0f 5e       	subi	r16, 0xEF	; 239
     644:	1f 4f       	sbci	r17, 0xFF	; 255
     646:	03 c0       	rjmp	.+6      	; 0x64e <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     648:	89 89       	ldd	r24, Y+17	; 0x11
     64a:	88 23       	and	r24, r24
     64c:	61 f0       	breq	.+24     	; 0x666 <prvUnlockQueue+0x42>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     64e:	c8 01       	movw	r24, r16
     650:	0e 94 17 08 	call	0x102e	; 0x102e <xTaskRemoveFromEventList>
     654:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
     656:	0e 94 a3 08 	call	0x1146	; 0x1146 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
     65a:	8e 8d       	ldd	r24, Y+30	; 0x1e
     65c:	81 50       	subi	r24, 0x01	; 1
     65e:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     660:	8e 8d       	ldd	r24, Y+30	; 0x1e
     662:	18 16       	cp	r1, r24
     664:	8c f3       	brlt	.-30     	; 0x648 <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
     666:	8f ef       	ldi	r24, 0xFF	; 255
     668:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     66a:	0f 90       	pop	r0
     66c:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     66e:	0f b6       	in	r0, 0x3f	; 63
     670:	f8 94       	cli
     672:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     674:	8d 8d       	ldd	r24, Y+29	; 0x1d
     676:	18 16       	cp	r1, r24
     678:	b4 f4       	brge	.+44     	; 0x6a6 <prvUnlockQueue+0x82>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     67a:	88 85       	ldd	r24, Y+8	; 0x08
     67c:	88 23       	and	r24, r24
     67e:	99 f0       	breq	.+38     	; 0x6a6 <prvUnlockQueue+0x82>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     680:	8e 01       	movw	r16, r28
     682:	08 5f       	subi	r16, 0xF8	; 248
     684:	1f 4f       	sbci	r17, 0xFF	; 255
     686:	03 c0       	rjmp	.+6      	; 0x68e <prvUnlockQueue+0x6a>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     688:	88 85       	ldd	r24, Y+8	; 0x08
     68a:	88 23       	and	r24, r24
     68c:	61 f0       	breq	.+24     	; 0x6a6 <prvUnlockQueue+0x82>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     68e:	c8 01       	movw	r24, r16
     690:	0e 94 17 08 	call	0x102e	; 0x102e <xTaskRemoveFromEventList>
     694:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
     696:	0e 94 a3 08 	call	0x1146	; 0x1146 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
     69a:	8d 8d       	ldd	r24, Y+29	; 0x1d
     69c:	81 50       	subi	r24, 0x01	; 1
     69e:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     6a0:	8d 8d       	ldd	r24, Y+29	; 0x1d
     6a2:	18 16       	cp	r1, r24
     6a4:	8c f3       	brlt	.-30     	; 0x688 <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     6a6:	8f ef       	ldi	r24, 0xFF	; 255
     6a8:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     6aa:	0f 90       	pop	r0
     6ac:	0f be       	out	0x3f, r0	; 63
}
     6ae:	df 91       	pop	r29
     6b0:	cf 91       	pop	r28
     6b2:	1f 91       	pop	r17
     6b4:	0f 91       	pop	r16
     6b6:	08 95       	ret

000006b8 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
     6b8:	cf 93       	push	r28
     6ba:	df 93       	push	r29
     6bc:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     6be:	0f b6       	in	r0, 0x3f	; 63
     6c0:	f8 94       	cli
     6c2:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     6c4:	88 81       	ld	r24, Y
     6c6:	99 81       	ldd	r25, Y+1	; 0x01
     6c8:	2c 8d       	ldd	r18, Y+28	; 0x1c
     6ca:	30 e0       	ldi	r19, 0x00	; 0
     6cc:	7b 8d       	ldd	r23, Y+27	; 0x1b
     6ce:	72 9f       	mul	r23, r18
     6d0:	a0 01       	movw	r20, r0
     6d2:	73 9f       	mul	r23, r19
     6d4:	50 0d       	add	r21, r0
     6d6:	11 24       	eor	r1, r1
     6d8:	fc 01       	movw	r30, r24
     6da:	e4 0f       	add	r30, r20
     6dc:	f5 1f       	adc	r31, r21
     6de:	fb 83       	std	Y+3, r31	; 0x03
     6e0:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     6e2:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     6e4:	9d 83       	std	Y+5, r25	; 0x05
     6e6:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
     6e8:	42 1b       	sub	r20, r18
     6ea:	53 0b       	sbc	r21, r19
     6ec:	84 0f       	add	r24, r20
     6ee:	95 1f       	adc	r25, r21
     6f0:	9f 83       	std	Y+7, r25	; 0x07
     6f2:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
     6f4:	8f ef       	ldi	r24, 0xFF	; 255
     6f6:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
     6f8:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     6fa:	61 11       	cpse	r22, r1
     6fc:	0c c0       	rjmp	.+24     	; 0x716 <xQueueGenericReset+0x5e>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     6fe:	88 85       	ldd	r24, Y+8	; 0x08
     700:	88 23       	and	r24, r24
     702:	89 f0       	breq	.+34     	; 0x726 <xQueueGenericReset+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     704:	ce 01       	movw	r24, r28
     706:	08 96       	adiw	r24, 0x08	; 8
     708:	0e 94 17 08 	call	0x102e	; 0x102e <xTaskRemoveFromEventList>
     70c:	81 30       	cpi	r24, 0x01	; 1
     70e:	59 f4       	brne	.+22     	; 0x726 <xQueueGenericReset+0x6e>
				{
					queueYIELD_IF_USING_PREEMPTION();
     710:	0e 94 0a 02 	call	0x414	; 0x414 <vPortYield>
     714:	08 c0       	rjmp	.+16     	; 0x726 <xQueueGenericReset+0x6e>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     716:	ce 01       	movw	r24, r28
     718:	08 96       	adiw	r24, 0x08	; 8
     71a:	0e 94 da 00 	call	0x1b4	; 0x1b4 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     71e:	ce 01       	movw	r24, r28
     720:	41 96       	adiw	r24, 0x11	; 17
     722:	0e 94 da 00 	call	0x1b4	; 0x1b4 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
     726:	0f 90       	pop	r0
     728:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
     72a:	81 e0       	ldi	r24, 0x01	; 1
     72c:	df 91       	pop	r29
     72e:	cf 91       	pop	r28
     730:	08 95       	ret

00000732 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
     732:	0f 93       	push	r16
     734:	1f 93       	push	r17
     736:	cf 93       	push	r28
     738:	df 93       	push	r29
     73a:	08 2f       	mov	r16, r24
     73c:	16 2f       	mov	r17, r22
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

	if( uxItemSize == ( UBaseType_t ) 0 )
     73e:	66 23       	and	r22, r22
     740:	c9 f0       	breq	.+50     	; 0x774 <xQueueGenericCreate+0x42>
	}
	else
	{
		/* The queue is one byte longer than asked for to make wrap checking
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     742:	86 9f       	mul	r24, r22
     744:	c0 01       	movw	r24, r0
     746:	11 24       	eor	r1, r1
	}

	/* Allocate the new queue structure and storage area. */
	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     748:	80 96       	adiw	r24, 0x20	; 32
     74a:	0e 94 c2 02 	call	0x584	; 0x584 <pvPortMalloc>
     74e:	ec 01       	movw	r28, r24

	if( pxNewQueue != NULL )
     750:	00 97       	sbiw	r24, 0x00	; 0
     752:	21 f4       	brne	.+8      	; 0x75c <xQueueGenericCreate+0x2a>
     754:	16 c0       	rjmp	.+44     	; 0x782 <xQueueGenericCreate+0x50>
		{
			/* No RAM was allocated for the queue storage area, but PC head
			cannot be set to NULL because NULL is used as a key to say the queue
			is used as a mutex.  Therefore just set pcHead to point to the queue
			as a benign value that is known to be within the memory map. */
			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
     756:	d9 83       	std	Y+1, r29	; 0x01
     758:	c8 83       	st	Y, r28
     75a:	05 c0       	rjmp	.+10     	; 0x766 <xQueueGenericCreate+0x34>
		}
		else
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pxNewQueue->pcHead = ( ( int8_t * ) pxNewQueue ) + sizeof( Queue_t );
     75c:	9c 01       	movw	r18, r24
     75e:	21 5e       	subi	r18, 0xE1	; 225
     760:	3f 4f       	sbci	r19, 0xFF	; 255
     762:	39 83       	std	Y+1, r19	; 0x01
     764:	28 83       	st	Y, r18
		}

		/* Initialise the queue members as described above where the queue type
		is defined. */
		pxNewQueue->uxLength = uxQueueLength;
     766:	0b 8f       	std	Y+27, r16	; 0x1b
		pxNewQueue->uxItemSize = uxItemSize;
     768:	1c 8f       	std	Y+28, r17	; 0x1c
		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
     76a:	61 e0       	ldi	r22, 0x01	; 1
     76c:	ce 01       	movw	r24, r28
     76e:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <xQueueGenericReset>
     772:	07 c0       	rjmp	.+14     	; 0x782 <xQueueGenericCreate+0x50>
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
	}

	/* Allocate the new queue structure and storage area. */
	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     774:	8f e1       	ldi	r24, 0x1F	; 31
     776:	90 e0       	ldi	r25, 0x00	; 0
     778:	0e 94 c2 02 	call	0x584	; 0x584 <pvPortMalloc>
     77c:	ec 01       	movw	r28, r24

	if( pxNewQueue != NULL )
     77e:	00 97       	sbiw	r24, 0x00	; 0
     780:	51 f7       	brne	.-44     	; 0x756 <xQueueGenericCreate+0x24>
	}

	configASSERT( xReturn );

	return xReturn;
}
     782:	ce 01       	movw	r24, r28
     784:	df 91       	pop	r29
     786:	cf 91       	pop	r28
     788:	1f 91       	pop	r17
     78a:	0f 91       	pop	r16
     78c:	08 95       	ret

0000078e <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     78e:	9f 92       	push	r9
     790:	af 92       	push	r10
     792:	bf 92       	push	r11
     794:	cf 92       	push	r12
     796:	df 92       	push	r13
     798:	ef 92       	push	r14
     79a:	ff 92       	push	r15
     79c:	0f 93       	push	r16
     79e:	1f 93       	push	r17
     7a0:	cf 93       	push	r28
     7a2:	df 93       	push	r29
     7a4:	00 d0       	rcall	.+0      	; 0x7a6 <xQueueGenericReceive+0x18>
     7a6:	00 d0       	rcall	.+0      	; 0x7a8 <xQueueGenericReceive+0x1a>
     7a8:	1f 92       	push	r1
     7aa:	cd b7       	in	r28, 0x3d	; 61
     7ac:	de b7       	in	r29, 0x3e	; 62
     7ae:	8c 01       	movw	r16, r24
     7b0:	6b 01       	movw	r12, r22
     7b2:	5d 83       	std	Y+5, r21	; 0x05
     7b4:	4c 83       	std	Y+4, r20	; 0x04
     7b6:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
     7b8:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     7ba:	99 24       	eor	r9, r9
     7bc:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     7be:	7c 01       	movw	r14, r24
     7c0:	81 e1       	ldi	r24, 0x11	; 17
     7c2:	e8 0e       	add	r14, r24
     7c4:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     7c6:	0f b6       	in	r0, 0x3f	; 63
     7c8:	f8 94       	cli
     7ca:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     7cc:	f8 01       	movw	r30, r16
     7ce:	82 8d       	ldd	r24, Z+26	; 0x1a
     7d0:	88 23       	and	r24, r24
     7d2:	49 f1       	breq	.+82     	; 0x826 <xQueueGenericReceive+0x98>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     7d4:	e6 80       	ldd	r14, Z+6	; 0x06
     7d6:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     7d8:	b6 01       	movw	r22, r12
     7da:	c8 01       	movw	r24, r16
     7dc:	0e 94 f8 02 	call	0x5f0	; 0x5f0 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     7e0:	b1 10       	cpse	r11, r1
     7e2:	10 c0       	rjmp	.+32     	; 0x804 <xQueueGenericReceive+0x76>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
     7e4:	f8 01       	movw	r30, r16
     7e6:	82 8d       	ldd	r24, Z+26	; 0x1a
     7e8:	81 50       	subi	r24, 0x01	; 1
     7ea:	82 8f       	std	Z+26, r24	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     7ec:	80 85       	ldd	r24, Z+8	; 0x08
     7ee:	88 23       	and	r24, r24
     7f0:	b1 f0       	breq	.+44     	; 0x81e <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     7f2:	c8 01       	movw	r24, r16
     7f4:	08 96       	adiw	r24, 0x08	; 8
     7f6:	0e 94 17 08 	call	0x102e	; 0x102e <xTaskRemoveFromEventList>
     7fa:	81 30       	cpi	r24, 0x01	; 1
     7fc:	81 f4       	brne	.+32     	; 0x81e <xQueueGenericReceive+0x90>
						{
							queueYIELD_IF_USING_PREEMPTION();
     7fe:	0e 94 0a 02 	call	0x414	; 0x414 <vPortYield>
     802:	0d c0       	rjmp	.+26     	; 0x81e <xQueueGenericReceive+0x90>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     804:	f8 01       	movw	r30, r16
     806:	f7 82       	std	Z+7, r15	; 0x07
     808:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     80a:	81 89       	ldd	r24, Z+17	; 0x11
     80c:	88 23       	and	r24, r24
     80e:	39 f0       	breq	.+14     	; 0x81e <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     810:	c8 01       	movw	r24, r16
     812:	41 96       	adiw	r24, 0x11	; 17
     814:	0e 94 17 08 	call	0x102e	; 0x102e <xTaskRemoveFromEventList>
     818:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     81a:	0e 94 0a 02 	call	0x414	; 0x414 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     81e:	0f 90       	pop	r0
     820:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     822:	81 e0       	ldi	r24, 0x01	; 1
     824:	4f c0       	rjmp	.+158    	; 0x8c4 <xQueueGenericReceive+0x136>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     826:	4c 81       	ldd	r20, Y+4	; 0x04
     828:	5d 81       	ldd	r21, Y+5	; 0x05
     82a:	45 2b       	or	r20, r21
     82c:	21 f4       	brne	.+8      	; 0x836 <xQueueGenericReceive+0xa8>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     82e:	0f 90       	pop	r0
     830:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     832:	80 e0       	ldi	r24, 0x00	; 0
     834:	47 c0       	rjmp	.+142    	; 0x8c4 <xQueueGenericReceive+0x136>
				}
				else if( xEntryTimeSet == pdFALSE )
     836:	a1 10       	cpse	r10, r1
     838:	05 c0       	rjmp	.+10     	; 0x844 <xQueueGenericReceive+0xb6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     83a:	ce 01       	movw	r24, r28
     83c:	01 96       	adiw	r24, 0x01	; 1
     83e:	0e 94 5f 08 	call	0x10be	; 0x10be <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     842:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     844:	0f 90       	pop	r0
     846:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     848:	0e 94 09 06 	call	0xc12	; 0xc12 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     84c:	0f b6       	in	r0, 0x3f	; 63
     84e:	f8 94       	cli
     850:	0f 92       	push	r0
     852:	f8 01       	movw	r30, r16
     854:	85 8d       	ldd	r24, Z+29	; 0x1d
     856:	8f 3f       	cpi	r24, 0xFF	; 255
     858:	09 f4       	brne	.+2      	; 0x85c <xQueueGenericReceive+0xce>
     85a:	15 8e       	std	Z+29, r1	; 0x1d
     85c:	f8 01       	movw	r30, r16
     85e:	86 8d       	ldd	r24, Z+30	; 0x1e
     860:	8f 3f       	cpi	r24, 0xFF	; 255
     862:	09 f4       	brne	.+2      	; 0x866 <xQueueGenericReceive+0xd8>
     864:	16 8e       	std	Z+30, r1	; 0x1e
     866:	0f 90       	pop	r0
     868:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     86a:	be 01       	movw	r22, r28
     86c:	6c 5f       	subi	r22, 0xFC	; 252
     86e:	7f 4f       	sbci	r23, 0xFF	; 255
     870:	ce 01       	movw	r24, r28
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	0e 94 6a 08 	call	0x10d4	; 0x10d4 <xTaskCheckForTimeOut>
     878:	81 11       	cpse	r24, r1
     87a:	1e c0       	rjmp	.+60     	; 0x8b8 <xQueueGenericReceive+0x12a>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     87c:	0f b6       	in	r0, 0x3f	; 63
     87e:	f8 94       	cli
     880:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     882:	f8 01       	movw	r30, r16
     884:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     886:	0f 90       	pop	r0
     888:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     88a:	81 11       	cpse	r24, r1
     88c:	0f c0       	rjmp	.+30     	; 0x8ac <xQueueGenericReceive+0x11e>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     88e:	6c 81       	ldd	r22, Y+4	; 0x04
     890:	7d 81       	ldd	r23, Y+5	; 0x05
     892:	c7 01       	movw	r24, r14
     894:	0e 94 eb 07 	call	0xfd6	; 0xfd6 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     898:	c8 01       	movw	r24, r16
     89a:	0e 94 12 03 	call	0x624	; 0x624 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     89e:	0e 94 ce 06 	call	0xd9c	; 0xd9c <xTaskResumeAll>
     8a2:	81 11       	cpse	r24, r1
     8a4:	90 cf       	rjmp	.-224    	; 0x7c6 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
     8a6:	0e 94 0a 02 	call	0x414	; 0x414 <vPortYield>
     8aa:	8d cf       	rjmp	.-230    	; 0x7c6 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     8ac:	c8 01       	movw	r24, r16
     8ae:	0e 94 12 03 	call	0x624	; 0x624 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     8b2:	0e 94 ce 06 	call	0xd9c	; 0xd9c <xTaskResumeAll>
     8b6:	87 cf       	rjmp	.-242    	; 0x7c6 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     8b8:	c8 01       	movw	r24, r16
     8ba:	0e 94 12 03 	call	0x624	; 0x624 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     8be:	0e 94 ce 06 	call	0xd9c	; 0xd9c <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
     8c2:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     8c4:	0f 90       	pop	r0
     8c6:	0f 90       	pop	r0
     8c8:	0f 90       	pop	r0
     8ca:	0f 90       	pop	r0
     8cc:	0f 90       	pop	r0
     8ce:	df 91       	pop	r29
     8d0:	cf 91       	pop	r28
     8d2:	1f 91       	pop	r17
     8d4:	0f 91       	pop	r16
     8d6:	ff 90       	pop	r15
     8d8:	ef 90       	pop	r14
     8da:	df 90       	pop	r13
     8dc:	cf 90       	pop	r12
     8de:	bf 90       	pop	r11
     8e0:	af 90       	pop	r10
     8e2:	9f 90       	pop	r9
     8e4:	08 95       	ret

000008e6 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     8e6:	e0 91 5e 05 	lds	r30, 0x055E
     8ea:	f0 91 5f 05 	lds	r31, 0x055F
     8ee:	80 81       	ld	r24, Z
     8f0:	81 11       	cpse	r24, r1
     8f2:	07 c0       	rjmp	.+14     	; 0x902 <__stack+0x3>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     8f4:	8f ef       	ldi	r24, 0xFF	; 255
     8f6:	9f ef       	ldi	r25, 0xFF	; 255
     8f8:	90 93 36 05 	sts	0x0536, r25
     8fc:	80 93 35 05 	sts	0x0535, r24
     900:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     902:	e0 91 5e 05 	lds	r30, 0x055E
     906:	f0 91 5f 05 	lds	r31, 0x055F
     90a:	05 80       	ldd	r0, Z+5	; 0x05
     90c:	f6 81       	ldd	r31, Z+6	; 0x06
     90e:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
     910:	06 80       	ldd	r0, Z+6	; 0x06
     912:	f7 81       	ldd	r31, Z+7	; 0x07
     914:	e0 2d       	mov	r30, r0
     916:	82 81       	ldd	r24, Z+2	; 0x02
     918:	93 81       	ldd	r25, Z+3	; 0x03
     91a:	90 93 36 05 	sts	0x0536, r25
     91e:	80 93 35 05 	sts	0x0535, r24
     922:	08 95       	ret

00000924 <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
     924:	cf 93       	push	r28
     926:	df 93       	push	r29
     928:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
     92a:	e0 91 96 05 	lds	r30, 0x0596
     92e:	f0 91 97 05 	lds	r31, 0x0597
     932:	93 83       	std	Z+3, r25	; 0x03
     934:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
     936:	80 91 3d 05 	lds	r24, 0x053D
     93a:	90 91 3e 05 	lds	r25, 0x053E
     93e:	c8 17       	cp	r28, r24
     940:	d9 07       	cpc	r29, r25
     942:	68 f4       	brcc	.+26     	; 0x95e <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     944:	60 91 96 05 	lds	r22, 0x0596
     948:	70 91 97 05 	lds	r23, 0x0597
     94c:	80 91 5c 05 	lds	r24, 0x055C
     950:	90 91 5d 05 	lds	r25, 0x055D
     954:	6e 5f       	subi	r22, 0xFE	; 254
     956:	7f 4f       	sbci	r23, 0xFF	; 255
     958:	0e 94 0d 01 	call	0x21a	; 0x21a <vListInsert>
     95c:	17 c0       	rjmp	.+46     	; 0x98c <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     95e:	60 91 96 05 	lds	r22, 0x0596
     962:	70 91 97 05 	lds	r23, 0x0597
     966:	80 91 5e 05 	lds	r24, 0x055E
     96a:	90 91 5f 05 	lds	r25, 0x055F
     96e:	6e 5f       	subi	r22, 0xFE	; 254
     970:	7f 4f       	sbci	r23, 0xFF	; 255
     972:	0e 94 0d 01 	call	0x21a	; 0x21a <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
     976:	80 91 35 05 	lds	r24, 0x0535
     97a:	90 91 36 05 	lds	r25, 0x0536
     97e:	c8 17       	cp	r28, r24
     980:	d9 07       	cpc	r29, r25
     982:	20 f4       	brcc	.+8      	; 0x98c <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
     984:	d0 93 36 05 	sts	0x0536, r29
     988:	c0 93 35 05 	sts	0x0535, r28
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     98c:	df 91       	pop	r29
     98e:	cf 91       	pop	r28
     990:	08 95       	ret

00000992 <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
     992:	4f 92       	push	r4
     994:	5f 92       	push	r5
     996:	6f 92       	push	r6
     998:	7f 92       	push	r7
     99a:	8f 92       	push	r8
     99c:	9f 92       	push	r9
     99e:	af 92       	push	r10
     9a0:	bf 92       	push	r11
     9a2:	cf 92       	push	r12
     9a4:	df 92       	push	r13
     9a6:	ef 92       	push	r14
     9a8:	ff 92       	push	r15
     9aa:	0f 93       	push	r16
     9ac:	1f 93       	push	r17
     9ae:	cf 93       	push	r28
     9b0:	df 93       	push	r29
     9b2:	4c 01       	movw	r8, r24
     9b4:	5b 01       	movw	r10, r22
     9b6:	2a 01       	movw	r4, r20
     9b8:	39 01       	movw	r6, r18
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     9ba:	c1 14       	cp	r12, r1
     9bc:	d1 04       	cpc	r13, r1
     9be:	39 f4       	brne	.+14     	; 0x9ce <xTaskGenericCreate+0x3c>
     9c0:	ca 01       	movw	r24, r20
     9c2:	0e 94 c2 02 	call	0x584	; 0x584 <pvPortMalloc>
     9c6:	6c 01       	movw	r12, r24

		if( pxStack != NULL )
     9c8:	00 97       	sbiw	r24, 0x00	; 0
     9ca:	09 f4       	brne	.+2      	; 0x9ce <xTaskGenericCreate+0x3c>
     9cc:	de c0       	rjmp	.+444    	; 0xb8a <xTaskGenericCreate+0x1f8>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
     9ce:	86 e2       	ldi	r24, 0x26	; 38
     9d0:	90 e0       	ldi	r25, 0x00	; 0
     9d2:	0e 94 c2 02 	call	0x584	; 0x584 <pvPortMalloc>
     9d6:	ec 01       	movw	r28, r24

			if( pxNewTCB != NULL )
     9d8:	00 97       	sbiw	r24, 0x00	; 0
     9da:	71 f0       	breq	.+28     	; 0x9f8 <xTaskGenericCreate+0x66>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
     9dc:	d8 8e       	std	Y+24, r13	; 0x18
     9de:	cf 8a       	std	Y+23, r12	; 0x17
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
     9e0:	81 e0       	ldi	r24, 0x01	; 1
     9e2:	48 1a       	sub	r4, r24
     9e4:	51 08       	sbc	r5, r1
     9e6:	c4 0c       	add	r12, r4
     9e8:	d5 1c       	adc	r13, r5
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
     9ea:	d5 01       	movw	r26, r10
     9ec:	8c 91       	ld	r24, X
     9ee:	89 8f       	std	Y+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     9f0:	8c 91       	ld	r24, X
     9f2:	81 11       	cpse	r24, r1
     9f4:	05 c0       	rjmp	.+10     	; 0xa00 <xTaskGenericCreate+0x6e>
     9f6:	15 c0       	rjmp	.+42     	; 0xa22 <xTaskGenericCreate+0x90>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
     9f8:	c6 01       	movw	r24, r12
     9fa:	0e 94 f7 02 	call	0x5ee	; 0x5ee <vPortFree>
     9fe:	c5 c0       	rjmp	.+394    	; 0xb8a <xTaskGenericCreate+0x1f8>
     a00:	ae 01       	movw	r20, r28
     a02:	46 5e       	subi	r20, 0xE6	; 230
     a04:	5f 4f       	sbci	r21, 0xFF	; 255
     a06:	f5 01       	movw	r30, r10
     a08:	31 96       	adiw	r30, 0x01	; 1
		pxTCB->pcTaskName[ x ] = pcName[ x ];

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     a0a:	27 e0       	ldi	r18, 0x07	; 7
     a0c:	cf 01       	movw	r24, r30
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
     a0e:	31 91       	ld	r19, Z+
     a10:	da 01       	movw	r26, r20
     a12:	3d 93       	st	X+, r19
     a14:	ad 01       	movw	r20, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     a16:	dc 01       	movw	r26, r24
     a18:	8c 91       	ld	r24, X
     a1a:	88 23       	and	r24, r24
     a1c:	11 f0       	breq	.+4      	; 0xa22 <xTaskGenericCreate+0x90>
     a1e:	21 50       	subi	r18, 0x01	; 1
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     a20:	a9 f7       	brne	.-22     	; 0xa0c <xTaskGenericCreate+0x7a>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     a22:	18 a2       	std	Y+32, r1	; 0x20
     a24:	10 2f       	mov	r17, r16
     a26:	04 30       	cpi	r16, 0x04	; 4
     a28:	08 f0       	brcs	.+2      	; 0xa2c <xTaskGenericCreate+0x9a>
     a2a:	13 e0       	ldi	r17, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
     a2c:	1e 8b       	std	Y+22, r17	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
     a2e:	5e 01       	movw	r10, r28
     a30:	b2 e0       	ldi	r27, 0x02	; 2
     a32:	ab 0e       	add	r10, r27
     a34:	b1 1c       	adc	r11, r1
     a36:	c5 01       	movw	r24, r10
     a38:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
     a3c:	ce 01       	movw	r24, r28
     a3e:	0c 96       	adiw	r24, 0x0c	; 12
     a40:	0e 94 e8 00 	call	0x1d0	; 0x1d0 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
     a44:	d9 87       	std	Y+9, r29	; 0x09
     a46:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     a48:	84 e0       	ldi	r24, 0x04	; 4
     a4a:	90 e0       	ldi	r25, 0x00	; 0
     a4c:	81 1b       	sub	r24, r17
     a4e:	91 09       	sbc	r25, r1
     a50:	9d 87       	std	Y+13, r25	; 0x0d
     a52:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
     a54:	db 8b       	std	Y+19, r29	; 0x13
     a56:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
     a58:	19 a2       	std	Y+33, r1	; 0x21
     a5a:	1a a2       	std	Y+34, r1	; 0x22
     a5c:	1b a2       	std	Y+35, r1	; 0x23
     a5e:	1c a2       	std	Y+36, r1	; 0x24
		pxTCB->eNotifyState = eNotWaitingNotification;
     a60:	1d a2       	std	Y+37, r1	; 0x25
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     a62:	a3 01       	movw	r20, r6
     a64:	b4 01       	movw	r22, r8
     a66:	c6 01       	movw	r24, r12
     a68:	0e 94 64 01 	call	0x2c8	; 0x2c8 <pxPortInitialiseStack>
     a6c:	99 83       	std	Y+1, r25	; 0x01
     a6e:	88 83       	st	Y, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
     a70:	e1 14       	cp	r14, r1
     a72:	f1 04       	cpc	r15, r1
     a74:	19 f0       	breq	.+6      	; 0xa7c <xTaskGenericCreate+0xea>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     a76:	f7 01       	movw	r30, r14
     a78:	d1 83       	std	Z+1, r29	; 0x01
     a7a:	c0 83       	st	Z, r28
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
     a7c:	0f b6       	in	r0, 0x3f	; 63
     a7e:	f8 94       	cli
     a80:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
     a82:	80 91 3f 05 	lds	r24, 0x053F
     a86:	8f 5f       	subi	r24, 0xFF	; 255
     a88:	80 93 3f 05 	sts	0x053F, r24
			if( pxCurrentTCB == NULL )
     a8c:	80 91 96 05 	lds	r24, 0x0596
     a90:	90 91 97 05 	lds	r25, 0x0597
     a94:	89 2b       	or	r24, r25
     a96:	d1 f5       	brne	.+116    	; 0xb0c <xTaskGenericCreate+0x17a>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
     a98:	d0 93 97 05 	sts	0x0597, r29
     a9c:	c0 93 96 05 	sts	0x0596, r28

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     aa0:	80 91 3f 05 	lds	r24, 0x053F
     aa4:	81 30       	cpi	r24, 0x01	; 1
     aa6:	09 f0       	breq	.+2      	; 0xaaa <xTaskGenericCreate+0x118>
     aa8:	40 c0       	rjmp	.+128    	; 0xb2a <xTaskGenericCreate+0x198>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     aaa:	82 e7       	ldi	r24, 0x72	; 114
     aac:	95 e0       	ldi	r25, 0x05	; 5
     aae:	0e 94 da 00 	call	0x1b4	; 0x1b4 <vListInitialise>
     ab2:	8b e7       	ldi	r24, 0x7B	; 123
     ab4:	95 e0       	ldi	r25, 0x05	; 5
     ab6:	0e 94 da 00 	call	0x1b4	; 0x1b4 <vListInitialise>
     aba:	84 e8       	ldi	r24, 0x84	; 132
     abc:	95 e0       	ldi	r25, 0x05	; 5
     abe:	0e 94 da 00 	call	0x1b4	; 0x1b4 <vListInitialise>
     ac2:	8d e8       	ldi	r24, 0x8D	; 141
     ac4:	95 e0       	ldi	r25, 0x05	; 5
     ac6:	0e 94 da 00 	call	0x1b4	; 0x1b4 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     aca:	89 e6       	ldi	r24, 0x69	; 105
     acc:	95 e0       	ldi	r25, 0x05	; 5
     ace:	0e 94 da 00 	call	0x1b4	; 0x1b4 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     ad2:	80 e6       	ldi	r24, 0x60	; 96
     ad4:	95 e0       	ldi	r25, 0x05	; 5
     ad6:	0e 94 da 00 	call	0x1b4	; 0x1b4 <vListInitialise>
	vListInitialise( &xPendingReadyList );
     ada:	83 e5       	ldi	r24, 0x53	; 83
     adc:	95 e0       	ldi	r25, 0x05	; 5
     ade:	0e 94 da 00 	call	0x1b4	; 0x1b4 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     ae2:	8a e4       	ldi	r24, 0x4A	; 74
     ae4:	95 e0       	ldi	r25, 0x05	; 5
     ae6:	0e 94 da 00 	call	0x1b4	; 0x1b4 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
     aea:	80 e4       	ldi	r24, 0x40	; 64
     aec:	95 e0       	ldi	r25, 0x05	; 5
     aee:	0e 94 da 00 	call	0x1b4	; 0x1b4 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     af2:	89 e6       	ldi	r24, 0x69	; 105
     af4:	95 e0       	ldi	r25, 0x05	; 5
     af6:	90 93 5f 05 	sts	0x055F, r25
     afa:	80 93 5e 05 	sts	0x055E, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     afe:	80 e6       	ldi	r24, 0x60	; 96
     b00:	95 e0       	ldi	r25, 0x05	; 5
     b02:	90 93 5d 05 	sts	0x055D, r25
     b06:	80 93 5c 05 	sts	0x055C, r24
     b0a:	0f c0       	rjmp	.+30     	; 0xb2a <xTaskGenericCreate+0x198>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
     b0c:	80 91 3b 05 	lds	r24, 0x053B
     b10:	81 11       	cpse	r24, r1
     b12:	0b c0       	rjmp	.+22     	; 0xb2a <xTaskGenericCreate+0x198>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
     b14:	e0 91 96 05 	lds	r30, 0x0596
     b18:	f0 91 97 05 	lds	r31, 0x0597
     b1c:	86 89       	ldd	r24, Z+22	; 0x16
     b1e:	08 17       	cp	r16, r24
     b20:	20 f0       	brcs	.+8      	; 0xb2a <xTaskGenericCreate+0x198>
					{
						pxCurrentTCB = pxNewTCB;
     b22:	d0 93 97 05 	sts	0x0597, r29
     b26:	c0 93 96 05 	sts	0x0596, r28
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
     b2a:	80 91 37 05 	lds	r24, 0x0537
     b2e:	8f 5f       	subi	r24, 0xFF	; 255
     b30:	80 93 37 05 	sts	0x0537, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
     b34:	8e 89       	ldd	r24, Y+22	; 0x16
     b36:	90 91 3c 05 	lds	r25, 0x053C
     b3a:	98 17       	cp	r25, r24
     b3c:	10 f4       	brcc	.+4      	; 0xb42 <xTaskGenericCreate+0x1b0>
     b3e:	80 93 3c 05 	sts	0x053C, r24
     b42:	90 e0       	ldi	r25, 0x00	; 0
     b44:	9c 01       	movw	r18, r24
     b46:	22 0f       	add	r18, r18
     b48:	33 1f       	adc	r19, r19
     b4a:	22 0f       	add	r18, r18
     b4c:	33 1f       	adc	r19, r19
     b4e:	22 0f       	add	r18, r18
     b50:	33 1f       	adc	r19, r19
     b52:	82 0f       	add	r24, r18
     b54:	93 1f       	adc	r25, r19
     b56:	b5 01       	movw	r22, r10
     b58:	8e 58       	subi	r24, 0x8E	; 142
     b5a:	9a 4f       	sbci	r25, 0xFA	; 250
     b5c:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
     b60:	0f 90       	pop	r0
     b62:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
     b64:	80 91 3b 05 	lds	r24, 0x053B
     b68:	88 23       	and	r24, r24
     b6a:	59 f0       	breq	.+22     	; 0xb82 <xTaskGenericCreate+0x1f0>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
     b6c:	e0 91 96 05 	lds	r30, 0x0596
     b70:	f0 91 97 05 	lds	r31, 0x0597
     b74:	86 89       	ldd	r24, Z+22	; 0x16
     b76:	80 17       	cp	r24, r16
     b78:	30 f4       	brcc	.+12     	; 0xb86 <xTaskGenericCreate+0x1f4>
			{
				taskYIELD_IF_USING_PREEMPTION();
     b7a:	0e 94 0a 02 	call	0x414	; 0x414 <vPortYield>
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );

			xReturn = pdPASS;
     b7e:	81 e0       	ldi	r24, 0x01	; 1
     b80:	05 c0       	rjmp	.+10     	; 0xb8c <xTaskGenericCreate+0x1fa>
     b82:	81 e0       	ldi	r24, 0x01	; 1
     b84:	03 c0       	rjmp	.+6      	; 0xb8c <xTaskGenericCreate+0x1fa>
     b86:	81 e0       	ldi	r24, 0x01	; 1
     b88:	01 c0       	rjmp	.+2      	; 0xb8c <xTaskGenericCreate+0x1fa>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     b8a:	8f ef       	ldi	r24, 0xFF	; 255
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
     b8c:	df 91       	pop	r29
     b8e:	cf 91       	pop	r28
     b90:	1f 91       	pop	r17
     b92:	0f 91       	pop	r16
     b94:	ff 90       	pop	r15
     b96:	ef 90       	pop	r14
     b98:	df 90       	pop	r13
     b9a:	cf 90       	pop	r12
     b9c:	bf 90       	pop	r11
     b9e:	af 90       	pop	r10
     ba0:	9f 90       	pop	r9
     ba2:	8f 90       	pop	r8
     ba4:	7f 90       	pop	r7
     ba6:	6f 90       	pop	r6
     ba8:	5f 90       	pop	r5
     baa:	4f 90       	pop	r4
     bac:	08 95       	ret

00000bae <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     bae:	af 92       	push	r10
     bb0:	bf 92       	push	r11
     bb2:	cf 92       	push	r12
     bb4:	df 92       	push	r13
     bb6:	ef 92       	push	r14
     bb8:	ff 92       	push	r15
     bba:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
     bbc:	a1 2c       	mov	r10, r1
     bbe:	b1 2c       	mov	r11, r1
     bc0:	c1 2c       	mov	r12, r1
     bc2:	d1 2c       	mov	r13, r1
     bc4:	e1 2c       	mov	r14, r1
     bc6:	f1 2c       	mov	r15, r1
     bc8:	00 e0       	ldi	r16, 0x00	; 0
     bca:	20 e0       	ldi	r18, 0x00	; 0
     bcc:	30 e0       	ldi	r19, 0x00	; 0
     bce:	45 e5       	ldi	r20, 0x55	; 85
     bd0:	50 e0       	ldi	r21, 0x00	; 0
     bd2:	62 e4       	ldi	r22, 0x42	; 66
     bd4:	71 e0       	ldi	r23, 0x01	; 1
     bd6:	81 e5       	ldi	r24, 0x51	; 81
     bd8:	97 e0       	ldi	r25, 0x07	; 7
     bda:	0e 94 c9 04 	call	0x992	; 0x992 <xTaskGenericCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     bde:	81 30       	cpi	r24, 0x01	; 1
     be0:	81 f4       	brne	.+32     	; 0xc02 <vTaskStartScheduler+0x54>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     be2:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
     be4:	8f ef       	ldi	r24, 0xFF	; 255
     be6:	9f ef       	ldi	r25, 0xFF	; 255
     be8:	90 93 36 05 	sts	0x0536, r25
     bec:	80 93 35 05 	sts	0x0535, r24
		xSchedulerRunning = pdTRUE;
     bf0:	81 e0       	ldi	r24, 0x01	; 1
     bf2:	80 93 3b 05 	sts	0x053B, r24
		xTickCount = ( TickType_t ) 0U;
     bf6:	10 92 3e 05 	sts	0x053E, r1
     bfa:	10 92 3d 05 	sts	0x053D, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     bfe:	0e 94 d0 01 	call	0x3a0	; 0x3a0 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
     c02:	0f 91       	pop	r16
     c04:	ff 90       	pop	r15
     c06:	ef 90       	pop	r14
     c08:	df 90       	pop	r13
     c0a:	cf 90       	pop	r12
     c0c:	bf 90       	pop	r11
     c0e:	af 90       	pop	r10
     c10:	08 95       	ret

00000c12 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     c12:	80 91 34 05 	lds	r24, 0x0534
     c16:	8f 5f       	subi	r24, 0xFF	; 255
     c18:	80 93 34 05 	sts	0x0534, r24
     c1c:	08 95       	ret

00000c1e <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     c1e:	cf 92       	push	r12
     c20:	df 92       	push	r13
     c22:	ef 92       	push	r14
     c24:	ff 92       	push	r15
     c26:	0f 93       	push	r16
     c28:	1f 93       	push	r17
     c2a:	cf 93       	push	r28
     c2c:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     c2e:	80 91 34 05 	lds	r24, 0x0534
     c32:	81 11       	cpse	r24, r1
     c34:	9a c0       	rjmp	.+308    	; 0xd6a <xTaskIncrementTick+0x14c>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
     c36:	80 91 3d 05 	lds	r24, 0x053D
     c3a:	90 91 3e 05 	lds	r25, 0x053E
     c3e:	01 96       	adiw	r24, 0x01	; 1
     c40:	90 93 3e 05 	sts	0x053E, r25
     c44:	80 93 3d 05 	sts	0x053D, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     c48:	e0 90 3d 05 	lds	r14, 0x053D
     c4c:	f0 90 3e 05 	lds	r15, 0x053E

			if( xConstTickCount == ( TickType_t ) 0U )
     c50:	e1 14       	cp	r14, r1
     c52:	f1 04       	cpc	r15, r1
     c54:	b9 f4       	brne	.+46     	; 0xc84 <xTaskIncrementTick+0x66>
			{
				taskSWITCH_DELAYED_LISTS();
     c56:	80 91 5e 05 	lds	r24, 0x055E
     c5a:	90 91 5f 05 	lds	r25, 0x055F
     c5e:	20 91 5c 05 	lds	r18, 0x055C
     c62:	30 91 5d 05 	lds	r19, 0x055D
     c66:	30 93 5f 05 	sts	0x055F, r19
     c6a:	20 93 5e 05 	sts	0x055E, r18
     c6e:	90 93 5d 05 	sts	0x055D, r25
     c72:	80 93 5c 05 	sts	0x055C, r24
     c76:	80 91 38 05 	lds	r24, 0x0538
     c7a:	8f 5f       	subi	r24, 0xFF	; 255
     c7c:	80 93 38 05 	sts	0x0538, r24
     c80:	0e 94 73 04 	call	0x8e6	; 0x8e6 <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
     c84:	80 91 35 05 	lds	r24, 0x0535
     c88:	90 91 36 05 	lds	r25, 0x0536
     c8c:	e8 16       	cp	r14, r24
     c8e:	f9 06       	cpc	r15, r25
     c90:	08 f4       	brcc	.+2      	; 0xc94 <xTaskIncrementTick+0x76>
     c92:	54 c0       	rjmp	.+168    	; 0xd3c <xTaskIncrementTick+0x11e>
     c94:	d1 2c       	mov	r13, r1
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
							{
								xSwitchRequired = pdTRUE;
     c96:	cc 24       	eor	r12, r12
     c98:	c3 94       	inc	r12
     c9a:	01 c0       	rjmp	.+2      	; 0xc9e <xTaskIncrementTick+0x80>
     c9c:	dc 2c       	mov	r13, r12
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     c9e:	e0 91 5e 05 	lds	r30, 0x055E
     ca2:	f0 91 5f 05 	lds	r31, 0x055F
     ca6:	80 81       	ld	r24, Z
     ca8:	81 11       	cpse	r24, r1
     caa:	07 c0       	rjmp	.+14     	; 0xcba <xTaskIncrementTick+0x9c>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
     cac:	8f ef       	ldi	r24, 0xFF	; 255
     cae:	9f ef       	ldi	r25, 0xFF	; 255
     cb0:	90 93 36 05 	sts	0x0536, r25
     cb4:	80 93 35 05 	sts	0x0535, r24
						break;
     cb8:	42 c0       	rjmp	.+132    	; 0xd3e <xTaskIncrementTick+0x120>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     cba:	e0 91 5e 05 	lds	r30, 0x055E
     cbe:	f0 91 5f 05 	lds	r31, 0x055F
     cc2:	05 80       	ldd	r0, Z+5	; 0x05
     cc4:	f6 81       	ldd	r31, Z+6	; 0x06
     cc6:	e0 2d       	mov	r30, r0
     cc8:	c6 81       	ldd	r28, Z+6	; 0x06
     cca:	d7 81       	ldd	r29, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
     ccc:	2a 81       	ldd	r18, Y+2	; 0x02
     cce:	3b 81       	ldd	r19, Y+3	; 0x03

						if( xConstTickCount < xItemValue )
     cd0:	e2 16       	cp	r14, r18
     cd2:	f3 06       	cpc	r15, r19
     cd4:	28 f4       	brcc	.+10     	; 0xce0 <xTaskIncrementTick+0xc2>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
     cd6:	30 93 36 05 	sts	0x0536, r19
     cda:	20 93 35 05 	sts	0x0535, r18
							break;
     cde:	2f c0       	rjmp	.+94     	; 0xd3e <xTaskIncrementTick+0x120>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     ce0:	8e 01       	movw	r16, r28
     ce2:	0e 5f       	subi	r16, 0xFE	; 254
     ce4:	1f 4f       	sbci	r17, 0xFF	; 255
     ce6:	c8 01       	movw	r24, r16
     ce8:	0e 94 3e 01 	call	0x27c	; 0x27c <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     cec:	8c 89       	ldd	r24, Y+20	; 0x14
     cee:	9d 89       	ldd	r25, Y+21	; 0x15
     cf0:	89 2b       	or	r24, r25
     cf2:	21 f0       	breq	.+8      	; 0xcfc <xTaskIncrementTick+0xde>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     cf4:	ce 01       	movw	r24, r28
     cf6:	0c 96       	adiw	r24, 0x0c	; 12
     cf8:	0e 94 3e 01 	call	0x27c	; 0x27c <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
     cfc:	2e 89       	ldd	r18, Y+22	; 0x16
     cfe:	80 91 3c 05 	lds	r24, 0x053C
     d02:	82 17       	cp	r24, r18
     d04:	10 f4       	brcc	.+4      	; 0xd0a <xTaskIncrementTick+0xec>
     d06:	20 93 3c 05 	sts	0x053C, r18
     d0a:	30 e0       	ldi	r19, 0x00	; 0
     d0c:	c9 01       	movw	r24, r18
     d0e:	88 0f       	add	r24, r24
     d10:	99 1f       	adc	r25, r25
     d12:	88 0f       	add	r24, r24
     d14:	99 1f       	adc	r25, r25
     d16:	88 0f       	add	r24, r24
     d18:	99 1f       	adc	r25, r25
     d1a:	82 0f       	add	r24, r18
     d1c:	93 1f       	adc	r25, r19
     d1e:	b8 01       	movw	r22, r16
     d20:	8e 58       	subi	r24, 0x8E	; 142
     d22:	9a 4f       	sbci	r25, 0xFA	; 250
     d24:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     d28:	e0 91 96 05 	lds	r30, 0x0596
     d2c:	f0 91 97 05 	lds	r31, 0x0597
     d30:	9e 89       	ldd	r25, Y+22	; 0x16
     d32:	86 89       	ldd	r24, Z+22	; 0x16
     d34:	98 17       	cp	r25, r24
     d36:	08 f0       	brcs	.+2      	; 0xd3a <xTaskIncrementTick+0x11c>
     d38:	b1 cf       	rjmp	.-158    	; 0xc9c <xTaskIncrementTick+0x7e>
     d3a:	b1 cf       	rjmp	.-158    	; 0xc9e <xTaskIncrementTick+0x80>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     d3c:	d1 2c       	mov	r13, r1
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     d3e:	e0 91 96 05 	lds	r30, 0x0596
     d42:	f0 91 97 05 	lds	r31, 0x0597
     d46:	86 89       	ldd	r24, Z+22	; 0x16
     d48:	90 e0       	ldi	r25, 0x00	; 0
     d4a:	fc 01       	movw	r30, r24
     d4c:	ee 0f       	add	r30, r30
     d4e:	ff 1f       	adc	r31, r31
     d50:	ee 0f       	add	r30, r30
     d52:	ff 1f       	adc	r31, r31
     d54:	ee 0f       	add	r30, r30
     d56:	ff 1f       	adc	r31, r31
     d58:	8e 0f       	add	r24, r30
     d5a:	9f 1f       	adc	r25, r31
     d5c:	fc 01       	movw	r30, r24
     d5e:	ee 58       	subi	r30, 0x8E	; 142
     d60:	fa 4f       	sbci	r31, 0xFA	; 250
     d62:	80 81       	ld	r24, Z
     d64:	82 30       	cpi	r24, 0x02	; 2
     d66:	40 f4       	brcc	.+16     	; 0xd78 <xTaskIncrementTick+0x15a>
     d68:	09 c0       	rjmp	.+18     	; 0xd7c <xTaskIncrementTick+0x15e>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     d6a:	80 91 3a 05 	lds	r24, 0x053A
     d6e:	8f 5f       	subi	r24, 0xFF	; 255
     d70:	80 93 3a 05 	sts	0x053A, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     d74:	d1 2c       	mov	r13, r1
     d76:	02 c0       	rjmp	.+4      	; 0xd7c <xTaskIncrementTick+0x15e>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
     d78:	dd 24       	eor	r13, r13
     d7a:	d3 94       	inc	r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     d7c:	80 91 39 05 	lds	r24, 0x0539
     d80:	88 23       	and	r24, r24
     d82:	11 f0       	breq	.+4      	; 0xd88 <xTaskIncrementTick+0x16a>
		{
			xSwitchRequired = pdTRUE;
     d84:	dd 24       	eor	r13, r13
     d86:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     d88:	8d 2d       	mov	r24, r13
     d8a:	df 91       	pop	r29
     d8c:	cf 91       	pop	r28
     d8e:	1f 91       	pop	r17
     d90:	0f 91       	pop	r16
     d92:	ff 90       	pop	r15
     d94:	ef 90       	pop	r14
     d96:	df 90       	pop	r13
     d98:	cf 90       	pop	r12
     d9a:	08 95       	ret

00000d9c <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     d9c:	df 92       	push	r13
     d9e:	ef 92       	push	r14
     da0:	ff 92       	push	r15
     da2:	0f 93       	push	r16
     da4:	1f 93       	push	r17
     da6:	cf 93       	push	r28
     da8:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     daa:	0f b6       	in	r0, 0x3f	; 63
     dac:	f8 94       	cli
     dae:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     db0:	80 91 34 05 	lds	r24, 0x0534
     db4:	81 50       	subi	r24, 0x01	; 1
     db6:	80 93 34 05 	sts	0x0534, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     dba:	80 91 34 05 	lds	r24, 0x0534
     dbe:	81 11       	cpse	r24, r1
     dc0:	61 c0       	rjmp	.+194    	; 0xe84 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     dc2:	80 91 3f 05 	lds	r24, 0x053F
     dc6:	88 23       	and	r24, r24
     dc8:	09 f4       	brne	.+2      	; 0xdcc <xTaskResumeAll+0x30>
     dca:	5e c0       	rjmp	.+188    	; 0xe88 <xTaskResumeAll+0xec>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     dcc:	0f 2e       	mov	r0, r31
     dce:	f3 e5       	ldi	r31, 0x53	; 83
     dd0:	ef 2e       	mov	r14, r31
     dd2:	f5 e0       	ldi	r31, 0x05	; 5
     dd4:	ff 2e       	mov	r15, r31
     dd6:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     dd8:	dd 24       	eor	r13, r13
     dda:	d3 94       	inc	r13
     ddc:	30 c0       	rjmp	.+96     	; 0xe3e <xTaskResumeAll+0xa2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     dde:	e0 91 58 05 	lds	r30, 0x0558
     de2:	f0 91 59 05 	lds	r31, 0x0559
     de6:	c6 81       	ldd	r28, Z+6	; 0x06
     de8:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     dea:	ce 01       	movw	r24, r28
     dec:	0c 96       	adiw	r24, 0x0c	; 12
     dee:	0e 94 3e 01 	call	0x27c	; 0x27c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     df2:	8e 01       	movw	r16, r28
     df4:	0e 5f       	subi	r16, 0xFE	; 254
     df6:	1f 4f       	sbci	r17, 0xFF	; 255
     df8:	c8 01       	movw	r24, r16
     dfa:	0e 94 3e 01 	call	0x27c	; 0x27c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     dfe:	8e 89       	ldd	r24, Y+22	; 0x16
     e00:	90 91 3c 05 	lds	r25, 0x053C
     e04:	98 17       	cp	r25, r24
     e06:	10 f4       	brcc	.+4      	; 0xe0c <xTaskResumeAll+0x70>
     e08:	80 93 3c 05 	sts	0x053C, r24
     e0c:	90 e0       	ldi	r25, 0x00	; 0
     e0e:	9c 01       	movw	r18, r24
     e10:	22 0f       	add	r18, r18
     e12:	33 1f       	adc	r19, r19
     e14:	22 0f       	add	r18, r18
     e16:	33 1f       	adc	r19, r19
     e18:	22 0f       	add	r18, r18
     e1a:	33 1f       	adc	r19, r19
     e1c:	82 0f       	add	r24, r18
     e1e:	93 1f       	adc	r25, r19
     e20:	b8 01       	movw	r22, r16
     e22:	8e 58       	subi	r24, 0x8E	; 142
     e24:	9a 4f       	sbci	r25, 0xFA	; 250
     e26:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     e2a:	e0 91 96 05 	lds	r30, 0x0596
     e2e:	f0 91 97 05 	lds	r31, 0x0597
     e32:	9e 89       	ldd	r25, Y+22	; 0x16
     e34:	86 89       	ldd	r24, Z+22	; 0x16
     e36:	98 17       	cp	r25, r24
     e38:	10 f0       	brcs	.+4      	; 0xe3e <xTaskResumeAll+0xa2>
					{
						xYieldPending = pdTRUE;
     e3a:	d0 92 39 05 	sts	0x0539, r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     e3e:	f7 01       	movw	r30, r14
     e40:	80 81       	ld	r24, Z
     e42:	81 11       	cpse	r24, r1
     e44:	cc cf       	rjmp	.-104    	; 0xdde <xTaskResumeAll+0x42>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
     e46:	80 91 3a 05 	lds	r24, 0x053A
     e4a:	88 23       	and	r24, r24
     e4c:	99 f0       	breq	.+38     	; 0xe74 <xTaskResumeAll+0xd8>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
     e4e:	80 91 3a 05 	lds	r24, 0x053A
     e52:	88 23       	and	r24, r24
     e54:	79 f0       	breq	.+30     	; 0xe74 <xTaskResumeAll+0xd8>
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
     e56:	c1 e0       	ldi	r28, 0x01	; 1
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
     e58:	0e 94 0f 06 	call	0xc1e	; 0xc1e <xTaskIncrementTick>
     e5c:	81 11       	cpse	r24, r1
						{
							xYieldPending = pdTRUE;
     e5e:	c0 93 39 05 	sts	0x0539, r28
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
     e62:	80 91 3a 05 	lds	r24, 0x053A
     e66:	81 50       	subi	r24, 0x01	; 1
     e68:	80 93 3a 05 	sts	0x053A, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
     e6c:	80 91 3a 05 	lds	r24, 0x053A
     e70:	81 11       	cpse	r24, r1
     e72:	f2 cf       	rjmp	.-28     	; 0xe58 <xTaskResumeAll+0xbc>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
     e74:	80 91 39 05 	lds	r24, 0x0539
     e78:	81 30       	cpi	r24, 0x01	; 1
     e7a:	41 f4       	brne	.+16     	; 0xe8c <xTaskResumeAll+0xf0>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     e7c:	0e 94 0a 02 	call	0x414	; 0x414 <vPortYield>

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     e80:	81 e0       	ldi	r24, 0x01	; 1
     e82:	05 c0       	rjmp	.+10     	; 0xe8e <xTaskResumeAll+0xf2>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
     e84:	80 e0       	ldi	r24, 0x00	; 0
     e86:	03 c0       	rjmp	.+6      	; 0xe8e <xTaskResumeAll+0xf2>
     e88:	80 e0       	ldi	r24, 0x00	; 0
     e8a:	01 c0       	rjmp	.+2      	; 0xe8e <xTaskResumeAll+0xf2>
     e8c:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     e8e:	0f 90       	pop	r0
     e90:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     e92:	df 91       	pop	r29
     e94:	cf 91       	pop	r28
     e96:	1f 91       	pop	r17
     e98:	0f 91       	pop	r16
     e9a:	ff 90       	pop	r15
     e9c:	ef 90       	pop	r14
     e9e:	df 90       	pop	r13
     ea0:	08 95       	ret

00000ea2 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     ea2:	0f 2e       	mov	r0, r31
     ea4:	f2 e7       	ldi	r31, 0x72	; 114
     ea6:	ef 2e       	mov	r14, r31
     ea8:	f5 e0       	ldi	r31, 0x05	; 5
     eaa:	ff 2e       	mov	r15, r31
     eac:	f0 2d       	mov	r31, r0
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
     eae:	ca e4       	ldi	r28, 0x4A	; 74
     eb0:	d5 e0       	ldi	r29, 0x05	; 5
     eb2:	28 c0       	rjmp	.+80     	; 0xf04 <prvIdleTask+0x62>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
     eb4:	0e 94 09 06 	call	0xc12	; 0xc12 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
     eb8:	18 81       	ld	r17, Y
			}
			( void ) xTaskResumeAll();
     eba:	0e 94 ce 06 	call	0xd9c	; 0xd9c <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
     ebe:	11 23       	and	r17, r17
     ec0:	09 f1       	breq	.+66     	; 0xf04 <prvIdleTask+0x62>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
     ec2:	0f b6       	in	r0, 0x3f	; 63
     ec4:	f8 94       	cli
     ec6:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
     ec8:	e0 91 4f 05 	lds	r30, 0x054F
     ecc:	f0 91 50 05 	lds	r31, 0x0550
     ed0:	06 81       	ldd	r16, Z+6	; 0x06
     ed2:	17 81       	ldd	r17, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     ed4:	c8 01       	movw	r24, r16
     ed6:	02 96       	adiw	r24, 0x02	; 2
     ed8:	0e 94 3e 01 	call	0x27c	; 0x27c <uxListRemove>
					--uxCurrentNumberOfTasks;
     edc:	80 91 3f 05 	lds	r24, 0x053F
     ee0:	81 50       	subi	r24, 0x01	; 1
     ee2:	80 93 3f 05 	sts	0x053F, r24
					--uxTasksDeleted;
     ee6:	80 91 49 05 	lds	r24, 0x0549
     eea:	81 50       	subi	r24, 0x01	; 1
     eec:	80 93 49 05 	sts	0x0549, r24
				}
				taskEXIT_CRITICAL();
     ef0:	0f 90       	pop	r0
     ef2:	0f be       	out	0x3f, r0	; 63
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
     ef4:	f8 01       	movw	r30, r16
     ef6:	87 89       	ldd	r24, Z+23	; 0x17
     ef8:	90 8d       	ldd	r25, Z+24	; 0x18
     efa:	0e 94 f7 02 	call	0x5ee	; 0x5ee <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
     efe:	c8 01       	movw	r24, r16
     f00:	0e 94 f7 02 	call	0x5ee	; 0x5ee <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
     f04:	80 91 49 05 	lds	r24, 0x0549
     f08:	81 11       	cpse	r24, r1
     f0a:	d4 cf       	rjmp	.-88     	; 0xeb4 <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     f0c:	f7 01       	movw	r30, r14
     f0e:	80 81       	ld	r24, Z
     f10:	82 30       	cpi	r24, 0x02	; 2
     f12:	c0 f3       	brcs	.-16     	; 0xf04 <prvIdleTask+0x62>
			{
				taskYIELD();
     f14:	0e 94 0a 02 	call	0x414	; 0x414 <vPortYield>
     f18:	f5 cf       	rjmp	.-22     	; 0xf04 <prvIdleTask+0x62>

00000f1a <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     f1a:	80 91 34 05 	lds	r24, 0x0534
     f1e:	88 23       	and	r24, r24
     f20:	21 f0       	breq	.+8      	; 0xf2a <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     f22:	81 e0       	ldi	r24, 0x01	; 1
     f24:	80 93 39 05 	sts	0x0539, r24
     f28:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     f2a:	10 92 39 05 	sts	0x0539, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     f2e:	80 91 3c 05 	lds	r24, 0x053C
     f32:	90 e0       	ldi	r25, 0x00	; 0
     f34:	fc 01       	movw	r30, r24
     f36:	ee 0f       	add	r30, r30
     f38:	ff 1f       	adc	r31, r31
     f3a:	ee 0f       	add	r30, r30
     f3c:	ff 1f       	adc	r31, r31
     f3e:	ee 0f       	add	r30, r30
     f40:	ff 1f       	adc	r31, r31
     f42:	8e 0f       	add	r24, r30
     f44:	9f 1f       	adc	r25, r31
     f46:	fc 01       	movw	r30, r24
     f48:	ee 58       	subi	r30, 0x8E	; 142
     f4a:	fa 4f       	sbci	r31, 0xFA	; 250
     f4c:	80 81       	ld	r24, Z
     f4e:	81 11       	cpse	r24, r1
     f50:	17 c0       	rjmp	.+46     	; 0xf80 <vTaskSwitchContext+0x66>
     f52:	80 91 3c 05 	lds	r24, 0x053C
     f56:	81 50       	subi	r24, 0x01	; 1
     f58:	80 93 3c 05 	sts	0x053C, r24
     f5c:	80 91 3c 05 	lds	r24, 0x053C
     f60:	90 e0       	ldi	r25, 0x00	; 0
     f62:	fc 01       	movw	r30, r24
     f64:	ee 0f       	add	r30, r30
     f66:	ff 1f       	adc	r31, r31
     f68:	ee 0f       	add	r30, r30
     f6a:	ff 1f       	adc	r31, r31
     f6c:	ee 0f       	add	r30, r30
     f6e:	ff 1f       	adc	r31, r31
     f70:	8e 0f       	add	r24, r30
     f72:	9f 1f       	adc	r25, r31
     f74:	fc 01       	movw	r30, r24
     f76:	ee 58       	subi	r30, 0x8E	; 142
     f78:	fa 4f       	sbci	r31, 0xFA	; 250
     f7a:	80 81       	ld	r24, Z
     f7c:	88 23       	and	r24, r24
     f7e:	49 f3       	breq	.-46     	; 0xf52 <vTaskSwitchContext+0x38>
     f80:	e0 91 3c 05 	lds	r30, 0x053C
     f84:	f0 e0       	ldi	r31, 0x00	; 0
     f86:	cf 01       	movw	r24, r30
     f88:	88 0f       	add	r24, r24
     f8a:	99 1f       	adc	r25, r25
     f8c:	88 0f       	add	r24, r24
     f8e:	99 1f       	adc	r25, r25
     f90:	88 0f       	add	r24, r24
     f92:	99 1f       	adc	r25, r25
     f94:	e8 0f       	add	r30, r24
     f96:	f9 1f       	adc	r31, r25
     f98:	ee 58       	subi	r30, 0x8E	; 142
     f9a:	fa 4f       	sbci	r31, 0xFA	; 250
     f9c:	a1 81       	ldd	r26, Z+1	; 0x01
     f9e:	b2 81       	ldd	r27, Z+2	; 0x02
     fa0:	12 96       	adiw	r26, 0x02	; 2
     fa2:	0d 90       	ld	r0, X+
     fa4:	bc 91       	ld	r27, X
     fa6:	a0 2d       	mov	r26, r0
     fa8:	b2 83       	std	Z+2, r27	; 0x02
     faa:	a1 83       	std	Z+1, r26	; 0x01
     fac:	cf 01       	movw	r24, r30
     fae:	03 96       	adiw	r24, 0x03	; 3
     fb0:	a8 17       	cp	r26, r24
     fb2:	b9 07       	cpc	r27, r25
     fb4:	31 f4       	brne	.+12     	; 0xfc2 <vTaskSwitchContext+0xa8>
     fb6:	12 96       	adiw	r26, 0x02	; 2
     fb8:	8d 91       	ld	r24, X+
     fba:	9c 91       	ld	r25, X
     fbc:	13 97       	sbiw	r26, 0x03	; 3
     fbe:	92 83       	std	Z+2, r25	; 0x02
     fc0:	81 83       	std	Z+1, r24	; 0x01
     fc2:	01 80       	ldd	r0, Z+1	; 0x01
     fc4:	f2 81       	ldd	r31, Z+2	; 0x02
     fc6:	e0 2d       	mov	r30, r0
     fc8:	86 81       	ldd	r24, Z+6	; 0x06
     fca:	97 81       	ldd	r25, Z+7	; 0x07
     fcc:	90 93 97 05 	sts	0x0597, r25
     fd0:	80 93 96 05 	sts	0x0596, r24
     fd4:	08 95       	ret

00000fd6 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
     fd6:	cf 93       	push	r28
     fd8:	df 93       	push	r29
     fda:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
     fdc:	60 91 96 05 	lds	r22, 0x0596
     fe0:	70 91 97 05 	lds	r23, 0x0597
     fe4:	64 5f       	subi	r22, 0xF4	; 244
     fe6:	7f 4f       	sbci	r23, 0xFF	; 255
     fe8:	0e 94 0d 01 	call	0x21a	; 0x21a <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
     fec:	80 91 96 05 	lds	r24, 0x0596
     ff0:	90 91 97 05 	lds	r25, 0x0597
     ff4:	02 96       	adiw	r24, 0x02	; 2
     ff6:	0e 94 3e 01 	call	0x27c	; 0x27c <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
     ffa:	cf 3f       	cpi	r28, 0xFF	; 255
     ffc:	8f ef       	ldi	r24, 0xFF	; 255
     ffe:	d8 07       	cpc	r29, r24
    1000:	59 f4       	brne	.+22     	; 0x1018 <vTaskPlaceOnEventList+0x42>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure the task is not woken by a timing event.  It will
			block indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    1002:	60 91 96 05 	lds	r22, 0x0596
    1006:	70 91 97 05 	lds	r23, 0x0597
    100a:	6e 5f       	subi	r22, 0xFE	; 254
    100c:	7f 4f       	sbci	r23, 0xFF	; 255
    100e:	80 e4       	ldi	r24, 0x40	; 64
    1010:	95 e0       	ldi	r25, 0x05	; 5
    1012:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <vListInsertEnd>
    1016:	08 c0       	rjmp	.+16     	; 0x1028 <vTaskPlaceOnEventList+0x52>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			scheduler will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    1018:	80 91 3d 05 	lds	r24, 0x053D
    101c:	90 91 3e 05 	lds	r25, 0x053E
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    1020:	8c 0f       	add	r24, r28
    1022:	9d 1f       	adc	r25, r29
    1024:	0e 94 92 04 	call	0x924	; 0x924 <prvAddCurrentTaskToDelayedList>
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    1028:	df 91       	pop	r29
    102a:	cf 91       	pop	r28
    102c:	08 95       	ret

0000102e <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    102e:	0f 93       	push	r16
    1030:	1f 93       	push	r17
    1032:	cf 93       	push	r28
    1034:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1036:	dc 01       	movw	r26, r24
    1038:	15 96       	adiw	r26, 0x05	; 5
    103a:	ed 91       	ld	r30, X+
    103c:	fc 91       	ld	r31, X
    103e:	16 97       	sbiw	r26, 0x06	; 6
    1040:	c6 81       	ldd	r28, Z+6	; 0x06
    1042:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    1044:	8e 01       	movw	r16, r28
    1046:	04 5f       	subi	r16, 0xF4	; 244
    1048:	1f 4f       	sbci	r17, 0xFF	; 255
    104a:	c8 01       	movw	r24, r16
    104c:	0e 94 3e 01 	call	0x27c	; 0x27c <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1050:	80 91 34 05 	lds	r24, 0x0534
    1054:	81 11       	cpse	r24, r1
    1056:	1c c0       	rjmp	.+56     	; 0x1090 <xTaskRemoveFromEventList+0x62>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    1058:	0a 50       	subi	r16, 0x0A	; 10
    105a:	11 09       	sbc	r17, r1
    105c:	c8 01       	movw	r24, r16
    105e:	0e 94 3e 01 	call	0x27c	; 0x27c <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    1062:	8e 89       	ldd	r24, Y+22	; 0x16
    1064:	90 91 3c 05 	lds	r25, 0x053C
    1068:	98 17       	cp	r25, r24
    106a:	10 f4       	brcc	.+4      	; 0x1070 <xTaskRemoveFromEventList+0x42>
    106c:	80 93 3c 05 	sts	0x053C, r24
    1070:	90 e0       	ldi	r25, 0x00	; 0
    1072:	9c 01       	movw	r18, r24
    1074:	22 0f       	add	r18, r18
    1076:	33 1f       	adc	r19, r19
    1078:	22 0f       	add	r18, r18
    107a:	33 1f       	adc	r19, r19
    107c:	22 0f       	add	r18, r18
    107e:	33 1f       	adc	r19, r19
    1080:	82 0f       	add	r24, r18
    1082:	93 1f       	adc	r25, r19
    1084:	b8 01       	movw	r22, r16
    1086:	8e 58       	subi	r24, 0x8E	; 142
    1088:	9a 4f       	sbci	r25, 0xFA	; 250
    108a:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <vListInsertEnd>
    108e:	05 c0       	rjmp	.+10     	; 0x109a <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1090:	b8 01       	movw	r22, r16
    1092:	83 e5       	ldi	r24, 0x53	; 83
    1094:	95 e0       	ldi	r25, 0x05	; 5
    1096:	0e 94 ec 00 	call	0x1d8	; 0x1d8 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    109a:	e0 91 96 05 	lds	r30, 0x0596
    109e:	f0 91 97 05 	lds	r31, 0x0597
    10a2:	9e 89       	ldd	r25, Y+22	; 0x16
    10a4:	86 89       	ldd	r24, Z+22	; 0x16
    10a6:	89 17       	cp	r24, r25
    10a8:	20 f4       	brcc	.+8      	; 0x10b2 <xTaskRemoveFromEventList+0x84>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    10aa:	81 e0       	ldi	r24, 0x01	; 1
    10ac:	80 93 39 05 	sts	0x0539, r24
    10b0:	01 c0       	rjmp	.+2      	; 0x10b4 <xTaskRemoveFromEventList+0x86>
	}
	else
	{
		xReturn = pdFALSE;
    10b2:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
    10b4:	df 91       	pop	r29
    10b6:	cf 91       	pop	r28
    10b8:	1f 91       	pop	r17
    10ba:	0f 91       	pop	r16
    10bc:	08 95       	ret

000010be <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    10be:	20 91 38 05 	lds	r18, 0x0538
    10c2:	fc 01       	movw	r30, r24
    10c4:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    10c6:	20 91 3d 05 	lds	r18, 0x053D
    10ca:	30 91 3e 05 	lds	r19, 0x053E
    10ce:	32 83       	std	Z+2, r19	; 0x02
    10d0:	21 83       	std	Z+1, r18	; 0x01
    10d2:	08 95       	ret

000010d4 <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    10d4:	0f b6       	in	r0, 0x3f	; 63
    10d6:	f8 94       	cli
    10d8:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    10da:	40 91 3d 05 	lds	r20, 0x053D
    10de:	50 91 3e 05 	lds	r21, 0x053E

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    10e2:	db 01       	movw	r26, r22
    10e4:	2d 91       	ld	r18, X+
    10e6:	3c 91       	ld	r19, X
    10e8:	2f 3f       	cpi	r18, 0xFF	; 255
    10ea:	bf ef       	ldi	r27, 0xFF	; 255
    10ec:	3b 07       	cpc	r19, r27
    10ee:	19 f1       	breq	.+70     	; 0x1136 <xTaskCheckForTimeOut+0x62>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    10f0:	e0 91 38 05 	lds	r30, 0x0538
    10f4:	dc 01       	movw	r26, r24
    10f6:	fc 91       	ld	r31, X
    10f8:	fe 17       	cp	r31, r30
    10fa:	39 f0       	breq	.+14     	; 0x110a <xTaskCheckForTimeOut+0x36>
    10fc:	11 96       	adiw	r26, 0x01	; 1
    10fe:	ed 91       	ld	r30, X+
    1100:	fc 91       	ld	r31, X
    1102:	12 97       	sbiw	r26, 0x02	; 2
    1104:	4e 17       	cp	r20, r30
    1106:	5f 07       	cpc	r21, r31
    1108:	c0 f4       	brcc	.+48     	; 0x113a <xTaskCheckForTimeOut+0x66>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    110a:	dc 01       	movw	r26, r24
    110c:	11 96       	adiw	r26, 0x01	; 1
    110e:	ed 91       	ld	r30, X+
    1110:	fc 91       	ld	r31, X
    1112:	12 97       	sbiw	r26, 0x02	; 2
    1114:	da 01       	movw	r26, r20
    1116:	ae 1b       	sub	r26, r30
    1118:	bf 0b       	sbc	r27, r31
    111a:	a2 17       	cp	r26, r18
    111c:	b3 07       	cpc	r27, r19
    111e:	78 f4       	brcc	.+30     	; 0x113e <xTaskCheckForTimeOut+0x6a>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    1120:	e4 1b       	sub	r30, r20
    1122:	f5 0b       	sbc	r31, r21
    1124:	2e 0f       	add	r18, r30
    1126:	3f 1f       	adc	r19, r31
    1128:	fb 01       	movw	r30, r22
    112a:	31 83       	std	Z+1, r19	; 0x01
    112c:	20 83       	st	Z, r18
			vTaskSetTimeOutState( pxTimeOut );
    112e:	0e 94 5f 08 	call	0x10be	; 0x10be <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    1132:	80 e0       	ldi	r24, 0x00	; 0
    1134:	05 c0       	rjmp	.+10     	; 0x1140 <xTaskCheckForTimeOut+0x6c>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
    1136:	80 e0       	ldi	r24, 0x00	; 0
    1138:	03 c0       	rjmp	.+6      	; 0x1140 <xTaskCheckForTimeOut+0x6c>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    113a:	81 e0       	ldi	r24, 0x01	; 1
    113c:	01 c0       	rjmp	.+2      	; 0x1140 <xTaskCheckForTimeOut+0x6c>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    113e:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    1140:	0f 90       	pop	r0
    1142:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    1144:	08 95       	ret

00001146 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    1146:	81 e0       	ldi	r24, 0x01	; 1
    1148:	80 93 39 05 	sts	0x0539, r24
    114c:	08 95       	ret

0000114e <USART_Init>:
#include <avr/io.h>
#include <stdio.h>

void USART_Init(unsigned int ubrr) {
	/* set baud rate */
	UBRR0H = (unsigned char)(ubrr>>8);
    114e:	90 93 c5 00 	sts	0x00C5, r25
	UBRR0L = (unsigned char)ubrr;
    1152:	80 93 c4 00 	sts	0x00C4, r24

    UCSR0C = _BV(USBS0) | _BV(UCSZ01) | _BV(UCSZ00); /* 8-bit data, 2 stop bits */ 
    1156:	8e e0       	ldi	r24, 0x0E	; 14
    1158:	80 93 c2 00 	sts	0x00C2, r24
    UCSR0B = _BV(RXEN0) | _BV(TXEN0);   /* Enable RX and TX */    
    115c:	88 e1       	ldi	r24, 0x18	; 24
    115e:	80 93 c1 00 	sts	0x00C1, r24
    1162:	08 95       	ret

00001164 <USART_Transmit>:
}

void USART_Transmit(char c, FILE *stream) {
    1164:	cf 93       	push	r28
    1166:	c8 2f       	mov	r28, r24
    if (c == '\n') {
    1168:	8a 30       	cpi	r24, 0x0A	; 10
    116a:	19 f4       	brne	.+6      	; 0x1172 <USART_Transmit+0xe>
        USART_Transmit('\r', stream); /* transmit carriage return with new line */
    116c:	8d e0       	ldi	r24, 0x0D	; 13
    116e:	0e 94 b2 08 	call	0x1164	; 0x1164 <USART_Transmit>
    }
    /* Wait for empty transmit buffer */
    while ( !( UCSR0A & (1<<UDRE0)) )
    1172:	e0 ec       	ldi	r30, 0xC0	; 192
    1174:	f0 e0       	ldi	r31, 0x00	; 0
    1176:	90 81       	ld	r25, Z
    1178:	95 ff       	sbrs	r25, 5
    117a:	fd cf       	rjmp	.-6      	; 0x1176 <USART_Transmit+0x12>
    ;
    /* Put data into buffer, sends the data */
    UDR0 = c;
    117c:	c0 93 c6 00 	sts	0x00C6, r28
}
    1180:	cf 91       	pop	r28
    1182:	08 95       	ret

00001184 <USART_Receive>:

char USART_Receive(FILE *stream) {
    /* Wait for data to be received */
    while ( !(UCSR0A & (1<<RXC0)) )
    1184:	e0 ec       	ldi	r30, 0xC0	; 192
    1186:	f0 e0       	ldi	r31, 0x00	; 0
    1188:	80 81       	ld	r24, Z
    118a:	88 23       	and	r24, r24
    118c:	ec f7       	brge	.-6      	; 0x1188 <USART_Receive+0x4>
    ;
    /* Get and return received data from buffer */
    return UDR0;
    118e:	80 91 c6 00 	lds	r24, 0x00C6
}
    1192:	08 95       	ret

00001194 <memcpy>:
    1194:	fb 01       	movw	r30, r22
    1196:	dc 01       	movw	r26, r24
    1198:	02 c0       	rjmp	.+4      	; 0x119e <memcpy+0xa>
    119a:	01 90       	ld	r0, Z+
    119c:	0d 92       	st	X+, r0
    119e:	41 50       	subi	r20, 0x01	; 1
    11a0:	50 40       	sbci	r21, 0x00	; 0
    11a2:	d8 f7       	brcc	.-10     	; 0x119a <memcpy+0x6>
    11a4:	08 95       	ret

000011a6 <printf>:
    11a6:	a0 e0       	ldi	r26, 0x00	; 0
    11a8:	b0 e0       	ldi	r27, 0x00	; 0
    11aa:	e9 ed       	ldi	r30, 0xD9	; 217
    11ac:	f8 e0       	ldi	r31, 0x08	; 8
    11ae:	0c 94 6f 0b 	jmp	0x16de	; 0x16de <__prologue_saves__+0x20>
    11b2:	fe 01       	movw	r30, r28
    11b4:	35 96       	adiw	r30, 0x05	; 5
    11b6:	61 91       	ld	r22, Z+
    11b8:	71 91       	ld	r23, Z+
    11ba:	af 01       	movw	r20, r30
    11bc:	80 91 9e 05 	lds	r24, 0x059E
    11c0:	90 91 9f 05 	lds	r25, 0x059F
    11c4:	0e 94 e7 08 	call	0x11ce	; 0x11ce <vfprintf>
    11c8:	e2 e0       	ldi	r30, 0x02	; 2
    11ca:	0c 94 8b 0b 	jmp	0x1716	; 0x1716 <__epilogue_restores__+0x20>

000011ce <vfprintf>:
    11ce:	ac e0       	ldi	r26, 0x0C	; 12
    11d0:	b0 e0       	ldi	r27, 0x00	; 0
    11d2:	ed ee       	ldi	r30, 0xED	; 237
    11d4:	f8 e0       	ldi	r31, 0x08	; 8
    11d6:	0c 94 5f 0b 	jmp	0x16be	; 0x16be <__prologue_saves__>
    11da:	7c 01       	movw	r14, r24
    11dc:	6b 01       	movw	r12, r22
    11de:	8a 01       	movw	r16, r20
    11e0:	fc 01       	movw	r30, r24
    11e2:	17 82       	std	Z+7, r1	; 0x07
    11e4:	16 82       	std	Z+6, r1	; 0x06
    11e6:	83 81       	ldd	r24, Z+3	; 0x03
    11e8:	81 ff       	sbrs	r24, 1
    11ea:	bd c1       	rjmp	.+890    	; 0x1566 <vfprintf+0x398>
    11ec:	ce 01       	movw	r24, r28
    11ee:	01 96       	adiw	r24, 0x01	; 1
    11f0:	4c 01       	movw	r8, r24
    11f2:	f7 01       	movw	r30, r14
    11f4:	93 81       	ldd	r25, Z+3	; 0x03
    11f6:	f6 01       	movw	r30, r12
    11f8:	93 fd       	sbrc	r25, 3
    11fa:	85 91       	lpm	r24, Z+
    11fc:	93 ff       	sbrs	r25, 3
    11fe:	81 91       	ld	r24, Z+
    1200:	6f 01       	movw	r12, r30
    1202:	88 23       	and	r24, r24
    1204:	09 f4       	brne	.+2      	; 0x1208 <vfprintf+0x3a>
    1206:	ab c1       	rjmp	.+854    	; 0x155e <vfprintf+0x390>
    1208:	85 32       	cpi	r24, 0x25	; 37
    120a:	39 f4       	brne	.+14     	; 0x121a <vfprintf+0x4c>
    120c:	93 fd       	sbrc	r25, 3
    120e:	85 91       	lpm	r24, Z+
    1210:	93 ff       	sbrs	r25, 3
    1212:	81 91       	ld	r24, Z+
    1214:	6f 01       	movw	r12, r30
    1216:	85 32       	cpi	r24, 0x25	; 37
    1218:	29 f4       	brne	.+10     	; 0x1224 <vfprintf+0x56>
    121a:	b7 01       	movw	r22, r14
    121c:	90 e0       	ldi	r25, 0x00	; 0
    121e:	0e 94 cf 0a 	call	0x159e	; 0x159e <fputc>
    1222:	e7 cf       	rjmp	.-50     	; 0x11f2 <vfprintf+0x24>
    1224:	51 2c       	mov	r5, r1
    1226:	31 2c       	mov	r3, r1
    1228:	20 e0       	ldi	r18, 0x00	; 0
    122a:	20 32       	cpi	r18, 0x20	; 32
    122c:	a0 f4       	brcc	.+40     	; 0x1256 <vfprintf+0x88>
    122e:	8b 32       	cpi	r24, 0x2B	; 43
    1230:	69 f0       	breq	.+26     	; 0x124c <vfprintf+0x7e>
    1232:	30 f4       	brcc	.+12     	; 0x1240 <vfprintf+0x72>
    1234:	80 32       	cpi	r24, 0x20	; 32
    1236:	59 f0       	breq	.+22     	; 0x124e <vfprintf+0x80>
    1238:	83 32       	cpi	r24, 0x23	; 35
    123a:	69 f4       	brne	.+26     	; 0x1256 <vfprintf+0x88>
    123c:	20 61       	ori	r18, 0x10	; 16
    123e:	2c c0       	rjmp	.+88     	; 0x1298 <vfprintf+0xca>
    1240:	8d 32       	cpi	r24, 0x2D	; 45
    1242:	39 f0       	breq	.+14     	; 0x1252 <vfprintf+0x84>
    1244:	80 33       	cpi	r24, 0x30	; 48
    1246:	39 f4       	brne	.+14     	; 0x1256 <vfprintf+0x88>
    1248:	21 60       	ori	r18, 0x01	; 1
    124a:	26 c0       	rjmp	.+76     	; 0x1298 <vfprintf+0xca>
    124c:	22 60       	ori	r18, 0x02	; 2
    124e:	24 60       	ori	r18, 0x04	; 4
    1250:	23 c0       	rjmp	.+70     	; 0x1298 <vfprintf+0xca>
    1252:	28 60       	ori	r18, 0x08	; 8
    1254:	21 c0       	rjmp	.+66     	; 0x1298 <vfprintf+0xca>
    1256:	27 fd       	sbrc	r18, 7
    1258:	27 c0       	rjmp	.+78     	; 0x12a8 <vfprintf+0xda>
    125a:	30 ed       	ldi	r19, 0xD0	; 208
    125c:	38 0f       	add	r19, r24
    125e:	3a 30       	cpi	r19, 0x0A	; 10
    1260:	78 f4       	brcc	.+30     	; 0x1280 <vfprintf+0xb2>
    1262:	26 ff       	sbrs	r18, 6
    1264:	06 c0       	rjmp	.+12     	; 0x1272 <vfprintf+0xa4>
    1266:	fa e0       	ldi	r31, 0x0A	; 10
    1268:	5f 9e       	mul	r5, r31
    126a:	30 0d       	add	r19, r0
    126c:	11 24       	eor	r1, r1
    126e:	53 2e       	mov	r5, r19
    1270:	13 c0       	rjmp	.+38     	; 0x1298 <vfprintf+0xca>
    1272:	8a e0       	ldi	r24, 0x0A	; 10
    1274:	38 9e       	mul	r3, r24
    1276:	30 0d       	add	r19, r0
    1278:	11 24       	eor	r1, r1
    127a:	33 2e       	mov	r3, r19
    127c:	20 62       	ori	r18, 0x20	; 32
    127e:	0c c0       	rjmp	.+24     	; 0x1298 <vfprintf+0xca>
    1280:	8e 32       	cpi	r24, 0x2E	; 46
    1282:	21 f4       	brne	.+8      	; 0x128c <vfprintf+0xbe>
    1284:	26 fd       	sbrc	r18, 6
    1286:	6b c1       	rjmp	.+726    	; 0x155e <vfprintf+0x390>
    1288:	20 64       	ori	r18, 0x40	; 64
    128a:	06 c0       	rjmp	.+12     	; 0x1298 <vfprintf+0xca>
    128c:	8c 36       	cpi	r24, 0x6C	; 108
    128e:	11 f4       	brne	.+4      	; 0x1294 <vfprintf+0xc6>
    1290:	20 68       	ori	r18, 0x80	; 128
    1292:	02 c0       	rjmp	.+4      	; 0x1298 <vfprintf+0xca>
    1294:	88 36       	cpi	r24, 0x68	; 104
    1296:	41 f4       	brne	.+16     	; 0x12a8 <vfprintf+0xda>
    1298:	f6 01       	movw	r30, r12
    129a:	93 fd       	sbrc	r25, 3
    129c:	85 91       	lpm	r24, Z+
    129e:	93 ff       	sbrs	r25, 3
    12a0:	81 91       	ld	r24, Z+
    12a2:	6f 01       	movw	r12, r30
    12a4:	81 11       	cpse	r24, r1
    12a6:	c1 cf       	rjmp	.-126    	; 0x122a <vfprintf+0x5c>
    12a8:	98 2f       	mov	r25, r24
    12aa:	9f 7d       	andi	r25, 0xDF	; 223
    12ac:	95 54       	subi	r25, 0x45	; 69
    12ae:	93 30       	cpi	r25, 0x03	; 3
    12b0:	28 f4       	brcc	.+10     	; 0x12bc <vfprintf+0xee>
    12b2:	0c 5f       	subi	r16, 0xFC	; 252
    12b4:	1f 4f       	sbci	r17, 0xFF	; 255
    12b6:	ff e3       	ldi	r31, 0x3F	; 63
    12b8:	f9 83       	std	Y+1, r31	; 0x01
    12ba:	0d c0       	rjmp	.+26     	; 0x12d6 <vfprintf+0x108>
    12bc:	83 36       	cpi	r24, 0x63	; 99
    12be:	31 f0       	breq	.+12     	; 0x12cc <vfprintf+0xfe>
    12c0:	83 37       	cpi	r24, 0x73	; 115
    12c2:	71 f0       	breq	.+28     	; 0x12e0 <vfprintf+0x112>
    12c4:	83 35       	cpi	r24, 0x53	; 83
    12c6:	09 f0       	breq	.+2      	; 0x12ca <vfprintf+0xfc>
    12c8:	5b c0       	rjmp	.+182    	; 0x1380 <vfprintf+0x1b2>
    12ca:	22 c0       	rjmp	.+68     	; 0x1310 <vfprintf+0x142>
    12cc:	f8 01       	movw	r30, r16
    12ce:	80 81       	ld	r24, Z
    12d0:	89 83       	std	Y+1, r24	; 0x01
    12d2:	0e 5f       	subi	r16, 0xFE	; 254
    12d4:	1f 4f       	sbci	r17, 0xFF	; 255
    12d6:	44 24       	eor	r4, r4
    12d8:	43 94       	inc	r4
    12da:	51 2c       	mov	r5, r1
    12dc:	54 01       	movw	r10, r8
    12de:	15 c0       	rjmp	.+42     	; 0x130a <vfprintf+0x13c>
    12e0:	38 01       	movw	r6, r16
    12e2:	f2 e0       	ldi	r31, 0x02	; 2
    12e4:	6f 0e       	add	r6, r31
    12e6:	71 1c       	adc	r7, r1
    12e8:	f8 01       	movw	r30, r16
    12ea:	a0 80       	ld	r10, Z
    12ec:	b1 80       	ldd	r11, Z+1	; 0x01
    12ee:	26 ff       	sbrs	r18, 6
    12f0:	03 c0       	rjmp	.+6      	; 0x12f8 <vfprintf+0x12a>
    12f2:	65 2d       	mov	r22, r5
    12f4:	70 e0       	ldi	r23, 0x00	; 0
    12f6:	02 c0       	rjmp	.+4      	; 0x12fc <vfprintf+0x12e>
    12f8:	6f ef       	ldi	r22, 0xFF	; 255
    12fa:	7f ef       	ldi	r23, 0xFF	; 255
    12fc:	c5 01       	movw	r24, r10
    12fe:	2c 87       	std	Y+12, r18	; 0x0c
    1300:	0e 94 c4 0a 	call	0x1588	; 0x1588 <strnlen>
    1304:	2c 01       	movw	r4, r24
    1306:	83 01       	movw	r16, r6
    1308:	2c 85       	ldd	r18, Y+12	; 0x0c
    130a:	2f 77       	andi	r18, 0x7F	; 127
    130c:	22 2e       	mov	r2, r18
    130e:	17 c0       	rjmp	.+46     	; 0x133e <vfprintf+0x170>
    1310:	38 01       	movw	r6, r16
    1312:	f2 e0       	ldi	r31, 0x02	; 2
    1314:	6f 0e       	add	r6, r31
    1316:	71 1c       	adc	r7, r1
    1318:	f8 01       	movw	r30, r16
    131a:	a0 80       	ld	r10, Z
    131c:	b1 80       	ldd	r11, Z+1	; 0x01
    131e:	26 ff       	sbrs	r18, 6
    1320:	03 c0       	rjmp	.+6      	; 0x1328 <vfprintf+0x15a>
    1322:	65 2d       	mov	r22, r5
    1324:	70 e0       	ldi	r23, 0x00	; 0
    1326:	02 c0       	rjmp	.+4      	; 0x132c <vfprintf+0x15e>
    1328:	6f ef       	ldi	r22, 0xFF	; 255
    132a:	7f ef       	ldi	r23, 0xFF	; 255
    132c:	c5 01       	movw	r24, r10
    132e:	2c 87       	std	Y+12, r18	; 0x0c
    1330:	0e 94 b9 0a 	call	0x1572	; 0x1572 <strnlen_P>
    1334:	2c 01       	movw	r4, r24
    1336:	2c 85       	ldd	r18, Y+12	; 0x0c
    1338:	20 68       	ori	r18, 0x80	; 128
    133a:	22 2e       	mov	r2, r18
    133c:	83 01       	movw	r16, r6
    133e:	23 fc       	sbrc	r2, 3
    1340:	1b c0       	rjmp	.+54     	; 0x1378 <vfprintf+0x1aa>
    1342:	83 2d       	mov	r24, r3
    1344:	90 e0       	ldi	r25, 0x00	; 0
    1346:	48 16       	cp	r4, r24
    1348:	59 06       	cpc	r5, r25
    134a:	b0 f4       	brcc	.+44     	; 0x1378 <vfprintf+0x1aa>
    134c:	b7 01       	movw	r22, r14
    134e:	80 e2       	ldi	r24, 0x20	; 32
    1350:	90 e0       	ldi	r25, 0x00	; 0
    1352:	0e 94 cf 0a 	call	0x159e	; 0x159e <fputc>
    1356:	3a 94       	dec	r3
    1358:	f4 cf       	rjmp	.-24     	; 0x1342 <vfprintf+0x174>
    135a:	f5 01       	movw	r30, r10
    135c:	27 fc       	sbrc	r2, 7
    135e:	85 91       	lpm	r24, Z+
    1360:	27 fe       	sbrs	r2, 7
    1362:	81 91       	ld	r24, Z+
    1364:	5f 01       	movw	r10, r30
    1366:	b7 01       	movw	r22, r14
    1368:	90 e0       	ldi	r25, 0x00	; 0
    136a:	0e 94 cf 0a 	call	0x159e	; 0x159e <fputc>
    136e:	31 10       	cpse	r3, r1
    1370:	3a 94       	dec	r3
    1372:	f1 e0       	ldi	r31, 0x01	; 1
    1374:	4f 1a       	sub	r4, r31
    1376:	51 08       	sbc	r5, r1
    1378:	41 14       	cp	r4, r1
    137a:	51 04       	cpc	r5, r1
    137c:	71 f7       	brne	.-36     	; 0x135a <vfprintf+0x18c>
    137e:	e5 c0       	rjmp	.+458    	; 0x154a <vfprintf+0x37c>
    1380:	84 36       	cpi	r24, 0x64	; 100
    1382:	11 f0       	breq	.+4      	; 0x1388 <vfprintf+0x1ba>
    1384:	89 36       	cpi	r24, 0x69	; 105
    1386:	39 f5       	brne	.+78     	; 0x13d6 <vfprintf+0x208>
    1388:	f8 01       	movw	r30, r16
    138a:	27 ff       	sbrs	r18, 7
    138c:	07 c0       	rjmp	.+14     	; 0x139c <vfprintf+0x1ce>
    138e:	60 81       	ld	r22, Z
    1390:	71 81       	ldd	r23, Z+1	; 0x01
    1392:	82 81       	ldd	r24, Z+2	; 0x02
    1394:	93 81       	ldd	r25, Z+3	; 0x03
    1396:	0c 5f       	subi	r16, 0xFC	; 252
    1398:	1f 4f       	sbci	r17, 0xFF	; 255
    139a:	08 c0       	rjmp	.+16     	; 0x13ac <vfprintf+0x1de>
    139c:	60 81       	ld	r22, Z
    139e:	71 81       	ldd	r23, Z+1	; 0x01
    13a0:	88 27       	eor	r24, r24
    13a2:	77 fd       	sbrc	r23, 7
    13a4:	80 95       	com	r24
    13a6:	98 2f       	mov	r25, r24
    13a8:	0e 5f       	subi	r16, 0xFE	; 254
    13aa:	1f 4f       	sbci	r17, 0xFF	; 255
    13ac:	2f 76       	andi	r18, 0x6F	; 111
    13ae:	b2 2e       	mov	r11, r18
    13b0:	97 ff       	sbrs	r25, 7
    13b2:	09 c0       	rjmp	.+18     	; 0x13c6 <vfprintf+0x1f8>
    13b4:	90 95       	com	r25
    13b6:	80 95       	com	r24
    13b8:	70 95       	com	r23
    13ba:	61 95       	neg	r22
    13bc:	7f 4f       	sbci	r23, 0xFF	; 255
    13be:	8f 4f       	sbci	r24, 0xFF	; 255
    13c0:	9f 4f       	sbci	r25, 0xFF	; 255
    13c2:	20 68       	ori	r18, 0x80	; 128
    13c4:	b2 2e       	mov	r11, r18
    13c6:	2a e0       	ldi	r18, 0x0A	; 10
    13c8:	30 e0       	ldi	r19, 0x00	; 0
    13ca:	a4 01       	movw	r20, r8
    13cc:	0e 94 01 0b 	call	0x1602	; 0x1602 <__ultoa_invert>
    13d0:	a8 2e       	mov	r10, r24
    13d2:	a8 18       	sub	r10, r8
    13d4:	44 c0       	rjmp	.+136    	; 0x145e <vfprintf+0x290>
    13d6:	85 37       	cpi	r24, 0x75	; 117
    13d8:	29 f4       	brne	.+10     	; 0x13e4 <vfprintf+0x216>
    13da:	2f 7e       	andi	r18, 0xEF	; 239
    13dc:	b2 2e       	mov	r11, r18
    13de:	2a e0       	ldi	r18, 0x0A	; 10
    13e0:	30 e0       	ldi	r19, 0x00	; 0
    13e2:	25 c0       	rjmp	.+74     	; 0x142e <vfprintf+0x260>
    13e4:	f2 2f       	mov	r31, r18
    13e6:	f9 7f       	andi	r31, 0xF9	; 249
    13e8:	bf 2e       	mov	r11, r31
    13ea:	8f 36       	cpi	r24, 0x6F	; 111
    13ec:	c1 f0       	breq	.+48     	; 0x141e <vfprintf+0x250>
    13ee:	18 f4       	brcc	.+6      	; 0x13f6 <vfprintf+0x228>
    13f0:	88 35       	cpi	r24, 0x58	; 88
    13f2:	79 f0       	breq	.+30     	; 0x1412 <vfprintf+0x244>
    13f4:	b4 c0       	rjmp	.+360    	; 0x155e <vfprintf+0x390>
    13f6:	80 37       	cpi	r24, 0x70	; 112
    13f8:	19 f0       	breq	.+6      	; 0x1400 <vfprintf+0x232>
    13fa:	88 37       	cpi	r24, 0x78	; 120
    13fc:	21 f0       	breq	.+8      	; 0x1406 <vfprintf+0x238>
    13fe:	af c0       	rjmp	.+350    	; 0x155e <vfprintf+0x390>
    1400:	2f 2f       	mov	r18, r31
    1402:	20 61       	ori	r18, 0x10	; 16
    1404:	b2 2e       	mov	r11, r18
    1406:	b4 fe       	sbrs	r11, 4
    1408:	0d c0       	rjmp	.+26     	; 0x1424 <vfprintf+0x256>
    140a:	8b 2d       	mov	r24, r11
    140c:	84 60       	ori	r24, 0x04	; 4
    140e:	b8 2e       	mov	r11, r24
    1410:	09 c0       	rjmp	.+18     	; 0x1424 <vfprintf+0x256>
    1412:	24 ff       	sbrs	r18, 4
    1414:	0a c0       	rjmp	.+20     	; 0x142a <vfprintf+0x25c>
    1416:	9f 2f       	mov	r25, r31
    1418:	96 60       	ori	r25, 0x06	; 6
    141a:	b9 2e       	mov	r11, r25
    141c:	06 c0       	rjmp	.+12     	; 0x142a <vfprintf+0x25c>
    141e:	28 e0       	ldi	r18, 0x08	; 8
    1420:	30 e0       	ldi	r19, 0x00	; 0
    1422:	05 c0       	rjmp	.+10     	; 0x142e <vfprintf+0x260>
    1424:	20 e1       	ldi	r18, 0x10	; 16
    1426:	30 e0       	ldi	r19, 0x00	; 0
    1428:	02 c0       	rjmp	.+4      	; 0x142e <vfprintf+0x260>
    142a:	20 e1       	ldi	r18, 0x10	; 16
    142c:	32 e0       	ldi	r19, 0x02	; 2
    142e:	f8 01       	movw	r30, r16
    1430:	b7 fe       	sbrs	r11, 7
    1432:	07 c0       	rjmp	.+14     	; 0x1442 <vfprintf+0x274>
    1434:	60 81       	ld	r22, Z
    1436:	71 81       	ldd	r23, Z+1	; 0x01
    1438:	82 81       	ldd	r24, Z+2	; 0x02
    143a:	93 81       	ldd	r25, Z+3	; 0x03
    143c:	0c 5f       	subi	r16, 0xFC	; 252
    143e:	1f 4f       	sbci	r17, 0xFF	; 255
    1440:	06 c0       	rjmp	.+12     	; 0x144e <vfprintf+0x280>
    1442:	60 81       	ld	r22, Z
    1444:	71 81       	ldd	r23, Z+1	; 0x01
    1446:	80 e0       	ldi	r24, 0x00	; 0
    1448:	90 e0       	ldi	r25, 0x00	; 0
    144a:	0e 5f       	subi	r16, 0xFE	; 254
    144c:	1f 4f       	sbci	r17, 0xFF	; 255
    144e:	a4 01       	movw	r20, r8
    1450:	0e 94 01 0b 	call	0x1602	; 0x1602 <__ultoa_invert>
    1454:	a8 2e       	mov	r10, r24
    1456:	a8 18       	sub	r10, r8
    1458:	fb 2d       	mov	r31, r11
    145a:	ff 77       	andi	r31, 0x7F	; 127
    145c:	bf 2e       	mov	r11, r31
    145e:	b6 fe       	sbrs	r11, 6
    1460:	0b c0       	rjmp	.+22     	; 0x1478 <vfprintf+0x2aa>
    1462:	2b 2d       	mov	r18, r11
    1464:	2e 7f       	andi	r18, 0xFE	; 254
    1466:	a5 14       	cp	r10, r5
    1468:	50 f4       	brcc	.+20     	; 0x147e <vfprintf+0x2b0>
    146a:	b4 fe       	sbrs	r11, 4
    146c:	0a c0       	rjmp	.+20     	; 0x1482 <vfprintf+0x2b4>
    146e:	b2 fc       	sbrc	r11, 2
    1470:	08 c0       	rjmp	.+16     	; 0x1482 <vfprintf+0x2b4>
    1472:	2b 2d       	mov	r18, r11
    1474:	2e 7e       	andi	r18, 0xEE	; 238
    1476:	05 c0       	rjmp	.+10     	; 0x1482 <vfprintf+0x2b4>
    1478:	7a 2c       	mov	r7, r10
    147a:	2b 2d       	mov	r18, r11
    147c:	03 c0       	rjmp	.+6      	; 0x1484 <vfprintf+0x2b6>
    147e:	7a 2c       	mov	r7, r10
    1480:	01 c0       	rjmp	.+2      	; 0x1484 <vfprintf+0x2b6>
    1482:	75 2c       	mov	r7, r5
    1484:	24 ff       	sbrs	r18, 4
    1486:	0d c0       	rjmp	.+26     	; 0x14a2 <vfprintf+0x2d4>
    1488:	fe 01       	movw	r30, r28
    148a:	ea 0d       	add	r30, r10
    148c:	f1 1d       	adc	r31, r1
    148e:	80 81       	ld	r24, Z
    1490:	80 33       	cpi	r24, 0x30	; 48
    1492:	11 f4       	brne	.+4      	; 0x1498 <vfprintf+0x2ca>
    1494:	29 7e       	andi	r18, 0xE9	; 233
    1496:	09 c0       	rjmp	.+18     	; 0x14aa <vfprintf+0x2dc>
    1498:	22 ff       	sbrs	r18, 2
    149a:	06 c0       	rjmp	.+12     	; 0x14a8 <vfprintf+0x2da>
    149c:	73 94       	inc	r7
    149e:	73 94       	inc	r7
    14a0:	04 c0       	rjmp	.+8      	; 0x14aa <vfprintf+0x2dc>
    14a2:	82 2f       	mov	r24, r18
    14a4:	86 78       	andi	r24, 0x86	; 134
    14a6:	09 f0       	breq	.+2      	; 0x14aa <vfprintf+0x2dc>
    14a8:	73 94       	inc	r7
    14aa:	23 fd       	sbrc	r18, 3
    14ac:	13 c0       	rjmp	.+38     	; 0x14d4 <vfprintf+0x306>
    14ae:	20 ff       	sbrs	r18, 0
    14b0:	06 c0       	rjmp	.+12     	; 0x14be <vfprintf+0x2f0>
    14b2:	5a 2c       	mov	r5, r10
    14b4:	73 14       	cp	r7, r3
    14b6:	18 f4       	brcc	.+6      	; 0x14be <vfprintf+0x2f0>
    14b8:	53 0c       	add	r5, r3
    14ba:	57 18       	sub	r5, r7
    14bc:	73 2c       	mov	r7, r3
    14be:	73 14       	cp	r7, r3
    14c0:	68 f4       	brcc	.+26     	; 0x14dc <vfprintf+0x30e>
    14c2:	b7 01       	movw	r22, r14
    14c4:	80 e2       	ldi	r24, 0x20	; 32
    14c6:	90 e0       	ldi	r25, 0x00	; 0
    14c8:	2c 87       	std	Y+12, r18	; 0x0c
    14ca:	0e 94 cf 0a 	call	0x159e	; 0x159e <fputc>
    14ce:	73 94       	inc	r7
    14d0:	2c 85       	ldd	r18, Y+12	; 0x0c
    14d2:	f5 cf       	rjmp	.-22     	; 0x14be <vfprintf+0x2f0>
    14d4:	73 14       	cp	r7, r3
    14d6:	10 f4       	brcc	.+4      	; 0x14dc <vfprintf+0x30e>
    14d8:	37 18       	sub	r3, r7
    14da:	01 c0       	rjmp	.+2      	; 0x14de <vfprintf+0x310>
    14dc:	31 2c       	mov	r3, r1
    14de:	24 ff       	sbrs	r18, 4
    14e0:	12 c0       	rjmp	.+36     	; 0x1506 <vfprintf+0x338>
    14e2:	b7 01       	movw	r22, r14
    14e4:	80 e3       	ldi	r24, 0x30	; 48
    14e6:	90 e0       	ldi	r25, 0x00	; 0
    14e8:	2c 87       	std	Y+12, r18	; 0x0c
    14ea:	0e 94 cf 0a 	call	0x159e	; 0x159e <fputc>
    14ee:	2c 85       	ldd	r18, Y+12	; 0x0c
    14f0:	22 ff       	sbrs	r18, 2
    14f2:	17 c0       	rjmp	.+46     	; 0x1522 <vfprintf+0x354>
    14f4:	21 ff       	sbrs	r18, 1
    14f6:	03 c0       	rjmp	.+6      	; 0x14fe <vfprintf+0x330>
    14f8:	88 e5       	ldi	r24, 0x58	; 88
    14fa:	90 e0       	ldi	r25, 0x00	; 0
    14fc:	02 c0       	rjmp	.+4      	; 0x1502 <vfprintf+0x334>
    14fe:	88 e7       	ldi	r24, 0x78	; 120
    1500:	90 e0       	ldi	r25, 0x00	; 0
    1502:	b7 01       	movw	r22, r14
    1504:	0c c0       	rjmp	.+24     	; 0x151e <vfprintf+0x350>
    1506:	82 2f       	mov	r24, r18
    1508:	86 78       	andi	r24, 0x86	; 134
    150a:	59 f0       	breq	.+22     	; 0x1522 <vfprintf+0x354>
    150c:	21 fd       	sbrc	r18, 1
    150e:	02 c0       	rjmp	.+4      	; 0x1514 <vfprintf+0x346>
    1510:	80 e2       	ldi	r24, 0x20	; 32
    1512:	01 c0       	rjmp	.+2      	; 0x1516 <vfprintf+0x348>
    1514:	8b e2       	ldi	r24, 0x2B	; 43
    1516:	27 fd       	sbrc	r18, 7
    1518:	8d e2       	ldi	r24, 0x2D	; 45
    151a:	b7 01       	movw	r22, r14
    151c:	90 e0       	ldi	r25, 0x00	; 0
    151e:	0e 94 cf 0a 	call	0x159e	; 0x159e <fputc>
    1522:	a5 14       	cp	r10, r5
    1524:	38 f4       	brcc	.+14     	; 0x1534 <vfprintf+0x366>
    1526:	b7 01       	movw	r22, r14
    1528:	80 e3       	ldi	r24, 0x30	; 48
    152a:	90 e0       	ldi	r25, 0x00	; 0
    152c:	0e 94 cf 0a 	call	0x159e	; 0x159e <fputc>
    1530:	5a 94       	dec	r5
    1532:	f7 cf       	rjmp	.-18     	; 0x1522 <vfprintf+0x354>
    1534:	aa 94       	dec	r10
    1536:	f4 01       	movw	r30, r8
    1538:	ea 0d       	add	r30, r10
    153a:	f1 1d       	adc	r31, r1
    153c:	80 81       	ld	r24, Z
    153e:	b7 01       	movw	r22, r14
    1540:	90 e0       	ldi	r25, 0x00	; 0
    1542:	0e 94 cf 0a 	call	0x159e	; 0x159e <fputc>
    1546:	a1 10       	cpse	r10, r1
    1548:	f5 cf       	rjmp	.-22     	; 0x1534 <vfprintf+0x366>
    154a:	33 20       	and	r3, r3
    154c:	09 f4       	brne	.+2      	; 0x1550 <vfprintf+0x382>
    154e:	51 ce       	rjmp	.-862    	; 0x11f2 <vfprintf+0x24>
    1550:	b7 01       	movw	r22, r14
    1552:	80 e2       	ldi	r24, 0x20	; 32
    1554:	90 e0       	ldi	r25, 0x00	; 0
    1556:	0e 94 cf 0a 	call	0x159e	; 0x159e <fputc>
    155a:	3a 94       	dec	r3
    155c:	f6 cf       	rjmp	.-20     	; 0x154a <vfprintf+0x37c>
    155e:	f7 01       	movw	r30, r14
    1560:	86 81       	ldd	r24, Z+6	; 0x06
    1562:	97 81       	ldd	r25, Z+7	; 0x07
    1564:	02 c0       	rjmp	.+4      	; 0x156a <vfprintf+0x39c>
    1566:	8f ef       	ldi	r24, 0xFF	; 255
    1568:	9f ef       	ldi	r25, 0xFF	; 255
    156a:	2c 96       	adiw	r28, 0x0c	; 12
    156c:	e2 e1       	ldi	r30, 0x12	; 18
    156e:	0c 94 7b 0b 	jmp	0x16f6	; 0x16f6 <__epilogue_restores__>

00001572 <strnlen_P>:
    1572:	fc 01       	movw	r30, r24
    1574:	05 90       	lpm	r0, Z+
    1576:	61 50       	subi	r22, 0x01	; 1
    1578:	70 40       	sbci	r23, 0x00	; 0
    157a:	01 10       	cpse	r0, r1
    157c:	d8 f7       	brcc	.-10     	; 0x1574 <strnlen_P+0x2>
    157e:	80 95       	com	r24
    1580:	90 95       	com	r25
    1582:	8e 0f       	add	r24, r30
    1584:	9f 1f       	adc	r25, r31
    1586:	08 95       	ret

00001588 <strnlen>:
    1588:	fc 01       	movw	r30, r24
    158a:	61 50       	subi	r22, 0x01	; 1
    158c:	70 40       	sbci	r23, 0x00	; 0
    158e:	01 90       	ld	r0, Z+
    1590:	01 10       	cpse	r0, r1
    1592:	d8 f7       	brcc	.-10     	; 0x158a <strnlen+0x2>
    1594:	80 95       	com	r24
    1596:	90 95       	com	r25
    1598:	8e 0f       	add	r24, r30
    159a:	9f 1f       	adc	r25, r31
    159c:	08 95       	ret

0000159e <fputc>:
    159e:	0f 93       	push	r16
    15a0:	1f 93       	push	r17
    15a2:	cf 93       	push	r28
    15a4:	df 93       	push	r29
    15a6:	18 2f       	mov	r17, r24
    15a8:	09 2f       	mov	r16, r25
    15aa:	eb 01       	movw	r28, r22
    15ac:	8b 81       	ldd	r24, Y+3	; 0x03
    15ae:	81 fd       	sbrc	r24, 1
    15b0:	03 c0       	rjmp	.+6      	; 0x15b8 <fputc+0x1a>
    15b2:	8f ef       	ldi	r24, 0xFF	; 255
    15b4:	9f ef       	ldi	r25, 0xFF	; 255
    15b6:	20 c0       	rjmp	.+64     	; 0x15f8 <fputc+0x5a>
    15b8:	82 ff       	sbrs	r24, 2
    15ba:	10 c0       	rjmp	.+32     	; 0x15dc <fputc+0x3e>
    15bc:	4e 81       	ldd	r20, Y+6	; 0x06
    15be:	5f 81       	ldd	r21, Y+7	; 0x07
    15c0:	2c 81       	ldd	r18, Y+4	; 0x04
    15c2:	3d 81       	ldd	r19, Y+5	; 0x05
    15c4:	42 17       	cp	r20, r18
    15c6:	53 07       	cpc	r21, r19
    15c8:	7c f4       	brge	.+30     	; 0x15e8 <fputc+0x4a>
    15ca:	e8 81       	ld	r30, Y
    15cc:	f9 81       	ldd	r31, Y+1	; 0x01
    15ce:	9f 01       	movw	r18, r30
    15d0:	2f 5f       	subi	r18, 0xFF	; 255
    15d2:	3f 4f       	sbci	r19, 0xFF	; 255
    15d4:	39 83       	std	Y+1, r19	; 0x01
    15d6:	28 83       	st	Y, r18
    15d8:	10 83       	st	Z, r17
    15da:	06 c0       	rjmp	.+12     	; 0x15e8 <fputc+0x4a>
    15dc:	e8 85       	ldd	r30, Y+8	; 0x08
    15de:	f9 85       	ldd	r31, Y+9	; 0x09
    15e0:	81 2f       	mov	r24, r17
    15e2:	09 95       	icall
    15e4:	89 2b       	or	r24, r25
    15e6:	29 f7       	brne	.-54     	; 0x15b2 <fputc+0x14>
    15e8:	2e 81       	ldd	r18, Y+6	; 0x06
    15ea:	3f 81       	ldd	r19, Y+7	; 0x07
    15ec:	2f 5f       	subi	r18, 0xFF	; 255
    15ee:	3f 4f       	sbci	r19, 0xFF	; 255
    15f0:	3f 83       	std	Y+7, r19	; 0x07
    15f2:	2e 83       	std	Y+6, r18	; 0x06
    15f4:	81 2f       	mov	r24, r17
    15f6:	90 2f       	mov	r25, r16
    15f8:	df 91       	pop	r29
    15fa:	cf 91       	pop	r28
    15fc:	1f 91       	pop	r17
    15fe:	0f 91       	pop	r16
    1600:	08 95       	ret

00001602 <__ultoa_invert>:
    1602:	fa 01       	movw	r30, r20
    1604:	aa 27       	eor	r26, r26
    1606:	28 30       	cpi	r18, 0x08	; 8
    1608:	51 f1       	breq	.+84     	; 0x165e <__ultoa_invert+0x5c>
    160a:	20 31       	cpi	r18, 0x10	; 16
    160c:	81 f1       	breq	.+96     	; 0x166e <__ultoa_invert+0x6c>
    160e:	e8 94       	clt
    1610:	6f 93       	push	r22
    1612:	6e 7f       	andi	r22, 0xFE	; 254
    1614:	6e 5f       	subi	r22, 0xFE	; 254
    1616:	7f 4f       	sbci	r23, 0xFF	; 255
    1618:	8f 4f       	sbci	r24, 0xFF	; 255
    161a:	9f 4f       	sbci	r25, 0xFF	; 255
    161c:	af 4f       	sbci	r26, 0xFF	; 255
    161e:	b1 e0       	ldi	r27, 0x01	; 1
    1620:	3e d0       	rcall	.+124    	; 0x169e <__ultoa_invert+0x9c>
    1622:	b4 e0       	ldi	r27, 0x04	; 4
    1624:	3c d0       	rcall	.+120    	; 0x169e <__ultoa_invert+0x9c>
    1626:	67 0f       	add	r22, r23
    1628:	78 1f       	adc	r23, r24
    162a:	89 1f       	adc	r24, r25
    162c:	9a 1f       	adc	r25, r26
    162e:	a1 1d       	adc	r26, r1
    1630:	68 0f       	add	r22, r24
    1632:	79 1f       	adc	r23, r25
    1634:	8a 1f       	adc	r24, r26
    1636:	91 1d       	adc	r25, r1
    1638:	a1 1d       	adc	r26, r1
    163a:	6a 0f       	add	r22, r26
    163c:	71 1d       	adc	r23, r1
    163e:	81 1d       	adc	r24, r1
    1640:	91 1d       	adc	r25, r1
    1642:	a1 1d       	adc	r26, r1
    1644:	20 d0       	rcall	.+64     	; 0x1686 <__ultoa_invert+0x84>
    1646:	09 f4       	brne	.+2      	; 0x164a <__ultoa_invert+0x48>
    1648:	68 94       	set
    164a:	3f 91       	pop	r19
    164c:	2a e0       	ldi	r18, 0x0A	; 10
    164e:	26 9f       	mul	r18, r22
    1650:	11 24       	eor	r1, r1
    1652:	30 19       	sub	r19, r0
    1654:	30 5d       	subi	r19, 0xD0	; 208
    1656:	31 93       	st	Z+, r19
    1658:	de f6       	brtc	.-74     	; 0x1610 <__ultoa_invert+0xe>
    165a:	cf 01       	movw	r24, r30
    165c:	08 95       	ret
    165e:	46 2f       	mov	r20, r22
    1660:	47 70       	andi	r20, 0x07	; 7
    1662:	40 5d       	subi	r20, 0xD0	; 208
    1664:	41 93       	st	Z+, r20
    1666:	b3 e0       	ldi	r27, 0x03	; 3
    1668:	0f d0       	rcall	.+30     	; 0x1688 <__ultoa_invert+0x86>
    166a:	c9 f7       	brne	.-14     	; 0x165e <__ultoa_invert+0x5c>
    166c:	f6 cf       	rjmp	.-20     	; 0x165a <__ultoa_invert+0x58>
    166e:	46 2f       	mov	r20, r22
    1670:	4f 70       	andi	r20, 0x0F	; 15
    1672:	40 5d       	subi	r20, 0xD0	; 208
    1674:	4a 33       	cpi	r20, 0x3A	; 58
    1676:	18 f0       	brcs	.+6      	; 0x167e <__ultoa_invert+0x7c>
    1678:	49 5d       	subi	r20, 0xD9	; 217
    167a:	31 fd       	sbrc	r19, 1
    167c:	40 52       	subi	r20, 0x20	; 32
    167e:	41 93       	st	Z+, r20
    1680:	02 d0       	rcall	.+4      	; 0x1686 <__ultoa_invert+0x84>
    1682:	a9 f7       	brne	.-22     	; 0x166e <__ultoa_invert+0x6c>
    1684:	ea cf       	rjmp	.-44     	; 0x165a <__ultoa_invert+0x58>
    1686:	b4 e0       	ldi	r27, 0x04	; 4
    1688:	a6 95       	lsr	r26
    168a:	97 95       	ror	r25
    168c:	87 95       	ror	r24
    168e:	77 95       	ror	r23
    1690:	67 95       	ror	r22
    1692:	ba 95       	dec	r27
    1694:	c9 f7       	brne	.-14     	; 0x1688 <__ultoa_invert+0x86>
    1696:	00 97       	sbiw	r24, 0x00	; 0
    1698:	61 05       	cpc	r22, r1
    169a:	71 05       	cpc	r23, r1
    169c:	08 95       	ret
    169e:	9b 01       	movw	r18, r22
    16a0:	ac 01       	movw	r20, r24
    16a2:	0a 2e       	mov	r0, r26
    16a4:	06 94       	lsr	r0
    16a6:	57 95       	ror	r21
    16a8:	47 95       	ror	r20
    16aa:	37 95       	ror	r19
    16ac:	27 95       	ror	r18
    16ae:	ba 95       	dec	r27
    16b0:	c9 f7       	brne	.-14     	; 0x16a4 <__ultoa_invert+0xa2>
    16b2:	62 0f       	add	r22, r18
    16b4:	73 1f       	adc	r23, r19
    16b6:	84 1f       	adc	r24, r20
    16b8:	95 1f       	adc	r25, r21
    16ba:	a0 1d       	adc	r26, r0
    16bc:	08 95       	ret

000016be <__prologue_saves__>:
    16be:	2f 92       	push	r2
    16c0:	3f 92       	push	r3
    16c2:	4f 92       	push	r4
    16c4:	5f 92       	push	r5
    16c6:	6f 92       	push	r6
    16c8:	7f 92       	push	r7
    16ca:	8f 92       	push	r8
    16cc:	9f 92       	push	r9
    16ce:	af 92       	push	r10
    16d0:	bf 92       	push	r11
    16d2:	cf 92       	push	r12
    16d4:	df 92       	push	r13
    16d6:	ef 92       	push	r14
    16d8:	ff 92       	push	r15
    16da:	0f 93       	push	r16
    16dc:	1f 93       	push	r17
    16de:	cf 93       	push	r28
    16e0:	df 93       	push	r29
    16e2:	cd b7       	in	r28, 0x3d	; 61
    16e4:	de b7       	in	r29, 0x3e	; 62
    16e6:	ca 1b       	sub	r28, r26
    16e8:	db 0b       	sbc	r29, r27
    16ea:	0f b6       	in	r0, 0x3f	; 63
    16ec:	f8 94       	cli
    16ee:	de bf       	out	0x3e, r29	; 62
    16f0:	0f be       	out	0x3f, r0	; 63
    16f2:	cd bf       	out	0x3d, r28	; 61
    16f4:	09 94       	ijmp

000016f6 <__epilogue_restores__>:
    16f6:	2a 88       	ldd	r2, Y+18	; 0x12
    16f8:	39 88       	ldd	r3, Y+17	; 0x11
    16fa:	48 88       	ldd	r4, Y+16	; 0x10
    16fc:	5f 84       	ldd	r5, Y+15	; 0x0f
    16fe:	6e 84       	ldd	r6, Y+14	; 0x0e
    1700:	7d 84       	ldd	r7, Y+13	; 0x0d
    1702:	8c 84       	ldd	r8, Y+12	; 0x0c
    1704:	9b 84       	ldd	r9, Y+11	; 0x0b
    1706:	aa 84       	ldd	r10, Y+10	; 0x0a
    1708:	b9 84       	ldd	r11, Y+9	; 0x09
    170a:	c8 84       	ldd	r12, Y+8	; 0x08
    170c:	df 80       	ldd	r13, Y+7	; 0x07
    170e:	ee 80       	ldd	r14, Y+6	; 0x06
    1710:	fd 80       	ldd	r15, Y+5	; 0x05
    1712:	0c 81       	ldd	r16, Y+4	; 0x04
    1714:	1b 81       	ldd	r17, Y+3	; 0x03
    1716:	aa 81       	ldd	r26, Y+2	; 0x02
    1718:	b9 81       	ldd	r27, Y+1	; 0x01
    171a:	ce 0f       	add	r28, r30
    171c:	d1 1d       	adc	r29, r1
    171e:	0f b6       	in	r0, 0x3f	; 63
    1720:	f8 94       	cli
    1722:	de bf       	out	0x3e, r29	; 62
    1724:	0f be       	out	0x3f, r0	; 63
    1726:	cd bf       	out	0x3d, r28	; 61
    1728:	ed 01       	movw	r28, r26
    172a:	08 95       	ret

0000172c <_exit>:
    172c:	f8 94       	cli

0000172e <__stop_program>:
    172e:	ff cf       	rjmp	.-2      	; 0x172e <__stop_program>
