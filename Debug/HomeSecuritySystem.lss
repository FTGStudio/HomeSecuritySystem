
HomeSecuritySystem.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000054  00800100  000017e6  0000187a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000017e6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000045e  00800154  00800154  000018ce  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  000018ce  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000380  00000000  00000000  0000192a  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00004394  00000000  00000000  00001caa  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00001034  00000000  00000000  0000603e  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00001929  00000000  00000000  00007072  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000a18  00000000  00000000  0000899c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    00001293  00000000  00000000  000093b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00003baf  00000000  00000000  0000a647  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000330  00000000  00000000  0000e1f6  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 07 03 	jmp	0x60e	; 0x60e <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e6 ee       	ldi	r30, 0xE6	; 230
      7c:	f7 e1       	ldi	r31, 0x17	; 23
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a4 35       	cpi	r26, 0x54	; 84
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	25 e0       	ldi	r18, 0x05	; 5
      8c:	a4 e5       	ldi	r26, 0x54	; 84
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	a2 3b       	cpi	r26, 0xB2	; 178
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 98 00 	call	0x130	; 0x130 <main>
      9e:	0c 94 f1 0b 	jmp	0x17e2	; 0x17e2 <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vHallEffectTask>:
#include "../Source/include/queue.h"

xQueueHandle hallEffectMsgQ;

void vHallEffectTask(void *pvParameters)
{
      a6:	cf 93       	push	r28
      a8:	df 93       	push	r29
      aa:	00 d0       	rcall	.+0      	; 0xac <vHallEffectTask+0x6>
      ac:	00 d0       	rcall	.+0      	; 0xae <vHallEffectTask+0x8>
      ae:	cd b7       	in	r28, 0x3d	; 61
      b0:	de b7       	in	r29, 0x3e	; 62
	HallEffectMsg_t msg;
	while(1)
	{
		if(xQueueReceive(hallEffectMsgQ, &msg, blockTime))
		{
			printf("Hall effect voltage %d", (int)msg.hallEffectData);
      b2:	0c e1       	ldi	r16, 0x1C	; 28
      b4:	11 e0       	ldi	r17, 0x01	; 1
{
	uint32_t blockTime = portMAX_DELAY;
	HallEffectMsg_t msg;
	while(1)
	{
		if(xQueueReceive(hallEffectMsgQ, &msg, blockTime))
      b6:	20 e0       	ldi	r18, 0x00	; 0
      b8:	4f ef       	ldi	r20, 0xFF	; 255
      ba:	5f ef       	ldi	r21, 0xFF	; 255
      bc:	be 01       	movw	r22, r28
      be:	6f 5f       	subi	r22, 0xFF	; 255
      c0:	7f 4f       	sbci	r23, 0xFF	; 255
      c2:	80 91 a4 05 	lds	r24, 0x05A4
      c6:	90 91 a5 05 	lds	r25, 0x05A5
      ca:	0e 94 0f 04 	call	0x81e	; 0x81e <xQueueGenericReceive>
      ce:	88 23       	and	r24, r24
      d0:	91 f3       	breq	.-28     	; 0xb6 <vHallEffectTask+0x10>
		{
			printf("Hall effect voltage %d", (int)msg.hallEffectData);
      d2:	8a 81       	ldd	r24, Y+2	; 0x02
      d4:	8f 93       	push	r24
      d6:	89 81       	ldd	r24, Y+1	; 0x01
      d8:	8f 93       	push	r24
      da:	1f 93       	push	r17
      dc:	0f 93       	push	r16
      de:	0e 94 2e 09 	call	0x125c	; 0x125c <printf>
      e2:	0f 90       	pop	r0
      e4:	0f 90       	pop	r0
      e6:	0f 90       	pop	r0
      e8:	0f 90       	pop	r0
      ea:	e5 cf       	rjmp	.-54     	; 0xb6 <vHallEffectTask+0x10>

000000ec <vLCDTask>:
#include "LCD.h"

xQueueHandle lcdMsgQ;

void vLCDTask(void *pvParameters)
{
      ec:	cf 93       	push	r28
      ee:	df 93       	push	r29
      f0:	00 d0       	rcall	.+0      	; 0xf2 <vLCDTask+0x6>
      f2:	cd b7       	in	r28, 0x3d	; 61
      f4:	de b7       	in	r29, 0x3e	; 62
	LCDMsg_t msg;
	while(1)
	{
		if(xQueueReceive(lcdMsgQ, &msg, blockTime))
		{
			printf("%s", msg.displayString);
      f6:	03 e3       	ldi	r16, 0x33	; 51
      f8:	11 e0       	ldi	r17, 0x01	; 1
{
	uint32_t blockTime = portMAX_DELAY;
	LCDMsg_t msg;
	while(1)
	{
		if(xQueueReceive(lcdMsgQ, &msg, blockTime))
      fa:	20 e0       	ldi	r18, 0x00	; 0
      fc:	4f ef       	ldi	r20, 0xFF	; 255
      fe:	5f ef       	ldi	r21, 0xFF	; 255
     100:	be 01       	movw	r22, r28
     102:	6f 5f       	subi	r22, 0xFF	; 255
     104:	7f 4f       	sbci	r23, 0xFF	; 255
     106:	80 91 a6 05 	lds	r24, 0x05A6
     10a:	90 91 a7 05 	lds	r25, 0x05A7
     10e:	0e 94 0f 04 	call	0x81e	; 0x81e <xQueueGenericReceive>
     112:	88 23       	and	r24, r24
     114:	91 f3       	breq	.-28     	; 0xfa <vLCDTask+0xe>
		{
			printf("%s", msg.displayString);
     116:	8a 81       	ldd	r24, Y+2	; 0x02
     118:	8f 93       	push	r24
     11a:	89 81       	ldd	r24, Y+1	; 0x01
     11c:	8f 93       	push	r24
     11e:	1f 93       	push	r17
     120:	0f 93       	push	r16
     122:	0e 94 2e 09 	call	0x125c	; 0x125c <printf>
     126:	0f 90       	pop	r0
     128:	0f 90       	pop	r0
     12a:	0f 90       	pop	r0
     12c:	0f 90       	pop	r0
     12e:	e5 cf       	rjmp	.-54     	; 0xfa <vLCDTask+0xe>

00000130 <main>:
#define MYUBRR						F_CPU/8/BAUD-1



int main(void)
{
     130:	af 92       	push	r10
     132:	bf 92       	push	r11
     134:	cf 92       	push	r12
     136:	df 92       	push	r13
     138:	ef 92       	push	r14
     13a:	ff 92       	push	r15
     13c:	0f 93       	push	r16
	
	USART_Init(MYUBRR);
     13e:	87 e6       	ldi	r24, 0x67	; 103
     140:	90 e0       	ldi	r25, 0x00	; 0
     142:	0e 94 ef 08 	call	0x11de	; 0x11de <USART_Init>
	stdout = &uart_output;
     146:	8e e0       	ldi	r24, 0x0E	; 14
     148:	91 e0       	ldi	r25, 0x01	; 1
     14a:	90 93 af 05 	sts	0x05AF, r25
     14e:	80 93 ae 05 	sts	0x05AE, r24
	stdin = &uart_input;
     152:	80 e0       	ldi	r24, 0x00	; 0
     154:	91 e0       	ldi	r25, 0x01	; 1
     156:	90 93 ad 05 	sts	0x05AD, r25
     15a:	80 93 ac 05 	sts	0x05AC, r24
	
	hallEffectMsgQ = xQueueCreate(2, sizeof(HallEffectMsg_t));
     15e:	40 e0       	ldi	r20, 0x00	; 0
     160:	64 e0       	ldi	r22, 0x04	; 4
     162:	82 e0       	ldi	r24, 0x02	; 2
     164:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <xQueueGenericCreate>
     168:	90 93 a5 05 	sts	0x05A5, r25
     16c:	80 93 a4 05 	sts	0x05A4, r24
	rtcMsgQ = xQueueCreate(2, sizeof(RTCMsg_t));
     170:	40 e0       	ldi	r20, 0x00	; 0
     172:	66 e0       	ldi	r22, 0x06	; 6
     174:	82 e0       	ldi	r24, 0x02	; 2
     176:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <xQueueGenericCreate>
     17a:	90 93 a9 05 	sts	0x05A9, r25
     17e:	80 93 a8 05 	sts	0x05A8, r24
	lcdMsgQ = xQueueCreate(2, sizeof(LCDMsg_t));
     182:	40 e0       	ldi	r20, 0x00	; 0
     184:	62 e0       	ldi	r22, 0x02	; 2
     186:	82 e0       	ldi	r24, 0x02	; 2
     188:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <xQueueGenericCreate>
     18c:	90 93 a7 05 	sts	0x05A7, r25
     190:	80 93 a6 05 	sts	0x05A6, r24
	wifiMsgQ = xQueueCreate(2, sizeof(WiFiMsg_t));
     194:	40 e0       	ldi	r20, 0x00	; 0
     196:	64 e0       	ldi	r22, 0x04	; 4
     198:	82 e0       	ldi	r24, 0x02	; 2
     19a:	0e 94 e1 03 	call	0x7c2	; 0x7c2 <xQueueGenericCreate>
     19e:	90 93 ab 05 	sts	0x05AB, r25
     1a2:	80 93 aa 05 	sts	0x05AA, r24
	
	xTaskCreate( vRTCTask, ( signed char * ) "RTC", configMINIMAL_STACK_SIZE, NULL, 1, NULL );
     1a6:	a1 2c       	mov	r10, r1
     1a8:	b1 2c       	mov	r11, r1
     1aa:	c1 2c       	mov	r12, r1
     1ac:	d1 2c       	mov	r13, r1
     1ae:	e1 2c       	mov	r14, r1
     1b0:	f1 2c       	mov	r15, r1
     1b2:	01 e0       	ldi	r16, 0x01	; 1
     1b4:	20 e0       	ldi	r18, 0x00	; 0
     1b6:	30 e0       	ldi	r19, 0x00	; 0
     1b8:	45 e5       	ldi	r20, 0x55	; 85
     1ba:	50 e0       	ldi	r21, 0x00	; 0
     1bc:	66 e3       	ldi	r22, 0x36	; 54
     1be:	71 e0       	ldi	r23, 0x01	; 1
     1c0:	8e e0       	ldi	r24, 0x0E	; 14
     1c2:	91 e0       	ldi	r25, 0x01	; 1
     1c4:	0e 94 11 05 	call	0xa22	; 0xa22 <xTaskGenericCreate>
	xTaskCreate( vHallEffectTask, ( signed char * ) "HallEffect", configMINIMAL_STACK_SIZE, NULL, 1, NULL );
     1c8:	20 e0       	ldi	r18, 0x00	; 0
     1ca:	30 e0       	ldi	r19, 0x00	; 0
     1cc:	45 e5       	ldi	r20, 0x55	; 85
     1ce:	50 e0       	ldi	r21, 0x00	; 0
     1d0:	6a e3       	ldi	r22, 0x3A	; 58
     1d2:	71 e0       	ldi	r23, 0x01	; 1
     1d4:	83 e5       	ldi	r24, 0x53	; 83
     1d6:	90 e0       	ldi	r25, 0x00	; 0
     1d8:	0e 94 11 05 	call	0xa22	; 0xa22 <xTaskGenericCreate>
	xTaskCreate( vLCDTask, ( signed char * ) "LCD", configMINIMAL_STACK_SIZE, NULL, 1, NULL );
     1dc:	20 e0       	ldi	r18, 0x00	; 0
     1de:	30 e0       	ldi	r19, 0x00	; 0
     1e0:	45 e5       	ldi	r20, 0x55	; 85
     1e2:	50 e0       	ldi	r21, 0x00	; 0
     1e4:	65 e4       	ldi	r22, 0x45	; 69
     1e6:	71 e0       	ldi	r23, 0x01	; 1
     1e8:	86 e7       	ldi	r24, 0x76	; 118
     1ea:	90 e0       	ldi	r25, 0x00	; 0
     1ec:	0e 94 11 05 	call	0xa22	; 0xa22 <xTaskGenericCreate>
	xTaskCreate( vWifiTask, ( signed char * ) "WiFi", configMINIMAL_STACK_SIZE, NULL, 1, NULL );
     1f0:	20 e0       	ldi	r18, 0x00	; 0
     1f2:	30 e0       	ldi	r19, 0x00	; 0
     1f4:	45 e5       	ldi	r20, 0x55	; 85
     1f6:	50 e0       	ldi	r21, 0x00	; 0
     1f8:	69 e4       	ldi	r22, 0x49	; 73
     1fa:	71 e0       	ldi	r23, 0x01	; 1
     1fc:	82 e1       	ldi	r24, 0x12	; 18
     1fe:	99 e0       	ldi	r25, 0x09	; 9
     200:	0e 94 11 05 	call	0xa22	; 0xa22 <xTaskGenericCreate>
	
	vTaskStartScheduler();
     204:	0e 94 1f 06 	call	0xc3e	; 0xc3e <vTaskStartScheduler>
     208:	80 e0       	ldi	r24, 0x00	; 0
     20a:	90 e0       	ldi	r25, 0x00	; 0
     20c:	0f 91       	pop	r16
     20e:	ff 90       	pop	r15
     210:	ef 90       	pop	r14
     212:	df 90       	pop	r13
     214:	cf 90       	pop	r12
     216:	bf 90       	pop	r11
     218:	af 90       	pop	r10
     21a:	08 95       	ret

0000021c <vRTCTask>:
#include "../Source/include/queue.h"

xQueueHandle rtcMsgQ;

void vRTCTask( void *pvParameters )
{
     21c:	cf 93       	push	r28
     21e:	df 93       	push	r29
     220:	00 d0       	rcall	.+0      	; 0x222 <vRTCTask+0x6>
     222:	00 d0       	rcall	.+0      	; 0x224 <vRTCTask+0x8>
     224:	00 d0       	rcall	.+0      	; 0x226 <vRTCTask+0xa>
     226:	cd b7       	in	r28, 0x3d	; 61
     228:	de b7       	in	r29, 0x3e	; 62
	uint32_t blockTime = portMAX_DELAY;
	RTCMsg_t msg;
	while(1)
	{
		if(xQueueReceive(rtcMsgQ, &msg, blockTime))
     22a:	20 e0       	ldi	r18, 0x00	; 0
     22c:	4f ef       	ldi	r20, 0xFF	; 255
     22e:	5f ef       	ldi	r21, 0xFF	; 255
     230:	be 01       	movw	r22, r28
     232:	6f 5f       	subi	r22, 0xFF	; 255
     234:	7f 4f       	sbci	r23, 0xFF	; 255
     236:	80 91 a8 05 	lds	r24, 0x05A8
     23a:	90 91 a9 05 	lds	r25, 0x05A9
     23e:	0e 94 0f 04 	call	0x81e	; 0x81e <xQueueGenericReceive>
     242:	f3 cf       	rjmp	.-26     	; 0x22a <vRTCTask+0xe>

00000244 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     244:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     246:	03 96       	adiw	r24, 0x03	; 3
     248:	92 83       	std	Z+2, r25	; 0x02
     24a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     24c:	2f ef       	ldi	r18, 0xFF	; 255
     24e:	3f ef       	ldi	r19, 0xFF	; 255
     250:	34 83       	std	Z+4, r19	; 0x04
     252:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     254:	96 83       	std	Z+6, r25	; 0x06
     256:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     258:	90 87       	std	Z+8, r25	; 0x08
     25a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     25c:	10 82       	st	Z, r1
     25e:	08 95       	ret

00000260 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     260:	fc 01       	movw	r30, r24
     262:	11 86       	std	Z+9, r1	; 0x09
     264:	10 86       	std	Z+8, r1	; 0x08
     266:	08 95       	ret

00000268 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     268:	cf 93       	push	r28
     26a:	df 93       	push	r29
     26c:	9c 01       	movw	r18, r24
     26e:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     270:	dc 01       	movw	r26, r24
     272:	11 96       	adiw	r26, 0x01	; 1
     274:	cd 91       	ld	r28, X+
     276:	dc 91       	ld	r29, X
     278:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     27a:	d3 83       	std	Z+3, r29	; 0x03
     27c:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     27e:	8c 81       	ldd	r24, Y+4	; 0x04
     280:	9d 81       	ldd	r25, Y+5	; 0x05
     282:	95 83       	std	Z+5, r25	; 0x05
     284:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     286:	8c 81       	ldd	r24, Y+4	; 0x04
     288:	9d 81       	ldd	r25, Y+5	; 0x05
     28a:	dc 01       	movw	r26, r24
     28c:	13 96       	adiw	r26, 0x03	; 3
     28e:	7c 93       	st	X, r23
     290:	6e 93       	st	-X, r22
     292:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     294:	7d 83       	std	Y+5, r23	; 0x05
     296:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     298:	31 87       	std	Z+9, r19	; 0x09
     29a:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     29c:	f9 01       	movw	r30, r18
     29e:	80 81       	ld	r24, Z
     2a0:	8f 5f       	subi	r24, 0xFF	; 255
     2a2:	80 83       	st	Z, r24
}
     2a4:	df 91       	pop	r29
     2a6:	cf 91       	pop	r28
     2a8:	08 95       	ret

000002aa <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     2aa:	cf 93       	push	r28
     2ac:	df 93       	push	r29
     2ae:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     2b0:	48 81       	ld	r20, Y
     2b2:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     2b4:	4f 3f       	cpi	r20, 0xFF	; 255
     2b6:	2f ef       	ldi	r18, 0xFF	; 255
     2b8:	52 07       	cpc	r21, r18
     2ba:	21 f4       	brne	.+8      	; 0x2c4 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     2bc:	fc 01       	movw	r30, r24
     2be:	a7 81       	ldd	r26, Z+7	; 0x07
     2c0:	b0 85       	ldd	r27, Z+8	; 0x08
     2c2:	0d c0       	rjmp	.+26     	; 0x2de <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2c4:	dc 01       	movw	r26, r24
     2c6:	13 96       	adiw	r26, 0x03	; 3
     2c8:	12 96       	adiw	r26, 0x02	; 2
     2ca:	ed 91       	ld	r30, X+
     2cc:	fc 91       	ld	r31, X
     2ce:	13 97       	sbiw	r26, 0x03	; 3
     2d0:	20 81       	ld	r18, Z
     2d2:	31 81       	ldd	r19, Z+1	; 0x01
     2d4:	42 17       	cp	r20, r18
     2d6:	53 07       	cpc	r21, r19
     2d8:	10 f0       	brcs	.+4      	; 0x2de <vListInsert+0x34>
     2da:	df 01       	movw	r26, r30
     2dc:	f5 cf       	rjmp	.-22     	; 0x2c8 <vListInsert+0x1e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     2de:	12 96       	adiw	r26, 0x02	; 2
     2e0:	ed 91       	ld	r30, X+
     2e2:	fc 91       	ld	r31, X
     2e4:	13 97       	sbiw	r26, 0x03	; 3
     2e6:	fb 83       	std	Y+3, r31	; 0x03
     2e8:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     2ea:	d5 83       	std	Z+5, r29	; 0x05
     2ec:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     2ee:	bd 83       	std	Y+5, r27	; 0x05
     2f0:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     2f2:	13 96       	adiw	r26, 0x03	; 3
     2f4:	dc 93       	st	X, r29
     2f6:	ce 93       	st	-X, r28
     2f8:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     2fa:	99 87       	std	Y+9, r25	; 0x09
     2fc:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     2fe:	fc 01       	movw	r30, r24
     300:	20 81       	ld	r18, Z
     302:	2f 5f       	subi	r18, 0xFF	; 255
     304:	20 83       	st	Z, r18
}
     306:	df 91       	pop	r29
     308:	cf 91       	pop	r28
     30a:	08 95       	ret

0000030c <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     30c:	cf 93       	push	r28
     30e:	df 93       	push	r29
     310:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     312:	a0 85       	ldd	r26, Z+8	; 0x08
     314:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     316:	c2 81       	ldd	r28, Z+2	; 0x02
     318:	d3 81       	ldd	r29, Z+3	; 0x03
     31a:	84 81       	ldd	r24, Z+4	; 0x04
     31c:	95 81       	ldd	r25, Z+5	; 0x05
     31e:	9d 83       	std	Y+5, r25	; 0x05
     320:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     322:	c4 81       	ldd	r28, Z+4	; 0x04
     324:	d5 81       	ldd	r29, Z+5	; 0x05
     326:	82 81       	ldd	r24, Z+2	; 0x02
     328:	93 81       	ldd	r25, Z+3	; 0x03
     32a:	9b 83       	std	Y+3, r25	; 0x03
     32c:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     32e:	11 96       	adiw	r26, 0x01	; 1
     330:	cd 91       	ld	r28, X+
     332:	dc 91       	ld	r29, X
     334:	12 97       	sbiw	r26, 0x02	; 2
     336:	ce 17       	cp	r28, r30
     338:	df 07       	cpc	r29, r31
     33a:	31 f4       	brne	.+12     	; 0x348 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     33c:	8c 81       	ldd	r24, Y+4	; 0x04
     33e:	9d 81       	ldd	r25, Y+5	; 0x05
     340:	12 96       	adiw	r26, 0x02	; 2
     342:	9c 93       	st	X, r25
     344:	8e 93       	st	-X, r24
     346:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     348:	11 86       	std	Z+9, r1	; 0x09
     34a:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     34c:	8c 91       	ld	r24, X
     34e:	81 50       	subi	r24, 0x01	; 1
     350:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     352:	df 91       	pop	r29
     354:	cf 91       	pop	r28
     356:	08 95       	ret

00000358 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     358:	31 e1       	ldi	r19, 0x11	; 17
     35a:	fc 01       	movw	r30, r24
     35c:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     35e:	31 97       	sbiw	r30, 0x01	; 1
     360:	22 e2       	ldi	r18, 0x22	; 34
     362:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     364:	31 97       	sbiw	r30, 0x01	; 1
     366:	a3 e3       	ldi	r26, 0x33	; 51
     368:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     36a:	31 97       	sbiw	r30, 0x01	; 1
     36c:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     36e:	31 97       	sbiw	r30, 0x01	; 1
     370:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     372:	31 97       	sbiw	r30, 0x01	; 1
     374:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     376:	31 97       	sbiw	r30, 0x01	; 1
     378:	60 e8       	ldi	r22, 0x80	; 128
     37a:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     37c:	31 97       	sbiw	r30, 0x01	; 1
     37e:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     380:	31 97       	sbiw	r30, 0x01	; 1
     382:	62 e0       	ldi	r22, 0x02	; 2
     384:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     386:	31 97       	sbiw	r30, 0x01	; 1
     388:	63 e0       	ldi	r22, 0x03	; 3
     38a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     38c:	31 97       	sbiw	r30, 0x01	; 1
     38e:	64 e0       	ldi	r22, 0x04	; 4
     390:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     392:	31 97       	sbiw	r30, 0x01	; 1
     394:	65 e0       	ldi	r22, 0x05	; 5
     396:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     398:	31 97       	sbiw	r30, 0x01	; 1
     39a:	66 e0       	ldi	r22, 0x06	; 6
     39c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     39e:	31 97       	sbiw	r30, 0x01	; 1
     3a0:	67 e0       	ldi	r22, 0x07	; 7
     3a2:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     3a4:	31 97       	sbiw	r30, 0x01	; 1
     3a6:	68 e0       	ldi	r22, 0x08	; 8
     3a8:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     3aa:	31 97       	sbiw	r30, 0x01	; 1
     3ac:	69 e0       	ldi	r22, 0x09	; 9
     3ae:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     3b0:	31 97       	sbiw	r30, 0x01	; 1
     3b2:	60 e1       	ldi	r22, 0x10	; 16
     3b4:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     3b6:	31 97       	sbiw	r30, 0x01	; 1
     3b8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     3ba:	31 97       	sbiw	r30, 0x01	; 1
     3bc:	32 e1       	ldi	r19, 0x12	; 18
     3be:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     3c0:	31 97       	sbiw	r30, 0x01	; 1
     3c2:	33 e1       	ldi	r19, 0x13	; 19
     3c4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     3c6:	31 97       	sbiw	r30, 0x01	; 1
     3c8:	34 e1       	ldi	r19, 0x14	; 20
     3ca:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     3cc:	31 97       	sbiw	r30, 0x01	; 1
     3ce:	35 e1       	ldi	r19, 0x15	; 21
     3d0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     3d2:	31 97       	sbiw	r30, 0x01	; 1
     3d4:	36 e1       	ldi	r19, 0x16	; 22
     3d6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     3d8:	31 97       	sbiw	r30, 0x01	; 1
     3da:	37 e1       	ldi	r19, 0x17	; 23
     3dc:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     3de:	31 97       	sbiw	r30, 0x01	; 1
     3e0:	38 e1       	ldi	r19, 0x18	; 24
     3e2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     3e4:	31 97       	sbiw	r30, 0x01	; 1
     3e6:	39 e1       	ldi	r19, 0x19	; 25
     3e8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     3ea:	31 97       	sbiw	r30, 0x01	; 1
     3ec:	30 e2       	ldi	r19, 0x20	; 32
     3ee:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     3f0:	31 97       	sbiw	r30, 0x01	; 1
     3f2:	31 e2       	ldi	r19, 0x21	; 33
     3f4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     3f6:	31 97       	sbiw	r30, 0x01	; 1
     3f8:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     3fa:	31 97       	sbiw	r30, 0x01	; 1
     3fc:	23 e2       	ldi	r18, 0x23	; 35
     3fe:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     400:	31 97       	sbiw	r30, 0x01	; 1
     402:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     404:	31 97       	sbiw	r30, 0x01	; 1
     406:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     408:	31 97       	sbiw	r30, 0x01	; 1
     40a:	26 e2       	ldi	r18, 0x26	; 38
     40c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     40e:	31 97       	sbiw	r30, 0x01	; 1
     410:	27 e2       	ldi	r18, 0x27	; 39
     412:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     414:	31 97       	sbiw	r30, 0x01	; 1
     416:	28 e2       	ldi	r18, 0x28	; 40
     418:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     41a:	31 97       	sbiw	r30, 0x01	; 1
     41c:	29 e2       	ldi	r18, 0x29	; 41
     41e:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     420:	31 97       	sbiw	r30, 0x01	; 1
     422:	20 e3       	ldi	r18, 0x30	; 48
     424:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     426:	31 97       	sbiw	r30, 0x01	; 1
     428:	21 e3       	ldi	r18, 0x31	; 49
     42a:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     42c:	86 97       	sbiw	r24, 0x26	; 38
     42e:	08 95       	ret

00000430 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
     430:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
     434:	8c e7       	ldi	r24, 0x7C	; 124
     436:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     43a:	8b e0       	ldi	r24, 0x0B	; 11
     43c:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
     440:	ef e6       	ldi	r30, 0x6F	; 111
     442:	f0 e0       	ldi	r31, 0x00	; 0
     444:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     446:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
     448:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     44a:	a0 91 a2 05 	lds	r26, 0x05A2
     44e:	b0 91 a3 05 	lds	r27, 0x05A3
     452:	cd 91       	ld	r28, X+
     454:	cd bf       	out	0x3d, r28	; 61
     456:	dd 91       	ld	r29, X+
     458:	de bf       	out	0x3e, r29	; 62
     45a:	ff 91       	pop	r31
     45c:	ef 91       	pop	r30
     45e:	df 91       	pop	r29
     460:	cf 91       	pop	r28
     462:	bf 91       	pop	r27
     464:	af 91       	pop	r26
     466:	9f 91       	pop	r25
     468:	8f 91       	pop	r24
     46a:	7f 91       	pop	r23
     46c:	6f 91       	pop	r22
     46e:	5f 91       	pop	r21
     470:	4f 91       	pop	r20
     472:	3f 91       	pop	r19
     474:	2f 91       	pop	r18
     476:	1f 91       	pop	r17
     478:	0f 91       	pop	r16
     47a:	ff 90       	pop	r15
     47c:	ef 90       	pop	r14
     47e:	df 90       	pop	r13
     480:	cf 90       	pop	r12
     482:	bf 90       	pop	r11
     484:	af 90       	pop	r10
     486:	9f 90       	pop	r9
     488:	8f 90       	pop	r8
     48a:	7f 90       	pop	r7
     48c:	6f 90       	pop	r6
     48e:	5f 90       	pop	r5
     490:	4f 90       	pop	r4
     492:	3f 90       	pop	r3
     494:	2f 90       	pop	r2
     496:	1f 90       	pop	r1
     498:	0f 90       	pop	r0
     49a:	0f be       	out	0x3f, r0	; 63
     49c:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     49e:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     4a0:	81 e0       	ldi	r24, 0x01	; 1
     4a2:	08 95       	ret

000004a4 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     4a4:	0f 92       	push	r0
     4a6:	0f b6       	in	r0, 0x3f	; 63
     4a8:	f8 94       	cli
     4aa:	0f 92       	push	r0
     4ac:	1f 92       	push	r1
     4ae:	11 24       	eor	r1, r1
     4b0:	2f 92       	push	r2
     4b2:	3f 92       	push	r3
     4b4:	4f 92       	push	r4
     4b6:	5f 92       	push	r5
     4b8:	6f 92       	push	r6
     4ba:	7f 92       	push	r7
     4bc:	8f 92       	push	r8
     4be:	9f 92       	push	r9
     4c0:	af 92       	push	r10
     4c2:	bf 92       	push	r11
     4c4:	cf 92       	push	r12
     4c6:	df 92       	push	r13
     4c8:	ef 92       	push	r14
     4ca:	ff 92       	push	r15
     4cc:	0f 93       	push	r16
     4ce:	1f 93       	push	r17
     4d0:	2f 93       	push	r18
     4d2:	3f 93       	push	r19
     4d4:	4f 93       	push	r20
     4d6:	5f 93       	push	r21
     4d8:	6f 93       	push	r22
     4da:	7f 93       	push	r23
     4dc:	8f 93       	push	r24
     4de:	9f 93       	push	r25
     4e0:	af 93       	push	r26
     4e2:	bf 93       	push	r27
     4e4:	cf 93       	push	r28
     4e6:	df 93       	push	r29
     4e8:	ef 93       	push	r30
     4ea:	ff 93       	push	r31
     4ec:	a0 91 a2 05 	lds	r26, 0x05A2
     4f0:	b0 91 a3 05 	lds	r27, 0x05A3
     4f4:	0d b6       	in	r0, 0x3d	; 61
     4f6:	0d 92       	st	X+, r0
     4f8:	0e b6       	in	r0, 0x3e	; 62
     4fa:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     4fc:	0e 94 d5 07 	call	0xfaa	; 0xfaa <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     500:	a0 91 a2 05 	lds	r26, 0x05A2
     504:	b0 91 a3 05 	lds	r27, 0x05A3
     508:	cd 91       	ld	r28, X+
     50a:	cd bf       	out	0x3d, r28	; 61
     50c:	dd 91       	ld	r29, X+
     50e:	de bf       	out	0x3e, r29	; 62
     510:	ff 91       	pop	r31
     512:	ef 91       	pop	r30
     514:	df 91       	pop	r29
     516:	cf 91       	pop	r28
     518:	bf 91       	pop	r27
     51a:	af 91       	pop	r26
     51c:	9f 91       	pop	r25
     51e:	8f 91       	pop	r24
     520:	7f 91       	pop	r23
     522:	6f 91       	pop	r22
     524:	5f 91       	pop	r21
     526:	4f 91       	pop	r20
     528:	3f 91       	pop	r19
     52a:	2f 91       	pop	r18
     52c:	1f 91       	pop	r17
     52e:	0f 91       	pop	r16
     530:	ff 90       	pop	r15
     532:	ef 90       	pop	r14
     534:	df 90       	pop	r13
     536:	cf 90       	pop	r12
     538:	bf 90       	pop	r11
     53a:	af 90       	pop	r10
     53c:	9f 90       	pop	r9
     53e:	8f 90       	pop	r8
     540:	7f 90       	pop	r7
     542:	6f 90       	pop	r6
     544:	5f 90       	pop	r5
     546:	4f 90       	pop	r4
     548:	3f 90       	pop	r3
     54a:	2f 90       	pop	r2
     54c:	1f 90       	pop	r1
     54e:	0f 90       	pop	r0
     550:	0f be       	out	0x3f, r0	; 63
     552:	0f 90       	pop	r0

	asm volatile ( "ret" );
     554:	08 95       	ret

00000556 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     556:	0f 92       	push	r0
     558:	0f b6       	in	r0, 0x3f	; 63
     55a:	f8 94       	cli
     55c:	0f 92       	push	r0
     55e:	1f 92       	push	r1
     560:	11 24       	eor	r1, r1
     562:	2f 92       	push	r2
     564:	3f 92       	push	r3
     566:	4f 92       	push	r4
     568:	5f 92       	push	r5
     56a:	6f 92       	push	r6
     56c:	7f 92       	push	r7
     56e:	8f 92       	push	r8
     570:	9f 92       	push	r9
     572:	af 92       	push	r10
     574:	bf 92       	push	r11
     576:	cf 92       	push	r12
     578:	df 92       	push	r13
     57a:	ef 92       	push	r14
     57c:	ff 92       	push	r15
     57e:	0f 93       	push	r16
     580:	1f 93       	push	r17
     582:	2f 93       	push	r18
     584:	3f 93       	push	r19
     586:	4f 93       	push	r20
     588:	5f 93       	push	r21
     58a:	6f 93       	push	r22
     58c:	7f 93       	push	r23
     58e:	8f 93       	push	r24
     590:	9f 93       	push	r25
     592:	af 93       	push	r26
     594:	bf 93       	push	r27
     596:	cf 93       	push	r28
     598:	df 93       	push	r29
     59a:	ef 93       	push	r30
     59c:	ff 93       	push	r31
     59e:	a0 91 a2 05 	lds	r26, 0x05A2
     5a2:	b0 91 a3 05 	lds	r27, 0x05A3
     5a6:	0d b6       	in	r0, 0x3d	; 61
     5a8:	0d 92       	st	X+, r0
     5aa:	0e b6       	in	r0, 0x3e	; 62
     5ac:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     5ae:	0e 94 57 06 	call	0xcae	; 0xcae <xTaskIncrementTick>
     5b2:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     5b4:	0e 94 d5 07 	call	0xfaa	; 0xfaa <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     5b8:	a0 91 a2 05 	lds	r26, 0x05A2
     5bc:	b0 91 a3 05 	lds	r27, 0x05A3
     5c0:	cd 91       	ld	r28, X+
     5c2:	cd bf       	out	0x3d, r28	; 61
     5c4:	dd 91       	ld	r29, X+
     5c6:	de bf       	out	0x3e, r29	; 62
     5c8:	ff 91       	pop	r31
     5ca:	ef 91       	pop	r30
     5cc:	df 91       	pop	r29
     5ce:	cf 91       	pop	r28
     5d0:	bf 91       	pop	r27
     5d2:	af 91       	pop	r26
     5d4:	9f 91       	pop	r25
     5d6:	8f 91       	pop	r24
     5d8:	7f 91       	pop	r23
     5da:	6f 91       	pop	r22
     5dc:	5f 91       	pop	r21
     5de:	4f 91       	pop	r20
     5e0:	3f 91       	pop	r19
     5e2:	2f 91       	pop	r18
     5e4:	1f 91       	pop	r17
     5e6:	0f 91       	pop	r16
     5e8:	ff 90       	pop	r15
     5ea:	ef 90       	pop	r14
     5ec:	df 90       	pop	r13
     5ee:	cf 90       	pop	r12
     5f0:	bf 90       	pop	r11
     5f2:	af 90       	pop	r10
     5f4:	9f 90       	pop	r9
     5f6:	8f 90       	pop	r8
     5f8:	7f 90       	pop	r7
     5fa:	6f 90       	pop	r6
     5fc:	5f 90       	pop	r5
     5fe:	4f 90       	pop	r4
     600:	3f 90       	pop	r3
     602:	2f 90       	pop	r2
     604:	1f 90       	pop	r1
     606:	0f 90       	pop	r0
     608:	0f be       	out	0x3f, r0	; 63
     60a:	0f 90       	pop	r0

	asm volatile ( "ret" );
     60c:	08 95       	ret

0000060e <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     60e:	0e 94 ab 02 	call	0x556	; 0x556 <vPortYieldFromTick>
		asm volatile ( "reti" );
     612:	18 95       	reti

00000614 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     614:	cf 93       	push	r28
     616:	df 93       	push	r29
     618:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     61a:	0e 94 51 06 	call	0xca2	; 0xca2 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     61e:	80 91 54 01 	lds	r24, 0x0154
     622:	90 91 55 01 	lds	r25, 0x0155
     626:	89 2b       	or	r24, r25
     628:	31 f4       	brne	.+12     	; 0x636 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     62a:	89 e5       	ldi	r24, 0x59	; 89
     62c:	91 e0       	ldi	r25, 0x01	; 1
     62e:	90 93 55 01 	sts	0x0155, r25
     632:	80 93 54 01 	sts	0x0154, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     636:	40 91 56 01 	lds	r20, 0x0156
     63a:	50 91 57 01 	lds	r21, 0x0157
     63e:	9e 01       	movw	r18, r28
     640:	24 0f       	add	r18, r20
     642:	35 1f       	adc	r19, r21
     644:	27 3e       	cpi	r18, 0xE7	; 231
     646:	83 e0       	ldi	r24, 0x03	; 3
     648:	38 07       	cpc	r19, r24
     64a:	70 f4       	brcc	.+28     	; 0x668 <pvPortMalloc+0x54>
     64c:	42 17       	cp	r20, r18
     64e:	53 07       	cpc	r21, r19
     650:	70 f4       	brcc	.+28     	; 0x66e <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     652:	c0 91 54 01 	lds	r28, 0x0154
     656:	d0 91 55 01 	lds	r29, 0x0155
     65a:	c4 0f       	add	r28, r20
     65c:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     65e:	30 93 57 01 	sts	0x0157, r19
     662:	20 93 56 01 	sts	0x0156, r18
     666:	05 c0       	rjmp	.+10     	; 0x672 <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     668:	c0 e0       	ldi	r28, 0x00	; 0
     66a:	d0 e0       	ldi	r29, 0x00	; 0
     66c:	02 c0       	rjmp	.+4      	; 0x672 <pvPortMalloc+0x5e>
     66e:	c0 e0       	ldi	r28, 0x00	; 0
     670:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     672:	0e 94 16 07 	call	0xe2c	; 0xe2c <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     676:	ce 01       	movw	r24, r28
     678:	df 91       	pop	r29
     67a:	cf 91       	pop	r28
     67c:	08 95       	ret

0000067e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     67e:	08 95       	ret

00000680 <prvCopyDataFromQueue>:
	return xReturn;
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
     680:	fc 01       	movw	r30, r24
     682:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     684:	44 8d       	ldd	r20, Z+28	; 0x1c
     686:	44 23       	and	r20, r20
     688:	a1 f0       	breq	.+40     	; 0x6b2 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     68a:	50 e0       	ldi	r21, 0x00	; 0
     68c:	26 81       	ldd	r18, Z+6	; 0x06
     68e:	37 81       	ldd	r19, Z+7	; 0x07
     690:	24 0f       	add	r18, r20
     692:	35 1f       	adc	r19, r21
     694:	37 83       	std	Z+7, r19	; 0x07
     696:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     698:	62 81       	ldd	r22, Z+2	; 0x02
     69a:	73 81       	ldd	r23, Z+3	; 0x03
     69c:	26 17       	cp	r18, r22
     69e:	37 07       	cpc	r19, r23
     6a0:	20 f0       	brcs	.+8      	; 0x6aa <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     6a2:	20 81       	ld	r18, Z
     6a4:	31 81       	ldd	r19, Z+1	; 0x01
     6a6:	37 83       	std	Z+7, r19	; 0x07
     6a8:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     6aa:	66 81       	ldd	r22, Z+6	; 0x06
     6ac:	77 81       	ldd	r23, Z+7	; 0x07
     6ae:	0e 94 25 09 	call	0x124a	; 0x124a <memcpy>
     6b2:	08 95       	ret

000006b4 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
     6b4:	0f 93       	push	r16
     6b6:	1f 93       	push	r17
     6b8:	cf 93       	push	r28
     6ba:	df 93       	push	r29
     6bc:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     6be:	0f b6       	in	r0, 0x3f	; 63
     6c0:	f8 94       	cli
     6c2:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     6c4:	8e 8d       	ldd	r24, Y+30	; 0x1e
     6c6:	18 16       	cp	r1, r24
     6c8:	b4 f4       	brge	.+44     	; 0x6f6 <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     6ca:	89 89       	ldd	r24, Y+17	; 0x11
     6cc:	88 23       	and	r24, r24
     6ce:	99 f0       	breq	.+38     	; 0x6f6 <prvUnlockQueue+0x42>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     6d0:	8e 01       	movw	r16, r28
     6d2:	0f 5e       	subi	r16, 0xEF	; 239
     6d4:	1f 4f       	sbci	r17, 0xFF	; 255
     6d6:	03 c0       	rjmp	.+6      	; 0x6de <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     6d8:	89 89       	ldd	r24, Y+17	; 0x11
     6da:	88 23       	and	r24, r24
     6dc:	61 f0       	breq	.+24     	; 0x6f6 <prvUnlockQueue+0x42>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     6de:	c8 01       	movw	r24, r16
     6e0:	0e 94 5f 08 	call	0x10be	; 0x10be <xTaskRemoveFromEventList>
     6e4:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
     6e6:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
     6ea:	8e 8d       	ldd	r24, Y+30	; 0x1e
     6ec:	81 50       	subi	r24, 0x01	; 1
     6ee:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     6f0:	8e 8d       	ldd	r24, Y+30	; 0x1e
     6f2:	18 16       	cp	r1, r24
     6f4:	8c f3       	brlt	.-30     	; 0x6d8 <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
     6f6:	8f ef       	ldi	r24, 0xFF	; 255
     6f8:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     6fa:	0f 90       	pop	r0
     6fc:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     6fe:	0f b6       	in	r0, 0x3f	; 63
     700:	f8 94       	cli
     702:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     704:	8d 8d       	ldd	r24, Y+29	; 0x1d
     706:	18 16       	cp	r1, r24
     708:	b4 f4       	brge	.+44     	; 0x736 <prvUnlockQueue+0x82>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     70a:	88 85       	ldd	r24, Y+8	; 0x08
     70c:	88 23       	and	r24, r24
     70e:	99 f0       	breq	.+38     	; 0x736 <prvUnlockQueue+0x82>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     710:	8e 01       	movw	r16, r28
     712:	08 5f       	subi	r16, 0xF8	; 248
     714:	1f 4f       	sbci	r17, 0xFF	; 255
     716:	03 c0       	rjmp	.+6      	; 0x71e <prvUnlockQueue+0x6a>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     718:	88 85       	ldd	r24, Y+8	; 0x08
     71a:	88 23       	and	r24, r24
     71c:	61 f0       	breq	.+24     	; 0x736 <prvUnlockQueue+0x82>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     71e:	c8 01       	movw	r24, r16
     720:	0e 94 5f 08 	call	0x10be	; 0x10be <xTaskRemoveFromEventList>
     724:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
     726:	0e 94 eb 08 	call	0x11d6	; 0x11d6 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
     72a:	8d 8d       	ldd	r24, Y+29	; 0x1d
     72c:	81 50       	subi	r24, 0x01	; 1
     72e:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     730:	8d 8d       	ldd	r24, Y+29	; 0x1d
     732:	18 16       	cp	r1, r24
     734:	8c f3       	brlt	.-30     	; 0x718 <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     736:	8f ef       	ldi	r24, 0xFF	; 255
     738:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     73a:	0f 90       	pop	r0
     73c:	0f be       	out	0x3f, r0	; 63
}
     73e:	df 91       	pop	r29
     740:	cf 91       	pop	r28
     742:	1f 91       	pop	r17
     744:	0f 91       	pop	r16
     746:	08 95       	ret

00000748 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
     748:	cf 93       	push	r28
     74a:	df 93       	push	r29
     74c:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     74e:	0f b6       	in	r0, 0x3f	; 63
     750:	f8 94       	cli
     752:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     754:	88 81       	ld	r24, Y
     756:	99 81       	ldd	r25, Y+1	; 0x01
     758:	2c 8d       	ldd	r18, Y+28	; 0x1c
     75a:	30 e0       	ldi	r19, 0x00	; 0
     75c:	7b 8d       	ldd	r23, Y+27	; 0x1b
     75e:	72 9f       	mul	r23, r18
     760:	a0 01       	movw	r20, r0
     762:	73 9f       	mul	r23, r19
     764:	50 0d       	add	r21, r0
     766:	11 24       	eor	r1, r1
     768:	fc 01       	movw	r30, r24
     76a:	e4 0f       	add	r30, r20
     76c:	f5 1f       	adc	r31, r21
     76e:	fb 83       	std	Y+3, r31	; 0x03
     770:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     772:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     774:	9d 83       	std	Y+5, r25	; 0x05
     776:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
     778:	42 1b       	sub	r20, r18
     77a:	53 0b       	sbc	r21, r19
     77c:	84 0f       	add	r24, r20
     77e:	95 1f       	adc	r25, r21
     780:	9f 83       	std	Y+7, r25	; 0x07
     782:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
     784:	8f ef       	ldi	r24, 0xFF	; 255
     786:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
     788:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     78a:	61 11       	cpse	r22, r1
     78c:	0c c0       	rjmp	.+24     	; 0x7a6 <xQueueGenericReset+0x5e>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     78e:	88 85       	ldd	r24, Y+8	; 0x08
     790:	88 23       	and	r24, r24
     792:	89 f0       	breq	.+34     	; 0x7b6 <xQueueGenericReset+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     794:	ce 01       	movw	r24, r28
     796:	08 96       	adiw	r24, 0x08	; 8
     798:	0e 94 5f 08 	call	0x10be	; 0x10be <xTaskRemoveFromEventList>
     79c:	81 30       	cpi	r24, 0x01	; 1
     79e:	59 f4       	brne	.+22     	; 0x7b6 <xQueueGenericReset+0x6e>
				{
					queueYIELD_IF_USING_PREEMPTION();
     7a0:	0e 94 52 02 	call	0x4a4	; 0x4a4 <vPortYield>
     7a4:	08 c0       	rjmp	.+16     	; 0x7b6 <xQueueGenericReset+0x6e>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     7a6:	ce 01       	movw	r24, r28
     7a8:	08 96       	adiw	r24, 0x08	; 8
     7aa:	0e 94 22 01 	call	0x244	; 0x244 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     7ae:	ce 01       	movw	r24, r28
     7b0:	41 96       	adiw	r24, 0x11	; 17
     7b2:	0e 94 22 01 	call	0x244	; 0x244 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
     7b6:	0f 90       	pop	r0
     7b8:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
     7ba:	81 e0       	ldi	r24, 0x01	; 1
     7bc:	df 91       	pop	r29
     7be:	cf 91       	pop	r28
     7c0:	08 95       	ret

000007c2 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
     7c2:	0f 93       	push	r16
     7c4:	1f 93       	push	r17
     7c6:	cf 93       	push	r28
     7c8:	df 93       	push	r29
     7ca:	08 2f       	mov	r16, r24
     7cc:	16 2f       	mov	r17, r22
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

	if( uxItemSize == ( UBaseType_t ) 0 )
     7ce:	66 23       	and	r22, r22
     7d0:	c9 f0       	breq	.+50     	; 0x804 <xQueueGenericCreate+0x42>
	}
	else
	{
		/* The queue is one byte longer than asked for to make wrap checking
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     7d2:	86 9f       	mul	r24, r22
     7d4:	c0 01       	movw	r24, r0
     7d6:	11 24       	eor	r1, r1
	}

	/* Allocate the new queue structure and storage area. */
	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     7d8:	80 96       	adiw	r24, 0x20	; 32
     7da:	0e 94 0a 03 	call	0x614	; 0x614 <pvPortMalloc>
     7de:	ec 01       	movw	r28, r24

	if( pxNewQueue != NULL )
     7e0:	00 97       	sbiw	r24, 0x00	; 0
     7e2:	21 f4       	brne	.+8      	; 0x7ec <xQueueGenericCreate+0x2a>
     7e4:	16 c0       	rjmp	.+44     	; 0x812 <xQueueGenericCreate+0x50>
		{
			/* No RAM was allocated for the queue storage area, but PC head
			cannot be set to NULL because NULL is used as a key to say the queue
			is used as a mutex.  Therefore just set pcHead to point to the queue
			as a benign value that is known to be within the memory map. */
			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
     7e6:	d9 83       	std	Y+1, r29	; 0x01
     7e8:	c8 83       	st	Y, r28
     7ea:	05 c0       	rjmp	.+10     	; 0x7f6 <xQueueGenericCreate+0x34>
		}
		else
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pxNewQueue->pcHead = ( ( int8_t * ) pxNewQueue ) + sizeof( Queue_t );
     7ec:	9c 01       	movw	r18, r24
     7ee:	21 5e       	subi	r18, 0xE1	; 225
     7f0:	3f 4f       	sbci	r19, 0xFF	; 255
     7f2:	39 83       	std	Y+1, r19	; 0x01
     7f4:	28 83       	st	Y, r18
		}

		/* Initialise the queue members as described above where the queue type
		is defined. */
		pxNewQueue->uxLength = uxQueueLength;
     7f6:	0b 8f       	std	Y+27, r16	; 0x1b
		pxNewQueue->uxItemSize = uxItemSize;
     7f8:	1c 8f       	std	Y+28, r17	; 0x1c
		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
     7fa:	61 e0       	ldi	r22, 0x01	; 1
     7fc:	ce 01       	movw	r24, r28
     7fe:	0e 94 a4 03 	call	0x748	; 0x748 <xQueueGenericReset>
     802:	07 c0       	rjmp	.+14     	; 0x812 <xQueueGenericCreate+0x50>
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
	}

	/* Allocate the new queue structure and storage area. */
	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     804:	8f e1       	ldi	r24, 0x1F	; 31
     806:	90 e0       	ldi	r25, 0x00	; 0
     808:	0e 94 0a 03 	call	0x614	; 0x614 <pvPortMalloc>
     80c:	ec 01       	movw	r28, r24

	if( pxNewQueue != NULL )
     80e:	00 97       	sbiw	r24, 0x00	; 0
     810:	51 f7       	brne	.-44     	; 0x7e6 <xQueueGenericCreate+0x24>
	}

	configASSERT( xReturn );

	return xReturn;
}
     812:	ce 01       	movw	r24, r28
     814:	df 91       	pop	r29
     816:	cf 91       	pop	r28
     818:	1f 91       	pop	r17
     81a:	0f 91       	pop	r16
     81c:	08 95       	ret

0000081e <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     81e:	9f 92       	push	r9
     820:	af 92       	push	r10
     822:	bf 92       	push	r11
     824:	cf 92       	push	r12
     826:	df 92       	push	r13
     828:	ef 92       	push	r14
     82a:	ff 92       	push	r15
     82c:	0f 93       	push	r16
     82e:	1f 93       	push	r17
     830:	cf 93       	push	r28
     832:	df 93       	push	r29
     834:	00 d0       	rcall	.+0      	; 0x836 <xQueueGenericReceive+0x18>
     836:	00 d0       	rcall	.+0      	; 0x838 <xQueueGenericReceive+0x1a>
     838:	1f 92       	push	r1
     83a:	cd b7       	in	r28, 0x3d	; 61
     83c:	de b7       	in	r29, 0x3e	; 62
     83e:	8c 01       	movw	r16, r24
     840:	6b 01       	movw	r12, r22
     842:	5d 83       	std	Y+5, r21	; 0x05
     844:	4c 83       	std	Y+4, r20	; 0x04
     846:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
     848:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     84a:	99 24       	eor	r9, r9
     84c:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     84e:	7c 01       	movw	r14, r24
     850:	81 e1       	ldi	r24, 0x11	; 17
     852:	e8 0e       	add	r14, r24
     854:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     856:	0f b6       	in	r0, 0x3f	; 63
     858:	f8 94       	cli
     85a:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     85c:	f8 01       	movw	r30, r16
     85e:	82 8d       	ldd	r24, Z+26	; 0x1a
     860:	88 23       	and	r24, r24
     862:	49 f1       	breq	.+82     	; 0x8b6 <xQueueGenericReceive+0x98>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     864:	e6 80       	ldd	r14, Z+6	; 0x06
     866:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     868:	b6 01       	movw	r22, r12
     86a:	c8 01       	movw	r24, r16
     86c:	0e 94 40 03 	call	0x680	; 0x680 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     870:	b1 10       	cpse	r11, r1
     872:	10 c0       	rjmp	.+32     	; 0x894 <xQueueGenericReceive+0x76>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
     874:	f8 01       	movw	r30, r16
     876:	82 8d       	ldd	r24, Z+26	; 0x1a
     878:	81 50       	subi	r24, 0x01	; 1
     87a:	82 8f       	std	Z+26, r24	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     87c:	80 85       	ldd	r24, Z+8	; 0x08
     87e:	88 23       	and	r24, r24
     880:	b1 f0       	breq	.+44     	; 0x8ae <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     882:	c8 01       	movw	r24, r16
     884:	08 96       	adiw	r24, 0x08	; 8
     886:	0e 94 5f 08 	call	0x10be	; 0x10be <xTaskRemoveFromEventList>
     88a:	81 30       	cpi	r24, 0x01	; 1
     88c:	81 f4       	brne	.+32     	; 0x8ae <xQueueGenericReceive+0x90>
						{
							queueYIELD_IF_USING_PREEMPTION();
     88e:	0e 94 52 02 	call	0x4a4	; 0x4a4 <vPortYield>
     892:	0d c0       	rjmp	.+26     	; 0x8ae <xQueueGenericReceive+0x90>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     894:	f8 01       	movw	r30, r16
     896:	f7 82       	std	Z+7, r15	; 0x07
     898:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     89a:	81 89       	ldd	r24, Z+17	; 0x11
     89c:	88 23       	and	r24, r24
     89e:	39 f0       	breq	.+14     	; 0x8ae <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     8a0:	c8 01       	movw	r24, r16
     8a2:	41 96       	adiw	r24, 0x11	; 17
     8a4:	0e 94 5f 08 	call	0x10be	; 0x10be <xTaskRemoveFromEventList>
     8a8:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     8aa:	0e 94 52 02 	call	0x4a4	; 0x4a4 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     8ae:	0f 90       	pop	r0
     8b0:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     8b2:	81 e0       	ldi	r24, 0x01	; 1
     8b4:	4f c0       	rjmp	.+158    	; 0x954 <__stack+0x55>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     8b6:	4c 81       	ldd	r20, Y+4	; 0x04
     8b8:	5d 81       	ldd	r21, Y+5	; 0x05
     8ba:	45 2b       	or	r20, r21
     8bc:	21 f4       	brne	.+8      	; 0x8c6 <xQueueGenericReceive+0xa8>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     8be:	0f 90       	pop	r0
     8c0:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     8c2:	80 e0       	ldi	r24, 0x00	; 0
     8c4:	47 c0       	rjmp	.+142    	; 0x954 <__stack+0x55>
				}
				else if( xEntryTimeSet == pdFALSE )
     8c6:	a1 10       	cpse	r10, r1
     8c8:	05 c0       	rjmp	.+10     	; 0x8d4 <xQueueGenericReceive+0xb6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     8ca:	ce 01       	movw	r24, r28
     8cc:	01 96       	adiw	r24, 0x01	; 1
     8ce:	0e 94 a7 08 	call	0x114e	; 0x114e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     8d2:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     8d4:	0f 90       	pop	r0
     8d6:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     8d8:	0e 94 51 06 	call	0xca2	; 0xca2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     8dc:	0f b6       	in	r0, 0x3f	; 63
     8de:	f8 94       	cli
     8e0:	0f 92       	push	r0
     8e2:	f8 01       	movw	r30, r16
     8e4:	85 8d       	ldd	r24, Z+29	; 0x1d
     8e6:	8f 3f       	cpi	r24, 0xFF	; 255
     8e8:	09 f4       	brne	.+2      	; 0x8ec <xQueueGenericReceive+0xce>
     8ea:	15 8e       	std	Z+29, r1	; 0x1d
     8ec:	f8 01       	movw	r30, r16
     8ee:	86 8d       	ldd	r24, Z+30	; 0x1e
     8f0:	8f 3f       	cpi	r24, 0xFF	; 255
     8f2:	09 f4       	brne	.+2      	; 0x8f6 <xQueueGenericReceive+0xd8>
     8f4:	16 8e       	std	Z+30, r1	; 0x1e
     8f6:	0f 90       	pop	r0
     8f8:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     8fa:	be 01       	movw	r22, r28
     8fc:	6c 5f       	subi	r22, 0xFC	; 252
     8fe:	7f 4f       	sbci	r23, 0xFF	; 255
     900:	ce 01       	movw	r24, r28
     902:	01 96       	adiw	r24, 0x01	; 1
     904:	0e 94 b2 08 	call	0x1164	; 0x1164 <xTaskCheckForTimeOut>
     908:	81 11       	cpse	r24, r1
     90a:	1e c0       	rjmp	.+60     	; 0x948 <__stack+0x49>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     90c:	0f b6       	in	r0, 0x3f	; 63
     90e:	f8 94       	cli
     910:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     912:	f8 01       	movw	r30, r16
     914:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     916:	0f 90       	pop	r0
     918:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     91a:	81 11       	cpse	r24, r1
     91c:	0f c0       	rjmp	.+30     	; 0x93c <__stack+0x3d>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     91e:	6c 81       	ldd	r22, Y+4	; 0x04
     920:	7d 81       	ldd	r23, Y+5	; 0x05
     922:	c7 01       	movw	r24, r14
     924:	0e 94 33 08 	call	0x1066	; 0x1066 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     928:	c8 01       	movw	r24, r16
     92a:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     92e:	0e 94 16 07 	call	0xe2c	; 0xe2c <xTaskResumeAll>
     932:	81 11       	cpse	r24, r1
     934:	90 cf       	rjmp	.-224    	; 0x856 <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
     936:	0e 94 52 02 	call	0x4a4	; 0x4a4 <vPortYield>
     93a:	8d cf       	rjmp	.-230    	; 0x856 <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     93c:	c8 01       	movw	r24, r16
     93e:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     942:	0e 94 16 07 	call	0xe2c	; 0xe2c <xTaskResumeAll>
     946:	87 cf       	rjmp	.-242    	; 0x856 <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     948:	c8 01       	movw	r24, r16
     94a:	0e 94 5a 03 	call	0x6b4	; 0x6b4 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     94e:	0e 94 16 07 	call	0xe2c	; 0xe2c <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
     952:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     954:	0f 90       	pop	r0
     956:	0f 90       	pop	r0
     958:	0f 90       	pop	r0
     95a:	0f 90       	pop	r0
     95c:	0f 90       	pop	r0
     95e:	df 91       	pop	r29
     960:	cf 91       	pop	r28
     962:	1f 91       	pop	r17
     964:	0f 91       	pop	r16
     966:	ff 90       	pop	r15
     968:	ef 90       	pop	r14
     96a:	df 90       	pop	r13
     96c:	cf 90       	pop	r12
     96e:	bf 90       	pop	r11
     970:	af 90       	pop	r10
     972:	9f 90       	pop	r9
     974:	08 95       	ret

00000976 <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     976:	e0 91 6a 05 	lds	r30, 0x056A
     97a:	f0 91 6b 05 	lds	r31, 0x056B
     97e:	80 81       	ld	r24, Z
     980:	81 11       	cpse	r24, r1
     982:	07 c0       	rjmp	.+14     	; 0x992 <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     984:	8f ef       	ldi	r24, 0xFF	; 255
     986:	9f ef       	ldi	r25, 0xFF	; 255
     988:	90 93 42 05 	sts	0x0542, r25
     98c:	80 93 41 05 	sts	0x0541, r24
     990:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     992:	e0 91 6a 05 	lds	r30, 0x056A
     996:	f0 91 6b 05 	lds	r31, 0x056B
     99a:	05 80       	ldd	r0, Z+5	; 0x05
     99c:	f6 81       	ldd	r31, Z+6	; 0x06
     99e:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
     9a0:	06 80       	ldd	r0, Z+6	; 0x06
     9a2:	f7 81       	ldd	r31, Z+7	; 0x07
     9a4:	e0 2d       	mov	r30, r0
     9a6:	82 81       	ldd	r24, Z+2	; 0x02
     9a8:	93 81       	ldd	r25, Z+3	; 0x03
     9aa:	90 93 42 05 	sts	0x0542, r25
     9ae:	80 93 41 05 	sts	0x0541, r24
     9b2:	08 95       	ret

000009b4 <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
     9b4:	cf 93       	push	r28
     9b6:	df 93       	push	r29
     9b8:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
     9ba:	e0 91 a2 05 	lds	r30, 0x05A2
     9be:	f0 91 a3 05 	lds	r31, 0x05A3
     9c2:	93 83       	std	Z+3, r25	; 0x03
     9c4:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
     9c6:	80 91 49 05 	lds	r24, 0x0549
     9ca:	90 91 4a 05 	lds	r25, 0x054A
     9ce:	c8 17       	cp	r28, r24
     9d0:	d9 07       	cpc	r29, r25
     9d2:	68 f4       	brcc	.+26     	; 0x9ee <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     9d4:	60 91 a2 05 	lds	r22, 0x05A2
     9d8:	70 91 a3 05 	lds	r23, 0x05A3
     9dc:	80 91 68 05 	lds	r24, 0x0568
     9e0:	90 91 69 05 	lds	r25, 0x0569
     9e4:	6e 5f       	subi	r22, 0xFE	; 254
     9e6:	7f 4f       	sbci	r23, 0xFF	; 255
     9e8:	0e 94 55 01 	call	0x2aa	; 0x2aa <vListInsert>
     9ec:	17 c0       	rjmp	.+46     	; 0xa1c <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     9ee:	60 91 a2 05 	lds	r22, 0x05A2
     9f2:	70 91 a3 05 	lds	r23, 0x05A3
     9f6:	80 91 6a 05 	lds	r24, 0x056A
     9fa:	90 91 6b 05 	lds	r25, 0x056B
     9fe:	6e 5f       	subi	r22, 0xFE	; 254
     a00:	7f 4f       	sbci	r23, 0xFF	; 255
     a02:	0e 94 55 01 	call	0x2aa	; 0x2aa <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
     a06:	80 91 41 05 	lds	r24, 0x0541
     a0a:	90 91 42 05 	lds	r25, 0x0542
     a0e:	c8 17       	cp	r28, r24
     a10:	d9 07       	cpc	r29, r25
     a12:	20 f4       	brcc	.+8      	; 0xa1c <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
     a14:	d0 93 42 05 	sts	0x0542, r29
     a18:	c0 93 41 05 	sts	0x0541, r28
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     a1c:	df 91       	pop	r29
     a1e:	cf 91       	pop	r28
     a20:	08 95       	ret

00000a22 <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
     a22:	4f 92       	push	r4
     a24:	5f 92       	push	r5
     a26:	6f 92       	push	r6
     a28:	7f 92       	push	r7
     a2a:	8f 92       	push	r8
     a2c:	9f 92       	push	r9
     a2e:	af 92       	push	r10
     a30:	bf 92       	push	r11
     a32:	cf 92       	push	r12
     a34:	df 92       	push	r13
     a36:	ef 92       	push	r14
     a38:	ff 92       	push	r15
     a3a:	0f 93       	push	r16
     a3c:	1f 93       	push	r17
     a3e:	cf 93       	push	r28
     a40:	df 93       	push	r29
     a42:	4c 01       	movw	r8, r24
     a44:	5b 01       	movw	r10, r22
     a46:	2a 01       	movw	r4, r20
     a48:	39 01       	movw	r6, r18
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     a4a:	c1 14       	cp	r12, r1
     a4c:	d1 04       	cpc	r13, r1
     a4e:	39 f4       	brne	.+14     	; 0xa5e <xTaskGenericCreate+0x3c>
     a50:	ca 01       	movw	r24, r20
     a52:	0e 94 0a 03 	call	0x614	; 0x614 <pvPortMalloc>
     a56:	6c 01       	movw	r12, r24

		if( pxStack != NULL )
     a58:	00 97       	sbiw	r24, 0x00	; 0
     a5a:	09 f4       	brne	.+2      	; 0xa5e <xTaskGenericCreate+0x3c>
     a5c:	de c0       	rjmp	.+444    	; 0xc1a <xTaskGenericCreate+0x1f8>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
     a5e:	86 e2       	ldi	r24, 0x26	; 38
     a60:	90 e0       	ldi	r25, 0x00	; 0
     a62:	0e 94 0a 03 	call	0x614	; 0x614 <pvPortMalloc>
     a66:	ec 01       	movw	r28, r24

			if( pxNewTCB != NULL )
     a68:	00 97       	sbiw	r24, 0x00	; 0
     a6a:	71 f0       	breq	.+28     	; 0xa88 <xTaskGenericCreate+0x66>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
     a6c:	d8 8e       	std	Y+24, r13	; 0x18
     a6e:	cf 8a       	std	Y+23, r12	; 0x17
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
     a70:	81 e0       	ldi	r24, 0x01	; 1
     a72:	48 1a       	sub	r4, r24
     a74:	51 08       	sbc	r5, r1
     a76:	c4 0c       	add	r12, r4
     a78:	d5 1c       	adc	r13, r5
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
     a7a:	d5 01       	movw	r26, r10
     a7c:	8c 91       	ld	r24, X
     a7e:	89 8f       	std	Y+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     a80:	8c 91       	ld	r24, X
     a82:	81 11       	cpse	r24, r1
     a84:	05 c0       	rjmp	.+10     	; 0xa90 <xTaskGenericCreate+0x6e>
     a86:	15 c0       	rjmp	.+42     	; 0xab2 <xTaskGenericCreate+0x90>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
     a88:	c6 01       	movw	r24, r12
     a8a:	0e 94 3f 03 	call	0x67e	; 0x67e <vPortFree>
     a8e:	c5 c0       	rjmp	.+394    	; 0xc1a <xTaskGenericCreate+0x1f8>
     a90:	ae 01       	movw	r20, r28
     a92:	46 5e       	subi	r20, 0xE6	; 230
     a94:	5f 4f       	sbci	r21, 0xFF	; 255
     a96:	f5 01       	movw	r30, r10
     a98:	31 96       	adiw	r30, 0x01	; 1
		pxTCB->pcTaskName[ x ] = pcName[ x ];

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     a9a:	27 e0       	ldi	r18, 0x07	; 7
     a9c:	cf 01       	movw	r24, r30
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
     a9e:	31 91       	ld	r19, Z+
     aa0:	da 01       	movw	r26, r20
     aa2:	3d 93       	st	X+, r19
     aa4:	ad 01       	movw	r20, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     aa6:	dc 01       	movw	r26, r24
     aa8:	8c 91       	ld	r24, X
     aaa:	88 23       	and	r24, r24
     aac:	11 f0       	breq	.+4      	; 0xab2 <xTaskGenericCreate+0x90>
     aae:	21 50       	subi	r18, 0x01	; 1
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     ab0:	a9 f7       	brne	.-22     	; 0xa9c <xTaskGenericCreate+0x7a>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     ab2:	18 a2       	std	Y+32, r1	; 0x20
     ab4:	10 2f       	mov	r17, r16
     ab6:	04 30       	cpi	r16, 0x04	; 4
     ab8:	08 f0       	brcs	.+2      	; 0xabc <xTaskGenericCreate+0x9a>
     aba:	13 e0       	ldi	r17, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
     abc:	1e 8b       	std	Y+22, r17	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
     abe:	5e 01       	movw	r10, r28
     ac0:	b2 e0       	ldi	r27, 0x02	; 2
     ac2:	ab 0e       	add	r10, r27
     ac4:	b1 1c       	adc	r11, r1
     ac6:	c5 01       	movw	r24, r10
     ac8:	0e 94 30 01 	call	0x260	; 0x260 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
     acc:	ce 01       	movw	r24, r28
     ace:	0c 96       	adiw	r24, 0x0c	; 12
     ad0:	0e 94 30 01 	call	0x260	; 0x260 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
     ad4:	d9 87       	std	Y+9, r29	; 0x09
     ad6:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     ad8:	84 e0       	ldi	r24, 0x04	; 4
     ada:	90 e0       	ldi	r25, 0x00	; 0
     adc:	81 1b       	sub	r24, r17
     ade:	91 09       	sbc	r25, r1
     ae0:	9d 87       	std	Y+13, r25	; 0x0d
     ae2:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
     ae4:	db 8b       	std	Y+19, r29	; 0x13
     ae6:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
     ae8:	19 a2       	std	Y+33, r1	; 0x21
     aea:	1a a2       	std	Y+34, r1	; 0x22
     aec:	1b a2       	std	Y+35, r1	; 0x23
     aee:	1c a2       	std	Y+36, r1	; 0x24
		pxTCB->eNotifyState = eNotWaitingNotification;
     af0:	1d a2       	std	Y+37, r1	; 0x25
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     af2:	a3 01       	movw	r20, r6
     af4:	b4 01       	movw	r22, r8
     af6:	c6 01       	movw	r24, r12
     af8:	0e 94 ac 01 	call	0x358	; 0x358 <pxPortInitialiseStack>
     afc:	99 83       	std	Y+1, r25	; 0x01
     afe:	88 83       	st	Y, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
     b00:	e1 14       	cp	r14, r1
     b02:	f1 04       	cpc	r15, r1
     b04:	19 f0       	breq	.+6      	; 0xb0c <xTaskGenericCreate+0xea>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     b06:	f7 01       	movw	r30, r14
     b08:	d1 83       	std	Z+1, r29	; 0x01
     b0a:	c0 83       	st	Z, r28
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
     b0c:	0f b6       	in	r0, 0x3f	; 63
     b0e:	f8 94       	cli
     b10:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
     b12:	80 91 4b 05 	lds	r24, 0x054B
     b16:	8f 5f       	subi	r24, 0xFF	; 255
     b18:	80 93 4b 05 	sts	0x054B, r24
			if( pxCurrentTCB == NULL )
     b1c:	80 91 a2 05 	lds	r24, 0x05A2
     b20:	90 91 a3 05 	lds	r25, 0x05A3
     b24:	89 2b       	or	r24, r25
     b26:	d1 f5       	brne	.+116    	; 0xb9c <xTaskGenericCreate+0x17a>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
     b28:	d0 93 a3 05 	sts	0x05A3, r29
     b2c:	c0 93 a2 05 	sts	0x05A2, r28

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     b30:	80 91 4b 05 	lds	r24, 0x054B
     b34:	81 30       	cpi	r24, 0x01	; 1
     b36:	09 f0       	breq	.+2      	; 0xb3a <xTaskGenericCreate+0x118>
     b38:	40 c0       	rjmp	.+128    	; 0xbba <xTaskGenericCreate+0x198>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     b3a:	8e e7       	ldi	r24, 0x7E	; 126
     b3c:	95 e0       	ldi	r25, 0x05	; 5
     b3e:	0e 94 22 01 	call	0x244	; 0x244 <vListInitialise>
     b42:	87 e8       	ldi	r24, 0x87	; 135
     b44:	95 e0       	ldi	r25, 0x05	; 5
     b46:	0e 94 22 01 	call	0x244	; 0x244 <vListInitialise>
     b4a:	80 e9       	ldi	r24, 0x90	; 144
     b4c:	95 e0       	ldi	r25, 0x05	; 5
     b4e:	0e 94 22 01 	call	0x244	; 0x244 <vListInitialise>
     b52:	89 e9       	ldi	r24, 0x99	; 153
     b54:	95 e0       	ldi	r25, 0x05	; 5
     b56:	0e 94 22 01 	call	0x244	; 0x244 <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     b5a:	85 e7       	ldi	r24, 0x75	; 117
     b5c:	95 e0       	ldi	r25, 0x05	; 5
     b5e:	0e 94 22 01 	call	0x244	; 0x244 <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     b62:	8c e6       	ldi	r24, 0x6C	; 108
     b64:	95 e0       	ldi	r25, 0x05	; 5
     b66:	0e 94 22 01 	call	0x244	; 0x244 <vListInitialise>
	vListInitialise( &xPendingReadyList );
     b6a:	8f e5       	ldi	r24, 0x5F	; 95
     b6c:	95 e0       	ldi	r25, 0x05	; 5
     b6e:	0e 94 22 01 	call	0x244	; 0x244 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     b72:	86 e5       	ldi	r24, 0x56	; 86
     b74:	95 e0       	ldi	r25, 0x05	; 5
     b76:	0e 94 22 01 	call	0x244	; 0x244 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
     b7a:	8c e4       	ldi	r24, 0x4C	; 76
     b7c:	95 e0       	ldi	r25, 0x05	; 5
     b7e:	0e 94 22 01 	call	0x244	; 0x244 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     b82:	85 e7       	ldi	r24, 0x75	; 117
     b84:	95 e0       	ldi	r25, 0x05	; 5
     b86:	90 93 6b 05 	sts	0x056B, r25
     b8a:	80 93 6a 05 	sts	0x056A, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     b8e:	8c e6       	ldi	r24, 0x6C	; 108
     b90:	95 e0       	ldi	r25, 0x05	; 5
     b92:	90 93 69 05 	sts	0x0569, r25
     b96:	80 93 68 05 	sts	0x0568, r24
     b9a:	0f c0       	rjmp	.+30     	; 0xbba <xTaskGenericCreate+0x198>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
     b9c:	80 91 47 05 	lds	r24, 0x0547
     ba0:	81 11       	cpse	r24, r1
     ba2:	0b c0       	rjmp	.+22     	; 0xbba <xTaskGenericCreate+0x198>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
     ba4:	e0 91 a2 05 	lds	r30, 0x05A2
     ba8:	f0 91 a3 05 	lds	r31, 0x05A3
     bac:	86 89       	ldd	r24, Z+22	; 0x16
     bae:	08 17       	cp	r16, r24
     bb0:	20 f0       	brcs	.+8      	; 0xbba <xTaskGenericCreate+0x198>
					{
						pxCurrentTCB = pxNewTCB;
     bb2:	d0 93 a3 05 	sts	0x05A3, r29
     bb6:	c0 93 a2 05 	sts	0x05A2, r28
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
     bba:	80 91 43 05 	lds	r24, 0x0543
     bbe:	8f 5f       	subi	r24, 0xFF	; 255
     bc0:	80 93 43 05 	sts	0x0543, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
     bc4:	8e 89       	ldd	r24, Y+22	; 0x16
     bc6:	90 91 48 05 	lds	r25, 0x0548
     bca:	98 17       	cp	r25, r24
     bcc:	10 f4       	brcc	.+4      	; 0xbd2 <xTaskGenericCreate+0x1b0>
     bce:	80 93 48 05 	sts	0x0548, r24
     bd2:	90 e0       	ldi	r25, 0x00	; 0
     bd4:	9c 01       	movw	r18, r24
     bd6:	22 0f       	add	r18, r18
     bd8:	33 1f       	adc	r19, r19
     bda:	22 0f       	add	r18, r18
     bdc:	33 1f       	adc	r19, r19
     bde:	22 0f       	add	r18, r18
     be0:	33 1f       	adc	r19, r19
     be2:	82 0f       	add	r24, r18
     be4:	93 1f       	adc	r25, r19
     be6:	b5 01       	movw	r22, r10
     be8:	82 58       	subi	r24, 0x82	; 130
     bea:	9a 4f       	sbci	r25, 0xFA	; 250
     bec:	0e 94 34 01 	call	0x268	; 0x268 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
     bf0:	0f 90       	pop	r0
     bf2:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
     bf4:	80 91 47 05 	lds	r24, 0x0547
     bf8:	88 23       	and	r24, r24
     bfa:	59 f0       	breq	.+22     	; 0xc12 <xTaskGenericCreate+0x1f0>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
     bfc:	e0 91 a2 05 	lds	r30, 0x05A2
     c00:	f0 91 a3 05 	lds	r31, 0x05A3
     c04:	86 89       	ldd	r24, Z+22	; 0x16
     c06:	80 17       	cp	r24, r16
     c08:	30 f4       	brcc	.+12     	; 0xc16 <xTaskGenericCreate+0x1f4>
			{
				taskYIELD_IF_USING_PREEMPTION();
     c0a:	0e 94 52 02 	call	0x4a4	; 0x4a4 <vPortYield>
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );

			xReturn = pdPASS;
     c0e:	81 e0       	ldi	r24, 0x01	; 1
     c10:	05 c0       	rjmp	.+10     	; 0xc1c <xTaskGenericCreate+0x1fa>
     c12:	81 e0       	ldi	r24, 0x01	; 1
     c14:	03 c0       	rjmp	.+6      	; 0xc1c <xTaskGenericCreate+0x1fa>
     c16:	81 e0       	ldi	r24, 0x01	; 1
     c18:	01 c0       	rjmp	.+2      	; 0xc1c <xTaskGenericCreate+0x1fa>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     c1a:	8f ef       	ldi	r24, 0xFF	; 255
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
     c1c:	df 91       	pop	r29
     c1e:	cf 91       	pop	r28
     c20:	1f 91       	pop	r17
     c22:	0f 91       	pop	r16
     c24:	ff 90       	pop	r15
     c26:	ef 90       	pop	r14
     c28:	df 90       	pop	r13
     c2a:	cf 90       	pop	r12
     c2c:	bf 90       	pop	r11
     c2e:	af 90       	pop	r10
     c30:	9f 90       	pop	r9
     c32:	8f 90       	pop	r8
     c34:	7f 90       	pop	r7
     c36:	6f 90       	pop	r6
     c38:	5f 90       	pop	r5
     c3a:	4f 90       	pop	r4
     c3c:	08 95       	ret

00000c3e <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     c3e:	af 92       	push	r10
     c40:	bf 92       	push	r11
     c42:	cf 92       	push	r12
     c44:	df 92       	push	r13
     c46:	ef 92       	push	r14
     c48:	ff 92       	push	r15
     c4a:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
     c4c:	a1 2c       	mov	r10, r1
     c4e:	b1 2c       	mov	r11, r1
     c50:	c1 2c       	mov	r12, r1
     c52:	d1 2c       	mov	r13, r1
     c54:	e1 2c       	mov	r14, r1
     c56:	f1 2c       	mov	r15, r1
     c58:	00 e0       	ldi	r16, 0x00	; 0
     c5a:	20 e0       	ldi	r18, 0x00	; 0
     c5c:	30 e0       	ldi	r19, 0x00	; 0
     c5e:	45 e5       	ldi	r20, 0x55	; 85
     c60:	50 e0       	ldi	r21, 0x00	; 0
     c62:	6e e4       	ldi	r22, 0x4E	; 78
     c64:	71 e0       	ldi	r23, 0x01	; 1
     c66:	89 e9       	ldi	r24, 0x99	; 153
     c68:	97 e0       	ldi	r25, 0x07	; 7
     c6a:	0e 94 11 05 	call	0xa22	; 0xa22 <xTaskGenericCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     c6e:	81 30       	cpi	r24, 0x01	; 1
     c70:	81 f4       	brne	.+32     	; 0xc92 <vTaskStartScheduler+0x54>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     c72:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
     c74:	8f ef       	ldi	r24, 0xFF	; 255
     c76:	9f ef       	ldi	r25, 0xFF	; 255
     c78:	90 93 42 05 	sts	0x0542, r25
     c7c:	80 93 41 05 	sts	0x0541, r24
		xSchedulerRunning = pdTRUE;
     c80:	81 e0       	ldi	r24, 0x01	; 1
     c82:	80 93 47 05 	sts	0x0547, r24
		xTickCount = ( TickType_t ) 0U;
     c86:	10 92 4a 05 	sts	0x054A, r1
     c8a:	10 92 49 05 	sts	0x0549, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     c8e:	0e 94 18 02 	call	0x430	; 0x430 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
     c92:	0f 91       	pop	r16
     c94:	ff 90       	pop	r15
     c96:	ef 90       	pop	r14
     c98:	df 90       	pop	r13
     c9a:	cf 90       	pop	r12
     c9c:	bf 90       	pop	r11
     c9e:	af 90       	pop	r10
     ca0:	08 95       	ret

00000ca2 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     ca2:	80 91 40 05 	lds	r24, 0x0540
     ca6:	8f 5f       	subi	r24, 0xFF	; 255
     ca8:	80 93 40 05 	sts	0x0540, r24
     cac:	08 95       	ret

00000cae <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     cae:	cf 92       	push	r12
     cb0:	df 92       	push	r13
     cb2:	ef 92       	push	r14
     cb4:	ff 92       	push	r15
     cb6:	0f 93       	push	r16
     cb8:	1f 93       	push	r17
     cba:	cf 93       	push	r28
     cbc:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     cbe:	80 91 40 05 	lds	r24, 0x0540
     cc2:	81 11       	cpse	r24, r1
     cc4:	9a c0       	rjmp	.+308    	; 0xdfa <xTaskIncrementTick+0x14c>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
     cc6:	80 91 49 05 	lds	r24, 0x0549
     cca:	90 91 4a 05 	lds	r25, 0x054A
     cce:	01 96       	adiw	r24, 0x01	; 1
     cd0:	90 93 4a 05 	sts	0x054A, r25
     cd4:	80 93 49 05 	sts	0x0549, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     cd8:	e0 90 49 05 	lds	r14, 0x0549
     cdc:	f0 90 4a 05 	lds	r15, 0x054A

			if( xConstTickCount == ( TickType_t ) 0U )
     ce0:	e1 14       	cp	r14, r1
     ce2:	f1 04       	cpc	r15, r1
     ce4:	b9 f4       	brne	.+46     	; 0xd14 <xTaskIncrementTick+0x66>
			{
				taskSWITCH_DELAYED_LISTS();
     ce6:	80 91 6a 05 	lds	r24, 0x056A
     cea:	90 91 6b 05 	lds	r25, 0x056B
     cee:	20 91 68 05 	lds	r18, 0x0568
     cf2:	30 91 69 05 	lds	r19, 0x0569
     cf6:	30 93 6b 05 	sts	0x056B, r19
     cfa:	20 93 6a 05 	sts	0x056A, r18
     cfe:	90 93 69 05 	sts	0x0569, r25
     d02:	80 93 68 05 	sts	0x0568, r24
     d06:	80 91 44 05 	lds	r24, 0x0544
     d0a:	8f 5f       	subi	r24, 0xFF	; 255
     d0c:	80 93 44 05 	sts	0x0544, r24
     d10:	0e 94 bb 04 	call	0x976	; 0x976 <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
     d14:	80 91 41 05 	lds	r24, 0x0541
     d18:	90 91 42 05 	lds	r25, 0x0542
     d1c:	e8 16       	cp	r14, r24
     d1e:	f9 06       	cpc	r15, r25
     d20:	08 f4       	brcc	.+2      	; 0xd24 <xTaskIncrementTick+0x76>
     d22:	54 c0       	rjmp	.+168    	; 0xdcc <xTaskIncrementTick+0x11e>
     d24:	d1 2c       	mov	r13, r1
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
							{
								xSwitchRequired = pdTRUE;
     d26:	cc 24       	eor	r12, r12
     d28:	c3 94       	inc	r12
     d2a:	01 c0       	rjmp	.+2      	; 0xd2e <xTaskIncrementTick+0x80>
     d2c:	dc 2c       	mov	r13, r12
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     d2e:	e0 91 6a 05 	lds	r30, 0x056A
     d32:	f0 91 6b 05 	lds	r31, 0x056B
     d36:	80 81       	ld	r24, Z
     d38:	81 11       	cpse	r24, r1
     d3a:	07 c0       	rjmp	.+14     	; 0xd4a <xTaskIncrementTick+0x9c>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
     d3c:	8f ef       	ldi	r24, 0xFF	; 255
     d3e:	9f ef       	ldi	r25, 0xFF	; 255
     d40:	90 93 42 05 	sts	0x0542, r25
     d44:	80 93 41 05 	sts	0x0541, r24
						break;
     d48:	42 c0       	rjmp	.+132    	; 0xdce <xTaskIncrementTick+0x120>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     d4a:	e0 91 6a 05 	lds	r30, 0x056A
     d4e:	f0 91 6b 05 	lds	r31, 0x056B
     d52:	05 80       	ldd	r0, Z+5	; 0x05
     d54:	f6 81       	ldd	r31, Z+6	; 0x06
     d56:	e0 2d       	mov	r30, r0
     d58:	c6 81       	ldd	r28, Z+6	; 0x06
     d5a:	d7 81       	ldd	r29, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
     d5c:	2a 81       	ldd	r18, Y+2	; 0x02
     d5e:	3b 81       	ldd	r19, Y+3	; 0x03

						if( xConstTickCount < xItemValue )
     d60:	e2 16       	cp	r14, r18
     d62:	f3 06       	cpc	r15, r19
     d64:	28 f4       	brcc	.+10     	; 0xd70 <xTaskIncrementTick+0xc2>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
     d66:	30 93 42 05 	sts	0x0542, r19
     d6a:	20 93 41 05 	sts	0x0541, r18
							break;
     d6e:	2f c0       	rjmp	.+94     	; 0xdce <xTaskIncrementTick+0x120>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     d70:	8e 01       	movw	r16, r28
     d72:	0e 5f       	subi	r16, 0xFE	; 254
     d74:	1f 4f       	sbci	r17, 0xFF	; 255
     d76:	c8 01       	movw	r24, r16
     d78:	0e 94 86 01 	call	0x30c	; 0x30c <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     d7c:	8c 89       	ldd	r24, Y+20	; 0x14
     d7e:	9d 89       	ldd	r25, Y+21	; 0x15
     d80:	89 2b       	or	r24, r25
     d82:	21 f0       	breq	.+8      	; 0xd8c <xTaskIncrementTick+0xde>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     d84:	ce 01       	movw	r24, r28
     d86:	0c 96       	adiw	r24, 0x0c	; 12
     d88:	0e 94 86 01 	call	0x30c	; 0x30c <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
     d8c:	2e 89       	ldd	r18, Y+22	; 0x16
     d8e:	80 91 48 05 	lds	r24, 0x0548
     d92:	82 17       	cp	r24, r18
     d94:	10 f4       	brcc	.+4      	; 0xd9a <xTaskIncrementTick+0xec>
     d96:	20 93 48 05 	sts	0x0548, r18
     d9a:	30 e0       	ldi	r19, 0x00	; 0
     d9c:	c9 01       	movw	r24, r18
     d9e:	88 0f       	add	r24, r24
     da0:	99 1f       	adc	r25, r25
     da2:	88 0f       	add	r24, r24
     da4:	99 1f       	adc	r25, r25
     da6:	88 0f       	add	r24, r24
     da8:	99 1f       	adc	r25, r25
     daa:	82 0f       	add	r24, r18
     dac:	93 1f       	adc	r25, r19
     dae:	b8 01       	movw	r22, r16
     db0:	82 58       	subi	r24, 0x82	; 130
     db2:	9a 4f       	sbci	r25, 0xFA	; 250
     db4:	0e 94 34 01 	call	0x268	; 0x268 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     db8:	e0 91 a2 05 	lds	r30, 0x05A2
     dbc:	f0 91 a3 05 	lds	r31, 0x05A3
     dc0:	9e 89       	ldd	r25, Y+22	; 0x16
     dc2:	86 89       	ldd	r24, Z+22	; 0x16
     dc4:	98 17       	cp	r25, r24
     dc6:	08 f0       	brcs	.+2      	; 0xdca <xTaskIncrementTick+0x11c>
     dc8:	b1 cf       	rjmp	.-158    	; 0xd2c <xTaskIncrementTick+0x7e>
     dca:	b1 cf       	rjmp	.-158    	; 0xd2e <xTaskIncrementTick+0x80>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     dcc:	d1 2c       	mov	r13, r1
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     dce:	e0 91 a2 05 	lds	r30, 0x05A2
     dd2:	f0 91 a3 05 	lds	r31, 0x05A3
     dd6:	86 89       	ldd	r24, Z+22	; 0x16
     dd8:	90 e0       	ldi	r25, 0x00	; 0
     dda:	fc 01       	movw	r30, r24
     ddc:	ee 0f       	add	r30, r30
     dde:	ff 1f       	adc	r31, r31
     de0:	ee 0f       	add	r30, r30
     de2:	ff 1f       	adc	r31, r31
     de4:	ee 0f       	add	r30, r30
     de6:	ff 1f       	adc	r31, r31
     de8:	8e 0f       	add	r24, r30
     dea:	9f 1f       	adc	r25, r31
     dec:	fc 01       	movw	r30, r24
     dee:	e2 58       	subi	r30, 0x82	; 130
     df0:	fa 4f       	sbci	r31, 0xFA	; 250
     df2:	80 81       	ld	r24, Z
     df4:	82 30       	cpi	r24, 0x02	; 2
     df6:	40 f4       	brcc	.+16     	; 0xe08 <xTaskIncrementTick+0x15a>
     df8:	09 c0       	rjmp	.+18     	; 0xe0c <xTaskIncrementTick+0x15e>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     dfa:	80 91 46 05 	lds	r24, 0x0546
     dfe:	8f 5f       	subi	r24, 0xFF	; 255
     e00:	80 93 46 05 	sts	0x0546, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     e04:	d1 2c       	mov	r13, r1
     e06:	02 c0       	rjmp	.+4      	; 0xe0c <xTaskIncrementTick+0x15e>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
     e08:	dd 24       	eor	r13, r13
     e0a:	d3 94       	inc	r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     e0c:	80 91 45 05 	lds	r24, 0x0545
     e10:	88 23       	and	r24, r24
     e12:	11 f0       	breq	.+4      	; 0xe18 <xTaskIncrementTick+0x16a>
		{
			xSwitchRequired = pdTRUE;
     e14:	dd 24       	eor	r13, r13
     e16:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     e18:	8d 2d       	mov	r24, r13
     e1a:	df 91       	pop	r29
     e1c:	cf 91       	pop	r28
     e1e:	1f 91       	pop	r17
     e20:	0f 91       	pop	r16
     e22:	ff 90       	pop	r15
     e24:	ef 90       	pop	r14
     e26:	df 90       	pop	r13
     e28:	cf 90       	pop	r12
     e2a:	08 95       	ret

00000e2c <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
     e2c:	df 92       	push	r13
     e2e:	ef 92       	push	r14
     e30:	ff 92       	push	r15
     e32:	0f 93       	push	r16
     e34:	1f 93       	push	r17
     e36:	cf 93       	push	r28
     e38:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     e3a:	0f b6       	in	r0, 0x3f	; 63
     e3c:	f8 94       	cli
     e3e:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     e40:	80 91 40 05 	lds	r24, 0x0540
     e44:	81 50       	subi	r24, 0x01	; 1
     e46:	80 93 40 05 	sts	0x0540, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     e4a:	80 91 40 05 	lds	r24, 0x0540
     e4e:	81 11       	cpse	r24, r1
     e50:	61 c0       	rjmp	.+194    	; 0xf14 <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
     e52:	80 91 4b 05 	lds	r24, 0x054B
     e56:	88 23       	and	r24, r24
     e58:	09 f4       	brne	.+2      	; 0xe5c <xTaskResumeAll+0x30>
     e5a:	5e c0       	rjmp	.+188    	; 0xf18 <xTaskResumeAll+0xec>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     e5c:	0f 2e       	mov	r0, r31
     e5e:	ff e5       	ldi	r31, 0x5F	; 95
     e60:	ef 2e       	mov	r14, r31
     e62:	f5 e0       	ldi	r31, 0x05	; 5
     e64:	ff 2e       	mov	r15, r31
     e66:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
     e68:	dd 24       	eor	r13, r13
     e6a:	d3 94       	inc	r13
     e6c:	30 c0       	rjmp	.+96     	; 0xece <xTaskResumeAll+0xa2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
     e6e:	e0 91 64 05 	lds	r30, 0x0564
     e72:	f0 91 65 05 	lds	r31, 0x0565
     e76:	c6 81       	ldd	r28, Z+6	; 0x06
     e78:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     e7a:	ce 01       	movw	r24, r28
     e7c:	0c 96       	adiw	r24, 0x0c	; 12
     e7e:	0e 94 86 01 	call	0x30c	; 0x30c <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     e82:	8e 01       	movw	r16, r28
     e84:	0e 5f       	subi	r16, 0xFE	; 254
     e86:	1f 4f       	sbci	r17, 0xFF	; 255
     e88:	c8 01       	movw	r24, r16
     e8a:	0e 94 86 01 	call	0x30c	; 0x30c <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
     e8e:	8e 89       	ldd	r24, Y+22	; 0x16
     e90:	90 91 48 05 	lds	r25, 0x0548
     e94:	98 17       	cp	r25, r24
     e96:	10 f4       	brcc	.+4      	; 0xe9c <xTaskResumeAll+0x70>
     e98:	80 93 48 05 	sts	0x0548, r24
     e9c:	90 e0       	ldi	r25, 0x00	; 0
     e9e:	9c 01       	movw	r18, r24
     ea0:	22 0f       	add	r18, r18
     ea2:	33 1f       	adc	r19, r19
     ea4:	22 0f       	add	r18, r18
     ea6:	33 1f       	adc	r19, r19
     ea8:	22 0f       	add	r18, r18
     eaa:	33 1f       	adc	r19, r19
     eac:	82 0f       	add	r24, r18
     eae:	93 1f       	adc	r25, r19
     eb0:	b8 01       	movw	r22, r16
     eb2:	82 58       	subi	r24, 0x82	; 130
     eb4:	9a 4f       	sbci	r25, 0xFA	; 250
     eb6:	0e 94 34 01 	call	0x268	; 0x268 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     eba:	e0 91 a2 05 	lds	r30, 0x05A2
     ebe:	f0 91 a3 05 	lds	r31, 0x05A3
     ec2:	9e 89       	ldd	r25, Y+22	; 0x16
     ec4:	86 89       	ldd	r24, Z+22	; 0x16
     ec6:	98 17       	cp	r25, r24
     ec8:	10 f0       	brcs	.+4      	; 0xece <xTaskResumeAll+0xa2>
					{
						xYieldPending = pdTRUE;
     eca:	d0 92 45 05 	sts	0x0545, r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
     ece:	f7 01       	movw	r30, r14
     ed0:	80 81       	ld	r24, Z
     ed2:	81 11       	cpse	r24, r1
     ed4:	cc cf       	rjmp	.-104    	; 0xe6e <xTaskResumeAll+0x42>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
     ed6:	80 91 46 05 	lds	r24, 0x0546
     eda:	88 23       	and	r24, r24
     edc:	99 f0       	breq	.+38     	; 0xf04 <xTaskResumeAll+0xd8>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
     ede:	80 91 46 05 	lds	r24, 0x0546
     ee2:	88 23       	and	r24, r24
     ee4:	79 f0       	breq	.+30     	; 0xf04 <xTaskResumeAll+0xd8>
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
     ee6:	c1 e0       	ldi	r28, 0x01	; 1
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
     ee8:	0e 94 57 06 	call	0xcae	; 0xcae <xTaskIncrementTick>
     eec:	81 11       	cpse	r24, r1
						{
							xYieldPending = pdTRUE;
     eee:	c0 93 45 05 	sts	0x0545, r28
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
     ef2:	80 91 46 05 	lds	r24, 0x0546
     ef6:	81 50       	subi	r24, 0x01	; 1
     ef8:	80 93 46 05 	sts	0x0546, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
     efc:	80 91 46 05 	lds	r24, 0x0546
     f00:	81 11       	cpse	r24, r1
     f02:	f2 cf       	rjmp	.-28     	; 0xee8 <xTaskResumeAll+0xbc>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
     f04:	80 91 45 05 	lds	r24, 0x0545
     f08:	81 30       	cpi	r24, 0x01	; 1
     f0a:	41 f4       	brne	.+16     	; 0xf1c <xTaskResumeAll+0xf0>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
     f0c:	0e 94 52 02 	call	0x4a4	; 0x4a4 <vPortYield>

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
     f10:	81 e0       	ldi	r24, 0x01	; 1
     f12:	05 c0       	rjmp	.+10     	; 0xf1e <xTaskResumeAll+0xf2>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
     f14:	80 e0       	ldi	r24, 0x00	; 0
     f16:	03 c0       	rjmp	.+6      	; 0xf1e <xTaskResumeAll+0xf2>
     f18:	80 e0       	ldi	r24, 0x00	; 0
     f1a:	01 c0       	rjmp	.+2      	; 0xf1e <xTaskResumeAll+0xf2>
     f1c:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
     f1e:	0f 90       	pop	r0
     f20:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     f22:	df 91       	pop	r29
     f24:	cf 91       	pop	r28
     f26:	1f 91       	pop	r17
     f28:	0f 91       	pop	r16
     f2a:	ff 90       	pop	r15
     f2c:	ef 90       	pop	r14
     f2e:	df 90       	pop	r13
     f30:	08 95       	ret

00000f32 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     f32:	0f 2e       	mov	r0, r31
     f34:	fe e7       	ldi	r31, 0x7E	; 126
     f36:	ef 2e       	mov	r14, r31
     f38:	f5 e0       	ldi	r31, 0x05	; 5
     f3a:	ff 2e       	mov	r15, r31
     f3c:	f0 2d       	mov	r31, r0
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
     f3e:	c6 e5       	ldi	r28, 0x56	; 86
     f40:	d5 e0       	ldi	r29, 0x05	; 5
     f42:	28 c0       	rjmp	.+80     	; 0xf94 <prvIdleTask+0x62>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
     f44:	0e 94 51 06 	call	0xca2	; 0xca2 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
     f48:	18 81       	ld	r17, Y
			}
			( void ) xTaskResumeAll();
     f4a:	0e 94 16 07 	call	0xe2c	; 0xe2c <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
     f4e:	11 23       	and	r17, r17
     f50:	09 f1       	breq	.+66     	; 0xf94 <prvIdleTask+0x62>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
     f52:	0f b6       	in	r0, 0x3f	; 63
     f54:	f8 94       	cli
     f56:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
     f58:	e0 91 5b 05 	lds	r30, 0x055B
     f5c:	f0 91 5c 05 	lds	r31, 0x055C
     f60:	06 81       	ldd	r16, Z+6	; 0x06
     f62:	17 81       	ldd	r17, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     f64:	c8 01       	movw	r24, r16
     f66:	02 96       	adiw	r24, 0x02	; 2
     f68:	0e 94 86 01 	call	0x30c	; 0x30c <uxListRemove>
					--uxCurrentNumberOfTasks;
     f6c:	80 91 4b 05 	lds	r24, 0x054B
     f70:	81 50       	subi	r24, 0x01	; 1
     f72:	80 93 4b 05 	sts	0x054B, r24
					--uxTasksDeleted;
     f76:	80 91 55 05 	lds	r24, 0x0555
     f7a:	81 50       	subi	r24, 0x01	; 1
     f7c:	80 93 55 05 	sts	0x0555, r24
				}
				taskEXIT_CRITICAL();
     f80:	0f 90       	pop	r0
     f82:	0f be       	out	0x3f, r0	; 63
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
     f84:	f8 01       	movw	r30, r16
     f86:	87 89       	ldd	r24, Z+23	; 0x17
     f88:	90 8d       	ldd	r25, Z+24	; 0x18
     f8a:	0e 94 3f 03 	call	0x67e	; 0x67e <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
     f8e:	c8 01       	movw	r24, r16
     f90:	0e 94 3f 03 	call	0x67e	; 0x67e <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
     f94:	80 91 55 05 	lds	r24, 0x0555
     f98:	81 11       	cpse	r24, r1
     f9a:	d4 cf       	rjmp	.-88     	; 0xf44 <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
     f9c:	f7 01       	movw	r30, r14
     f9e:	80 81       	ld	r24, Z
     fa0:	82 30       	cpi	r24, 0x02	; 2
     fa2:	c0 f3       	brcs	.-16     	; 0xf94 <prvIdleTask+0x62>
			{
				taskYIELD();
     fa4:	0e 94 52 02 	call	0x4a4	; 0x4a4 <vPortYield>
     fa8:	f5 cf       	rjmp	.-22     	; 0xf94 <prvIdleTask+0x62>

00000faa <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
     faa:	80 91 40 05 	lds	r24, 0x0540
     fae:	88 23       	and	r24, r24
     fb0:	21 f0       	breq	.+8      	; 0xfba <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
     fb2:	81 e0       	ldi	r24, 0x01	; 1
     fb4:	80 93 45 05 	sts	0x0545, r24
     fb8:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
     fba:	10 92 45 05 	sts	0x0545, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
     fbe:	80 91 48 05 	lds	r24, 0x0548
     fc2:	90 e0       	ldi	r25, 0x00	; 0
     fc4:	fc 01       	movw	r30, r24
     fc6:	ee 0f       	add	r30, r30
     fc8:	ff 1f       	adc	r31, r31
     fca:	ee 0f       	add	r30, r30
     fcc:	ff 1f       	adc	r31, r31
     fce:	ee 0f       	add	r30, r30
     fd0:	ff 1f       	adc	r31, r31
     fd2:	8e 0f       	add	r24, r30
     fd4:	9f 1f       	adc	r25, r31
     fd6:	fc 01       	movw	r30, r24
     fd8:	e2 58       	subi	r30, 0x82	; 130
     fda:	fa 4f       	sbci	r31, 0xFA	; 250
     fdc:	80 81       	ld	r24, Z
     fde:	81 11       	cpse	r24, r1
     fe0:	17 c0       	rjmp	.+46     	; 0x1010 <vTaskSwitchContext+0x66>
     fe2:	80 91 48 05 	lds	r24, 0x0548
     fe6:	81 50       	subi	r24, 0x01	; 1
     fe8:	80 93 48 05 	sts	0x0548, r24
     fec:	80 91 48 05 	lds	r24, 0x0548
     ff0:	90 e0       	ldi	r25, 0x00	; 0
     ff2:	fc 01       	movw	r30, r24
     ff4:	ee 0f       	add	r30, r30
     ff6:	ff 1f       	adc	r31, r31
     ff8:	ee 0f       	add	r30, r30
     ffa:	ff 1f       	adc	r31, r31
     ffc:	ee 0f       	add	r30, r30
     ffe:	ff 1f       	adc	r31, r31
    1000:	8e 0f       	add	r24, r30
    1002:	9f 1f       	adc	r25, r31
    1004:	fc 01       	movw	r30, r24
    1006:	e2 58       	subi	r30, 0x82	; 130
    1008:	fa 4f       	sbci	r31, 0xFA	; 250
    100a:	80 81       	ld	r24, Z
    100c:	88 23       	and	r24, r24
    100e:	49 f3       	breq	.-46     	; 0xfe2 <vTaskSwitchContext+0x38>
    1010:	e0 91 48 05 	lds	r30, 0x0548
    1014:	f0 e0       	ldi	r31, 0x00	; 0
    1016:	cf 01       	movw	r24, r30
    1018:	88 0f       	add	r24, r24
    101a:	99 1f       	adc	r25, r25
    101c:	88 0f       	add	r24, r24
    101e:	99 1f       	adc	r25, r25
    1020:	88 0f       	add	r24, r24
    1022:	99 1f       	adc	r25, r25
    1024:	e8 0f       	add	r30, r24
    1026:	f9 1f       	adc	r31, r25
    1028:	e2 58       	subi	r30, 0x82	; 130
    102a:	fa 4f       	sbci	r31, 0xFA	; 250
    102c:	a1 81       	ldd	r26, Z+1	; 0x01
    102e:	b2 81       	ldd	r27, Z+2	; 0x02
    1030:	12 96       	adiw	r26, 0x02	; 2
    1032:	0d 90       	ld	r0, X+
    1034:	bc 91       	ld	r27, X
    1036:	a0 2d       	mov	r26, r0
    1038:	b2 83       	std	Z+2, r27	; 0x02
    103a:	a1 83       	std	Z+1, r26	; 0x01
    103c:	cf 01       	movw	r24, r30
    103e:	03 96       	adiw	r24, 0x03	; 3
    1040:	a8 17       	cp	r26, r24
    1042:	b9 07       	cpc	r27, r25
    1044:	31 f4       	brne	.+12     	; 0x1052 <vTaskSwitchContext+0xa8>
    1046:	12 96       	adiw	r26, 0x02	; 2
    1048:	8d 91       	ld	r24, X+
    104a:	9c 91       	ld	r25, X
    104c:	13 97       	sbiw	r26, 0x03	; 3
    104e:	92 83       	std	Z+2, r25	; 0x02
    1050:	81 83       	std	Z+1, r24	; 0x01
    1052:	01 80       	ldd	r0, Z+1	; 0x01
    1054:	f2 81       	ldd	r31, Z+2	; 0x02
    1056:	e0 2d       	mov	r30, r0
    1058:	86 81       	ldd	r24, Z+6	; 0x06
    105a:	97 81       	ldd	r25, Z+7	; 0x07
    105c:	90 93 a3 05 	sts	0x05A3, r25
    1060:	80 93 a2 05 	sts	0x05A2, r24
    1064:	08 95       	ret

00001066 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    1066:	cf 93       	push	r28
    1068:	df 93       	push	r29
    106a:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    106c:	60 91 a2 05 	lds	r22, 0x05A2
    1070:	70 91 a3 05 	lds	r23, 0x05A3
    1074:	64 5f       	subi	r22, 0xF4	; 244
    1076:	7f 4f       	sbci	r23, 0xFF	; 255
    1078:	0e 94 55 01 	call	0x2aa	; 0x2aa <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    107c:	80 91 a2 05 	lds	r24, 0x05A2
    1080:	90 91 a3 05 	lds	r25, 0x05A3
    1084:	02 96       	adiw	r24, 0x02	; 2
    1086:	0e 94 86 01 	call	0x30c	; 0x30c <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    108a:	cf 3f       	cpi	r28, 0xFF	; 255
    108c:	8f ef       	ldi	r24, 0xFF	; 255
    108e:	d8 07       	cpc	r29, r24
    1090:	59 f4       	brne	.+22     	; 0x10a8 <vTaskPlaceOnEventList+0x42>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure the task is not woken by a timing event.  It will
			block indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    1092:	60 91 a2 05 	lds	r22, 0x05A2
    1096:	70 91 a3 05 	lds	r23, 0x05A3
    109a:	6e 5f       	subi	r22, 0xFE	; 254
    109c:	7f 4f       	sbci	r23, 0xFF	; 255
    109e:	8c e4       	ldi	r24, 0x4C	; 76
    10a0:	95 e0       	ldi	r25, 0x05	; 5
    10a2:	0e 94 34 01 	call	0x268	; 0x268 <vListInsertEnd>
    10a6:	08 c0       	rjmp	.+16     	; 0x10b8 <vTaskPlaceOnEventList+0x52>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			scheduler will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    10a8:	80 91 49 05 	lds	r24, 0x0549
    10ac:	90 91 4a 05 	lds	r25, 0x054A
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    10b0:	8c 0f       	add	r24, r28
    10b2:	9d 1f       	adc	r25, r29
    10b4:	0e 94 da 04 	call	0x9b4	; 0x9b4 <prvAddCurrentTaskToDelayedList>
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    10b8:	df 91       	pop	r29
    10ba:	cf 91       	pop	r28
    10bc:	08 95       	ret

000010be <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    10be:	0f 93       	push	r16
    10c0:	1f 93       	push	r17
    10c2:	cf 93       	push	r28
    10c4:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    10c6:	dc 01       	movw	r26, r24
    10c8:	15 96       	adiw	r26, 0x05	; 5
    10ca:	ed 91       	ld	r30, X+
    10cc:	fc 91       	ld	r31, X
    10ce:	16 97       	sbiw	r26, 0x06	; 6
    10d0:	c6 81       	ldd	r28, Z+6	; 0x06
    10d2:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    10d4:	8e 01       	movw	r16, r28
    10d6:	04 5f       	subi	r16, 0xF4	; 244
    10d8:	1f 4f       	sbci	r17, 0xFF	; 255
    10da:	c8 01       	movw	r24, r16
    10dc:	0e 94 86 01 	call	0x30c	; 0x30c <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    10e0:	80 91 40 05 	lds	r24, 0x0540
    10e4:	81 11       	cpse	r24, r1
    10e6:	1c c0       	rjmp	.+56     	; 0x1120 <xTaskRemoveFromEventList+0x62>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    10e8:	0a 50       	subi	r16, 0x0A	; 10
    10ea:	11 09       	sbc	r17, r1
    10ec:	c8 01       	movw	r24, r16
    10ee:	0e 94 86 01 	call	0x30c	; 0x30c <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    10f2:	8e 89       	ldd	r24, Y+22	; 0x16
    10f4:	90 91 48 05 	lds	r25, 0x0548
    10f8:	98 17       	cp	r25, r24
    10fa:	10 f4       	brcc	.+4      	; 0x1100 <xTaskRemoveFromEventList+0x42>
    10fc:	80 93 48 05 	sts	0x0548, r24
    1100:	90 e0       	ldi	r25, 0x00	; 0
    1102:	9c 01       	movw	r18, r24
    1104:	22 0f       	add	r18, r18
    1106:	33 1f       	adc	r19, r19
    1108:	22 0f       	add	r18, r18
    110a:	33 1f       	adc	r19, r19
    110c:	22 0f       	add	r18, r18
    110e:	33 1f       	adc	r19, r19
    1110:	82 0f       	add	r24, r18
    1112:	93 1f       	adc	r25, r19
    1114:	b8 01       	movw	r22, r16
    1116:	82 58       	subi	r24, 0x82	; 130
    1118:	9a 4f       	sbci	r25, 0xFA	; 250
    111a:	0e 94 34 01 	call	0x268	; 0x268 <vListInsertEnd>
    111e:	05 c0       	rjmp	.+10     	; 0x112a <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1120:	b8 01       	movw	r22, r16
    1122:	8f e5       	ldi	r24, 0x5F	; 95
    1124:	95 e0       	ldi	r25, 0x05	; 5
    1126:	0e 94 34 01 	call	0x268	; 0x268 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    112a:	e0 91 a2 05 	lds	r30, 0x05A2
    112e:	f0 91 a3 05 	lds	r31, 0x05A3
    1132:	9e 89       	ldd	r25, Y+22	; 0x16
    1134:	86 89       	ldd	r24, Z+22	; 0x16
    1136:	89 17       	cp	r24, r25
    1138:	20 f4       	brcc	.+8      	; 0x1142 <xTaskRemoveFromEventList+0x84>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    113a:	81 e0       	ldi	r24, 0x01	; 1
    113c:	80 93 45 05 	sts	0x0545, r24
    1140:	01 c0       	rjmp	.+2      	; 0x1144 <xTaskRemoveFromEventList+0x86>
	}
	else
	{
		xReturn = pdFALSE;
    1142:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
    1144:	df 91       	pop	r29
    1146:	cf 91       	pop	r28
    1148:	1f 91       	pop	r17
    114a:	0f 91       	pop	r16
    114c:	08 95       	ret

0000114e <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    114e:	20 91 44 05 	lds	r18, 0x0544
    1152:	fc 01       	movw	r30, r24
    1154:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    1156:	20 91 49 05 	lds	r18, 0x0549
    115a:	30 91 4a 05 	lds	r19, 0x054A
    115e:	32 83       	std	Z+2, r19	; 0x02
    1160:	21 83       	std	Z+1, r18	; 0x01
    1162:	08 95       	ret

00001164 <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    1164:	0f b6       	in	r0, 0x3f	; 63
    1166:	f8 94       	cli
    1168:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    116a:	40 91 49 05 	lds	r20, 0x0549
    116e:	50 91 4a 05 	lds	r21, 0x054A

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    1172:	db 01       	movw	r26, r22
    1174:	2d 91       	ld	r18, X+
    1176:	3c 91       	ld	r19, X
    1178:	2f 3f       	cpi	r18, 0xFF	; 255
    117a:	bf ef       	ldi	r27, 0xFF	; 255
    117c:	3b 07       	cpc	r19, r27
    117e:	19 f1       	breq	.+70     	; 0x11c6 <xTaskCheckForTimeOut+0x62>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1180:	e0 91 44 05 	lds	r30, 0x0544
    1184:	dc 01       	movw	r26, r24
    1186:	fc 91       	ld	r31, X
    1188:	fe 17       	cp	r31, r30
    118a:	39 f0       	breq	.+14     	; 0x119a <xTaskCheckForTimeOut+0x36>
    118c:	11 96       	adiw	r26, 0x01	; 1
    118e:	ed 91       	ld	r30, X+
    1190:	fc 91       	ld	r31, X
    1192:	12 97       	sbiw	r26, 0x02	; 2
    1194:	4e 17       	cp	r20, r30
    1196:	5f 07       	cpc	r21, r31
    1198:	c0 f4       	brcc	.+48     	; 0x11ca <xTaskCheckForTimeOut+0x66>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    119a:	dc 01       	movw	r26, r24
    119c:	11 96       	adiw	r26, 0x01	; 1
    119e:	ed 91       	ld	r30, X+
    11a0:	fc 91       	ld	r31, X
    11a2:	12 97       	sbiw	r26, 0x02	; 2
    11a4:	da 01       	movw	r26, r20
    11a6:	ae 1b       	sub	r26, r30
    11a8:	bf 0b       	sbc	r27, r31
    11aa:	a2 17       	cp	r26, r18
    11ac:	b3 07       	cpc	r27, r19
    11ae:	78 f4       	brcc	.+30     	; 0x11ce <xTaskCheckForTimeOut+0x6a>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    11b0:	e4 1b       	sub	r30, r20
    11b2:	f5 0b       	sbc	r31, r21
    11b4:	2e 0f       	add	r18, r30
    11b6:	3f 1f       	adc	r19, r31
    11b8:	fb 01       	movw	r30, r22
    11ba:	31 83       	std	Z+1, r19	; 0x01
    11bc:	20 83       	st	Z, r18
			vTaskSetTimeOutState( pxTimeOut );
    11be:	0e 94 a7 08 	call	0x114e	; 0x114e <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    11c2:	80 e0       	ldi	r24, 0x00	; 0
    11c4:	05 c0       	rjmp	.+10     	; 0x11d0 <xTaskCheckForTimeOut+0x6c>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
    11c6:	80 e0       	ldi	r24, 0x00	; 0
    11c8:	03 c0       	rjmp	.+6      	; 0x11d0 <xTaskCheckForTimeOut+0x6c>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    11ca:	81 e0       	ldi	r24, 0x01	; 1
    11cc:	01 c0       	rjmp	.+2      	; 0x11d0 <xTaskCheckForTimeOut+0x6c>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    11ce:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    11d0:	0f 90       	pop	r0
    11d2:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    11d4:	08 95       	ret

000011d6 <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    11d6:	81 e0       	ldi	r24, 0x01	; 1
    11d8:	80 93 45 05 	sts	0x0545, r24
    11dc:	08 95       	ret

000011de <USART_Init>:
#include <avr/io.h>
#include <stdio.h>

void USART_Init(unsigned int ubrr) {
	/* set baud rate */
	UBRR0H = (unsigned char)(ubrr>>8);
    11de:	90 93 c5 00 	sts	0x00C5, r25
	UBRR0L = (unsigned char)ubrr;
    11e2:	80 93 c4 00 	sts	0x00C4, r24

    UCSR0C = _BV(USBS0) | _BV(UCSZ01) | _BV(UCSZ00); /* 8-bit data, 2 stop bits */ 
    11e6:	8e e0       	ldi	r24, 0x0E	; 14
    11e8:	80 93 c2 00 	sts	0x00C2, r24
    UCSR0B = _BV(RXEN0) | _BV(TXEN0);   /* Enable RX and TX */    
    11ec:	88 e1       	ldi	r24, 0x18	; 24
    11ee:	80 93 c1 00 	sts	0x00C1, r24
    11f2:	08 95       	ret

000011f4 <USART_Transmit>:
}

void USART_Transmit(char c, FILE *stream) {
    11f4:	cf 93       	push	r28
    11f6:	c8 2f       	mov	r28, r24
    if (c == '\n') {
    11f8:	8a 30       	cpi	r24, 0x0A	; 10
    11fa:	19 f4       	brne	.+6      	; 0x1202 <USART_Transmit+0xe>
        USART_Transmit('\r', stream); /* transmit carriage return with new line */
    11fc:	8d e0       	ldi	r24, 0x0D	; 13
    11fe:	0e 94 fa 08 	call	0x11f4	; 0x11f4 <USART_Transmit>
    }
    /* Wait for empty transmit buffer */
    while ( !( UCSR0A & (1<<UDRE0)) )
    1202:	e0 ec       	ldi	r30, 0xC0	; 192
    1204:	f0 e0       	ldi	r31, 0x00	; 0
    1206:	90 81       	ld	r25, Z
    1208:	95 ff       	sbrs	r25, 5
    120a:	fd cf       	rjmp	.-6      	; 0x1206 <USART_Transmit+0x12>
    ;
    /* Put data into buffer, sends the data */
    UDR0 = c;
    120c:	c0 93 c6 00 	sts	0x00C6, r28
}
    1210:	cf 91       	pop	r28
    1212:	08 95       	ret

00001214 <USART_Receive>:

char USART_Receive(FILE *stream) {
    /* Wait for data to be received */
    while ( !(UCSR0A & (1<<RXC0)) )
    1214:	e0 ec       	ldi	r30, 0xC0	; 192
    1216:	f0 e0       	ldi	r31, 0x00	; 0
    1218:	80 81       	ld	r24, Z
    121a:	88 23       	and	r24, r24
    121c:	ec f7       	brge	.-6      	; 0x1218 <USART_Receive+0x4>
    ;
    /* Get and return received data from buffer */
    return UDR0;
    121e:	80 91 c6 00 	lds	r24, 0x00C6
}
    1222:	08 95       	ret

00001224 <vWifiTask>:
#include "WiFi.h"

xQueueHandle wifiMsgQ;

void vWifiTask(void *pvParameters)
{
    1224:	cf 93       	push	r28
    1226:	df 93       	push	r29
    1228:	00 d0       	rcall	.+0      	; 0x122a <vWifiTask+0x6>
    122a:	00 d0       	rcall	.+0      	; 0x122c <vWifiTask+0x8>
    122c:	cd b7       	in	r28, 0x3d	; 61
    122e:	de b7       	in	r29, 0x3e	; 62
	uint32_t blockTime = portMAX_DELAY;
	WiFiMsg_t msg;
	while(1)
	{
		if(xQueueReceive(wifiMsgQ, &msg, blockTime))
    1230:	20 e0       	ldi	r18, 0x00	; 0
    1232:	4f ef       	ldi	r20, 0xFF	; 255
    1234:	5f ef       	ldi	r21, 0xFF	; 255
    1236:	be 01       	movw	r22, r28
    1238:	6f 5f       	subi	r22, 0xFF	; 255
    123a:	7f 4f       	sbci	r23, 0xFF	; 255
    123c:	80 91 aa 05 	lds	r24, 0x05AA
    1240:	90 91 ab 05 	lds	r25, 0x05AB
    1244:	0e 94 0f 04 	call	0x81e	; 0x81e <xQueueGenericReceive>
    1248:	f3 cf       	rjmp	.-26     	; 0x1230 <vWifiTask+0xc>

0000124a <memcpy>:
    124a:	fb 01       	movw	r30, r22
    124c:	dc 01       	movw	r26, r24
    124e:	02 c0       	rjmp	.+4      	; 0x1254 <memcpy+0xa>
    1250:	01 90       	ld	r0, Z+
    1252:	0d 92       	st	X+, r0
    1254:	41 50       	subi	r20, 0x01	; 1
    1256:	50 40       	sbci	r21, 0x00	; 0
    1258:	d8 f7       	brcc	.-10     	; 0x1250 <memcpy+0x6>
    125a:	08 95       	ret

0000125c <printf>:
    125c:	a0 e0       	ldi	r26, 0x00	; 0
    125e:	b0 e0       	ldi	r27, 0x00	; 0
    1260:	e4 e3       	ldi	r30, 0x34	; 52
    1262:	f9 e0       	ldi	r31, 0x09	; 9
    1264:	0c 94 ca 0b 	jmp	0x1794	; 0x1794 <__prologue_saves__+0x20>
    1268:	fe 01       	movw	r30, r28
    126a:	35 96       	adiw	r30, 0x05	; 5
    126c:	61 91       	ld	r22, Z+
    126e:	71 91       	ld	r23, Z+
    1270:	af 01       	movw	r20, r30
    1272:	80 91 ae 05 	lds	r24, 0x05AE
    1276:	90 91 af 05 	lds	r25, 0x05AF
    127a:	0e 94 42 09 	call	0x1284	; 0x1284 <vfprintf>
    127e:	e2 e0       	ldi	r30, 0x02	; 2
    1280:	0c 94 e6 0b 	jmp	0x17cc	; 0x17cc <__epilogue_restores__+0x20>

00001284 <vfprintf>:
    1284:	ac e0       	ldi	r26, 0x0C	; 12
    1286:	b0 e0       	ldi	r27, 0x00	; 0
    1288:	e8 e4       	ldi	r30, 0x48	; 72
    128a:	f9 e0       	ldi	r31, 0x09	; 9
    128c:	0c 94 ba 0b 	jmp	0x1774	; 0x1774 <__prologue_saves__>
    1290:	7c 01       	movw	r14, r24
    1292:	6b 01       	movw	r12, r22
    1294:	8a 01       	movw	r16, r20
    1296:	fc 01       	movw	r30, r24
    1298:	17 82       	std	Z+7, r1	; 0x07
    129a:	16 82       	std	Z+6, r1	; 0x06
    129c:	83 81       	ldd	r24, Z+3	; 0x03
    129e:	81 ff       	sbrs	r24, 1
    12a0:	bd c1       	rjmp	.+890    	; 0x161c <vfprintf+0x398>
    12a2:	ce 01       	movw	r24, r28
    12a4:	01 96       	adiw	r24, 0x01	; 1
    12a6:	4c 01       	movw	r8, r24
    12a8:	f7 01       	movw	r30, r14
    12aa:	93 81       	ldd	r25, Z+3	; 0x03
    12ac:	f6 01       	movw	r30, r12
    12ae:	93 fd       	sbrc	r25, 3
    12b0:	85 91       	lpm	r24, Z+
    12b2:	93 ff       	sbrs	r25, 3
    12b4:	81 91       	ld	r24, Z+
    12b6:	6f 01       	movw	r12, r30
    12b8:	88 23       	and	r24, r24
    12ba:	09 f4       	brne	.+2      	; 0x12be <vfprintf+0x3a>
    12bc:	ab c1       	rjmp	.+854    	; 0x1614 <vfprintf+0x390>
    12be:	85 32       	cpi	r24, 0x25	; 37
    12c0:	39 f4       	brne	.+14     	; 0x12d0 <vfprintf+0x4c>
    12c2:	93 fd       	sbrc	r25, 3
    12c4:	85 91       	lpm	r24, Z+
    12c6:	93 ff       	sbrs	r25, 3
    12c8:	81 91       	ld	r24, Z+
    12ca:	6f 01       	movw	r12, r30
    12cc:	85 32       	cpi	r24, 0x25	; 37
    12ce:	29 f4       	brne	.+10     	; 0x12da <vfprintf+0x56>
    12d0:	b7 01       	movw	r22, r14
    12d2:	90 e0       	ldi	r25, 0x00	; 0
    12d4:	0e 94 2a 0b 	call	0x1654	; 0x1654 <fputc>
    12d8:	e7 cf       	rjmp	.-50     	; 0x12a8 <vfprintf+0x24>
    12da:	51 2c       	mov	r5, r1
    12dc:	31 2c       	mov	r3, r1
    12de:	20 e0       	ldi	r18, 0x00	; 0
    12e0:	20 32       	cpi	r18, 0x20	; 32
    12e2:	a0 f4       	brcc	.+40     	; 0x130c <vfprintf+0x88>
    12e4:	8b 32       	cpi	r24, 0x2B	; 43
    12e6:	69 f0       	breq	.+26     	; 0x1302 <vfprintf+0x7e>
    12e8:	30 f4       	brcc	.+12     	; 0x12f6 <vfprintf+0x72>
    12ea:	80 32       	cpi	r24, 0x20	; 32
    12ec:	59 f0       	breq	.+22     	; 0x1304 <vfprintf+0x80>
    12ee:	83 32       	cpi	r24, 0x23	; 35
    12f0:	69 f4       	brne	.+26     	; 0x130c <vfprintf+0x88>
    12f2:	20 61       	ori	r18, 0x10	; 16
    12f4:	2c c0       	rjmp	.+88     	; 0x134e <vfprintf+0xca>
    12f6:	8d 32       	cpi	r24, 0x2D	; 45
    12f8:	39 f0       	breq	.+14     	; 0x1308 <vfprintf+0x84>
    12fa:	80 33       	cpi	r24, 0x30	; 48
    12fc:	39 f4       	brne	.+14     	; 0x130c <vfprintf+0x88>
    12fe:	21 60       	ori	r18, 0x01	; 1
    1300:	26 c0       	rjmp	.+76     	; 0x134e <vfprintf+0xca>
    1302:	22 60       	ori	r18, 0x02	; 2
    1304:	24 60       	ori	r18, 0x04	; 4
    1306:	23 c0       	rjmp	.+70     	; 0x134e <vfprintf+0xca>
    1308:	28 60       	ori	r18, 0x08	; 8
    130a:	21 c0       	rjmp	.+66     	; 0x134e <vfprintf+0xca>
    130c:	27 fd       	sbrc	r18, 7
    130e:	27 c0       	rjmp	.+78     	; 0x135e <vfprintf+0xda>
    1310:	30 ed       	ldi	r19, 0xD0	; 208
    1312:	38 0f       	add	r19, r24
    1314:	3a 30       	cpi	r19, 0x0A	; 10
    1316:	78 f4       	brcc	.+30     	; 0x1336 <vfprintf+0xb2>
    1318:	26 ff       	sbrs	r18, 6
    131a:	06 c0       	rjmp	.+12     	; 0x1328 <vfprintf+0xa4>
    131c:	fa e0       	ldi	r31, 0x0A	; 10
    131e:	5f 9e       	mul	r5, r31
    1320:	30 0d       	add	r19, r0
    1322:	11 24       	eor	r1, r1
    1324:	53 2e       	mov	r5, r19
    1326:	13 c0       	rjmp	.+38     	; 0x134e <vfprintf+0xca>
    1328:	8a e0       	ldi	r24, 0x0A	; 10
    132a:	38 9e       	mul	r3, r24
    132c:	30 0d       	add	r19, r0
    132e:	11 24       	eor	r1, r1
    1330:	33 2e       	mov	r3, r19
    1332:	20 62       	ori	r18, 0x20	; 32
    1334:	0c c0       	rjmp	.+24     	; 0x134e <vfprintf+0xca>
    1336:	8e 32       	cpi	r24, 0x2E	; 46
    1338:	21 f4       	brne	.+8      	; 0x1342 <vfprintf+0xbe>
    133a:	26 fd       	sbrc	r18, 6
    133c:	6b c1       	rjmp	.+726    	; 0x1614 <vfprintf+0x390>
    133e:	20 64       	ori	r18, 0x40	; 64
    1340:	06 c0       	rjmp	.+12     	; 0x134e <vfprintf+0xca>
    1342:	8c 36       	cpi	r24, 0x6C	; 108
    1344:	11 f4       	brne	.+4      	; 0x134a <vfprintf+0xc6>
    1346:	20 68       	ori	r18, 0x80	; 128
    1348:	02 c0       	rjmp	.+4      	; 0x134e <vfprintf+0xca>
    134a:	88 36       	cpi	r24, 0x68	; 104
    134c:	41 f4       	brne	.+16     	; 0x135e <vfprintf+0xda>
    134e:	f6 01       	movw	r30, r12
    1350:	93 fd       	sbrc	r25, 3
    1352:	85 91       	lpm	r24, Z+
    1354:	93 ff       	sbrs	r25, 3
    1356:	81 91       	ld	r24, Z+
    1358:	6f 01       	movw	r12, r30
    135a:	81 11       	cpse	r24, r1
    135c:	c1 cf       	rjmp	.-126    	; 0x12e0 <vfprintf+0x5c>
    135e:	98 2f       	mov	r25, r24
    1360:	9f 7d       	andi	r25, 0xDF	; 223
    1362:	95 54       	subi	r25, 0x45	; 69
    1364:	93 30       	cpi	r25, 0x03	; 3
    1366:	28 f4       	brcc	.+10     	; 0x1372 <vfprintf+0xee>
    1368:	0c 5f       	subi	r16, 0xFC	; 252
    136a:	1f 4f       	sbci	r17, 0xFF	; 255
    136c:	ff e3       	ldi	r31, 0x3F	; 63
    136e:	f9 83       	std	Y+1, r31	; 0x01
    1370:	0d c0       	rjmp	.+26     	; 0x138c <vfprintf+0x108>
    1372:	83 36       	cpi	r24, 0x63	; 99
    1374:	31 f0       	breq	.+12     	; 0x1382 <vfprintf+0xfe>
    1376:	83 37       	cpi	r24, 0x73	; 115
    1378:	71 f0       	breq	.+28     	; 0x1396 <vfprintf+0x112>
    137a:	83 35       	cpi	r24, 0x53	; 83
    137c:	09 f0       	breq	.+2      	; 0x1380 <vfprintf+0xfc>
    137e:	5b c0       	rjmp	.+182    	; 0x1436 <vfprintf+0x1b2>
    1380:	22 c0       	rjmp	.+68     	; 0x13c6 <vfprintf+0x142>
    1382:	f8 01       	movw	r30, r16
    1384:	80 81       	ld	r24, Z
    1386:	89 83       	std	Y+1, r24	; 0x01
    1388:	0e 5f       	subi	r16, 0xFE	; 254
    138a:	1f 4f       	sbci	r17, 0xFF	; 255
    138c:	44 24       	eor	r4, r4
    138e:	43 94       	inc	r4
    1390:	51 2c       	mov	r5, r1
    1392:	54 01       	movw	r10, r8
    1394:	15 c0       	rjmp	.+42     	; 0x13c0 <vfprintf+0x13c>
    1396:	38 01       	movw	r6, r16
    1398:	f2 e0       	ldi	r31, 0x02	; 2
    139a:	6f 0e       	add	r6, r31
    139c:	71 1c       	adc	r7, r1
    139e:	f8 01       	movw	r30, r16
    13a0:	a0 80       	ld	r10, Z
    13a2:	b1 80       	ldd	r11, Z+1	; 0x01
    13a4:	26 ff       	sbrs	r18, 6
    13a6:	03 c0       	rjmp	.+6      	; 0x13ae <vfprintf+0x12a>
    13a8:	65 2d       	mov	r22, r5
    13aa:	70 e0       	ldi	r23, 0x00	; 0
    13ac:	02 c0       	rjmp	.+4      	; 0x13b2 <vfprintf+0x12e>
    13ae:	6f ef       	ldi	r22, 0xFF	; 255
    13b0:	7f ef       	ldi	r23, 0xFF	; 255
    13b2:	c5 01       	movw	r24, r10
    13b4:	2c 87       	std	Y+12, r18	; 0x0c
    13b6:	0e 94 1f 0b 	call	0x163e	; 0x163e <strnlen>
    13ba:	2c 01       	movw	r4, r24
    13bc:	83 01       	movw	r16, r6
    13be:	2c 85       	ldd	r18, Y+12	; 0x0c
    13c0:	2f 77       	andi	r18, 0x7F	; 127
    13c2:	22 2e       	mov	r2, r18
    13c4:	17 c0       	rjmp	.+46     	; 0x13f4 <vfprintf+0x170>
    13c6:	38 01       	movw	r6, r16
    13c8:	f2 e0       	ldi	r31, 0x02	; 2
    13ca:	6f 0e       	add	r6, r31
    13cc:	71 1c       	adc	r7, r1
    13ce:	f8 01       	movw	r30, r16
    13d0:	a0 80       	ld	r10, Z
    13d2:	b1 80       	ldd	r11, Z+1	; 0x01
    13d4:	26 ff       	sbrs	r18, 6
    13d6:	03 c0       	rjmp	.+6      	; 0x13de <vfprintf+0x15a>
    13d8:	65 2d       	mov	r22, r5
    13da:	70 e0       	ldi	r23, 0x00	; 0
    13dc:	02 c0       	rjmp	.+4      	; 0x13e2 <vfprintf+0x15e>
    13de:	6f ef       	ldi	r22, 0xFF	; 255
    13e0:	7f ef       	ldi	r23, 0xFF	; 255
    13e2:	c5 01       	movw	r24, r10
    13e4:	2c 87       	std	Y+12, r18	; 0x0c
    13e6:	0e 94 14 0b 	call	0x1628	; 0x1628 <strnlen_P>
    13ea:	2c 01       	movw	r4, r24
    13ec:	2c 85       	ldd	r18, Y+12	; 0x0c
    13ee:	20 68       	ori	r18, 0x80	; 128
    13f0:	22 2e       	mov	r2, r18
    13f2:	83 01       	movw	r16, r6
    13f4:	23 fc       	sbrc	r2, 3
    13f6:	1b c0       	rjmp	.+54     	; 0x142e <vfprintf+0x1aa>
    13f8:	83 2d       	mov	r24, r3
    13fa:	90 e0       	ldi	r25, 0x00	; 0
    13fc:	48 16       	cp	r4, r24
    13fe:	59 06       	cpc	r5, r25
    1400:	b0 f4       	brcc	.+44     	; 0x142e <vfprintf+0x1aa>
    1402:	b7 01       	movw	r22, r14
    1404:	80 e2       	ldi	r24, 0x20	; 32
    1406:	90 e0       	ldi	r25, 0x00	; 0
    1408:	0e 94 2a 0b 	call	0x1654	; 0x1654 <fputc>
    140c:	3a 94       	dec	r3
    140e:	f4 cf       	rjmp	.-24     	; 0x13f8 <vfprintf+0x174>
    1410:	f5 01       	movw	r30, r10
    1412:	27 fc       	sbrc	r2, 7
    1414:	85 91       	lpm	r24, Z+
    1416:	27 fe       	sbrs	r2, 7
    1418:	81 91       	ld	r24, Z+
    141a:	5f 01       	movw	r10, r30
    141c:	b7 01       	movw	r22, r14
    141e:	90 e0       	ldi	r25, 0x00	; 0
    1420:	0e 94 2a 0b 	call	0x1654	; 0x1654 <fputc>
    1424:	31 10       	cpse	r3, r1
    1426:	3a 94       	dec	r3
    1428:	f1 e0       	ldi	r31, 0x01	; 1
    142a:	4f 1a       	sub	r4, r31
    142c:	51 08       	sbc	r5, r1
    142e:	41 14       	cp	r4, r1
    1430:	51 04       	cpc	r5, r1
    1432:	71 f7       	brne	.-36     	; 0x1410 <vfprintf+0x18c>
    1434:	e5 c0       	rjmp	.+458    	; 0x1600 <vfprintf+0x37c>
    1436:	84 36       	cpi	r24, 0x64	; 100
    1438:	11 f0       	breq	.+4      	; 0x143e <vfprintf+0x1ba>
    143a:	89 36       	cpi	r24, 0x69	; 105
    143c:	39 f5       	brne	.+78     	; 0x148c <vfprintf+0x208>
    143e:	f8 01       	movw	r30, r16
    1440:	27 ff       	sbrs	r18, 7
    1442:	07 c0       	rjmp	.+14     	; 0x1452 <vfprintf+0x1ce>
    1444:	60 81       	ld	r22, Z
    1446:	71 81       	ldd	r23, Z+1	; 0x01
    1448:	82 81       	ldd	r24, Z+2	; 0x02
    144a:	93 81       	ldd	r25, Z+3	; 0x03
    144c:	0c 5f       	subi	r16, 0xFC	; 252
    144e:	1f 4f       	sbci	r17, 0xFF	; 255
    1450:	08 c0       	rjmp	.+16     	; 0x1462 <vfprintf+0x1de>
    1452:	60 81       	ld	r22, Z
    1454:	71 81       	ldd	r23, Z+1	; 0x01
    1456:	88 27       	eor	r24, r24
    1458:	77 fd       	sbrc	r23, 7
    145a:	80 95       	com	r24
    145c:	98 2f       	mov	r25, r24
    145e:	0e 5f       	subi	r16, 0xFE	; 254
    1460:	1f 4f       	sbci	r17, 0xFF	; 255
    1462:	2f 76       	andi	r18, 0x6F	; 111
    1464:	b2 2e       	mov	r11, r18
    1466:	97 ff       	sbrs	r25, 7
    1468:	09 c0       	rjmp	.+18     	; 0x147c <vfprintf+0x1f8>
    146a:	90 95       	com	r25
    146c:	80 95       	com	r24
    146e:	70 95       	com	r23
    1470:	61 95       	neg	r22
    1472:	7f 4f       	sbci	r23, 0xFF	; 255
    1474:	8f 4f       	sbci	r24, 0xFF	; 255
    1476:	9f 4f       	sbci	r25, 0xFF	; 255
    1478:	20 68       	ori	r18, 0x80	; 128
    147a:	b2 2e       	mov	r11, r18
    147c:	2a e0       	ldi	r18, 0x0A	; 10
    147e:	30 e0       	ldi	r19, 0x00	; 0
    1480:	a4 01       	movw	r20, r8
    1482:	0e 94 5c 0b 	call	0x16b8	; 0x16b8 <__ultoa_invert>
    1486:	a8 2e       	mov	r10, r24
    1488:	a8 18       	sub	r10, r8
    148a:	44 c0       	rjmp	.+136    	; 0x1514 <vfprintf+0x290>
    148c:	85 37       	cpi	r24, 0x75	; 117
    148e:	29 f4       	brne	.+10     	; 0x149a <vfprintf+0x216>
    1490:	2f 7e       	andi	r18, 0xEF	; 239
    1492:	b2 2e       	mov	r11, r18
    1494:	2a e0       	ldi	r18, 0x0A	; 10
    1496:	30 e0       	ldi	r19, 0x00	; 0
    1498:	25 c0       	rjmp	.+74     	; 0x14e4 <vfprintf+0x260>
    149a:	f2 2f       	mov	r31, r18
    149c:	f9 7f       	andi	r31, 0xF9	; 249
    149e:	bf 2e       	mov	r11, r31
    14a0:	8f 36       	cpi	r24, 0x6F	; 111
    14a2:	c1 f0       	breq	.+48     	; 0x14d4 <vfprintf+0x250>
    14a4:	18 f4       	brcc	.+6      	; 0x14ac <vfprintf+0x228>
    14a6:	88 35       	cpi	r24, 0x58	; 88
    14a8:	79 f0       	breq	.+30     	; 0x14c8 <vfprintf+0x244>
    14aa:	b4 c0       	rjmp	.+360    	; 0x1614 <vfprintf+0x390>
    14ac:	80 37       	cpi	r24, 0x70	; 112
    14ae:	19 f0       	breq	.+6      	; 0x14b6 <vfprintf+0x232>
    14b0:	88 37       	cpi	r24, 0x78	; 120
    14b2:	21 f0       	breq	.+8      	; 0x14bc <vfprintf+0x238>
    14b4:	af c0       	rjmp	.+350    	; 0x1614 <vfprintf+0x390>
    14b6:	2f 2f       	mov	r18, r31
    14b8:	20 61       	ori	r18, 0x10	; 16
    14ba:	b2 2e       	mov	r11, r18
    14bc:	b4 fe       	sbrs	r11, 4
    14be:	0d c0       	rjmp	.+26     	; 0x14da <vfprintf+0x256>
    14c0:	8b 2d       	mov	r24, r11
    14c2:	84 60       	ori	r24, 0x04	; 4
    14c4:	b8 2e       	mov	r11, r24
    14c6:	09 c0       	rjmp	.+18     	; 0x14da <vfprintf+0x256>
    14c8:	24 ff       	sbrs	r18, 4
    14ca:	0a c0       	rjmp	.+20     	; 0x14e0 <vfprintf+0x25c>
    14cc:	9f 2f       	mov	r25, r31
    14ce:	96 60       	ori	r25, 0x06	; 6
    14d0:	b9 2e       	mov	r11, r25
    14d2:	06 c0       	rjmp	.+12     	; 0x14e0 <vfprintf+0x25c>
    14d4:	28 e0       	ldi	r18, 0x08	; 8
    14d6:	30 e0       	ldi	r19, 0x00	; 0
    14d8:	05 c0       	rjmp	.+10     	; 0x14e4 <vfprintf+0x260>
    14da:	20 e1       	ldi	r18, 0x10	; 16
    14dc:	30 e0       	ldi	r19, 0x00	; 0
    14de:	02 c0       	rjmp	.+4      	; 0x14e4 <vfprintf+0x260>
    14e0:	20 e1       	ldi	r18, 0x10	; 16
    14e2:	32 e0       	ldi	r19, 0x02	; 2
    14e4:	f8 01       	movw	r30, r16
    14e6:	b7 fe       	sbrs	r11, 7
    14e8:	07 c0       	rjmp	.+14     	; 0x14f8 <vfprintf+0x274>
    14ea:	60 81       	ld	r22, Z
    14ec:	71 81       	ldd	r23, Z+1	; 0x01
    14ee:	82 81       	ldd	r24, Z+2	; 0x02
    14f0:	93 81       	ldd	r25, Z+3	; 0x03
    14f2:	0c 5f       	subi	r16, 0xFC	; 252
    14f4:	1f 4f       	sbci	r17, 0xFF	; 255
    14f6:	06 c0       	rjmp	.+12     	; 0x1504 <vfprintf+0x280>
    14f8:	60 81       	ld	r22, Z
    14fa:	71 81       	ldd	r23, Z+1	; 0x01
    14fc:	80 e0       	ldi	r24, 0x00	; 0
    14fe:	90 e0       	ldi	r25, 0x00	; 0
    1500:	0e 5f       	subi	r16, 0xFE	; 254
    1502:	1f 4f       	sbci	r17, 0xFF	; 255
    1504:	a4 01       	movw	r20, r8
    1506:	0e 94 5c 0b 	call	0x16b8	; 0x16b8 <__ultoa_invert>
    150a:	a8 2e       	mov	r10, r24
    150c:	a8 18       	sub	r10, r8
    150e:	fb 2d       	mov	r31, r11
    1510:	ff 77       	andi	r31, 0x7F	; 127
    1512:	bf 2e       	mov	r11, r31
    1514:	b6 fe       	sbrs	r11, 6
    1516:	0b c0       	rjmp	.+22     	; 0x152e <vfprintf+0x2aa>
    1518:	2b 2d       	mov	r18, r11
    151a:	2e 7f       	andi	r18, 0xFE	; 254
    151c:	a5 14       	cp	r10, r5
    151e:	50 f4       	brcc	.+20     	; 0x1534 <vfprintf+0x2b0>
    1520:	b4 fe       	sbrs	r11, 4
    1522:	0a c0       	rjmp	.+20     	; 0x1538 <vfprintf+0x2b4>
    1524:	b2 fc       	sbrc	r11, 2
    1526:	08 c0       	rjmp	.+16     	; 0x1538 <vfprintf+0x2b4>
    1528:	2b 2d       	mov	r18, r11
    152a:	2e 7e       	andi	r18, 0xEE	; 238
    152c:	05 c0       	rjmp	.+10     	; 0x1538 <vfprintf+0x2b4>
    152e:	7a 2c       	mov	r7, r10
    1530:	2b 2d       	mov	r18, r11
    1532:	03 c0       	rjmp	.+6      	; 0x153a <vfprintf+0x2b6>
    1534:	7a 2c       	mov	r7, r10
    1536:	01 c0       	rjmp	.+2      	; 0x153a <vfprintf+0x2b6>
    1538:	75 2c       	mov	r7, r5
    153a:	24 ff       	sbrs	r18, 4
    153c:	0d c0       	rjmp	.+26     	; 0x1558 <vfprintf+0x2d4>
    153e:	fe 01       	movw	r30, r28
    1540:	ea 0d       	add	r30, r10
    1542:	f1 1d       	adc	r31, r1
    1544:	80 81       	ld	r24, Z
    1546:	80 33       	cpi	r24, 0x30	; 48
    1548:	11 f4       	brne	.+4      	; 0x154e <vfprintf+0x2ca>
    154a:	29 7e       	andi	r18, 0xE9	; 233
    154c:	09 c0       	rjmp	.+18     	; 0x1560 <vfprintf+0x2dc>
    154e:	22 ff       	sbrs	r18, 2
    1550:	06 c0       	rjmp	.+12     	; 0x155e <vfprintf+0x2da>
    1552:	73 94       	inc	r7
    1554:	73 94       	inc	r7
    1556:	04 c0       	rjmp	.+8      	; 0x1560 <vfprintf+0x2dc>
    1558:	82 2f       	mov	r24, r18
    155a:	86 78       	andi	r24, 0x86	; 134
    155c:	09 f0       	breq	.+2      	; 0x1560 <vfprintf+0x2dc>
    155e:	73 94       	inc	r7
    1560:	23 fd       	sbrc	r18, 3
    1562:	13 c0       	rjmp	.+38     	; 0x158a <vfprintf+0x306>
    1564:	20 ff       	sbrs	r18, 0
    1566:	06 c0       	rjmp	.+12     	; 0x1574 <vfprintf+0x2f0>
    1568:	5a 2c       	mov	r5, r10
    156a:	73 14       	cp	r7, r3
    156c:	18 f4       	brcc	.+6      	; 0x1574 <vfprintf+0x2f0>
    156e:	53 0c       	add	r5, r3
    1570:	57 18       	sub	r5, r7
    1572:	73 2c       	mov	r7, r3
    1574:	73 14       	cp	r7, r3
    1576:	68 f4       	brcc	.+26     	; 0x1592 <vfprintf+0x30e>
    1578:	b7 01       	movw	r22, r14
    157a:	80 e2       	ldi	r24, 0x20	; 32
    157c:	90 e0       	ldi	r25, 0x00	; 0
    157e:	2c 87       	std	Y+12, r18	; 0x0c
    1580:	0e 94 2a 0b 	call	0x1654	; 0x1654 <fputc>
    1584:	73 94       	inc	r7
    1586:	2c 85       	ldd	r18, Y+12	; 0x0c
    1588:	f5 cf       	rjmp	.-22     	; 0x1574 <vfprintf+0x2f0>
    158a:	73 14       	cp	r7, r3
    158c:	10 f4       	brcc	.+4      	; 0x1592 <vfprintf+0x30e>
    158e:	37 18       	sub	r3, r7
    1590:	01 c0       	rjmp	.+2      	; 0x1594 <vfprintf+0x310>
    1592:	31 2c       	mov	r3, r1
    1594:	24 ff       	sbrs	r18, 4
    1596:	12 c0       	rjmp	.+36     	; 0x15bc <vfprintf+0x338>
    1598:	b7 01       	movw	r22, r14
    159a:	80 e3       	ldi	r24, 0x30	; 48
    159c:	90 e0       	ldi	r25, 0x00	; 0
    159e:	2c 87       	std	Y+12, r18	; 0x0c
    15a0:	0e 94 2a 0b 	call	0x1654	; 0x1654 <fputc>
    15a4:	2c 85       	ldd	r18, Y+12	; 0x0c
    15a6:	22 ff       	sbrs	r18, 2
    15a8:	17 c0       	rjmp	.+46     	; 0x15d8 <vfprintf+0x354>
    15aa:	21 ff       	sbrs	r18, 1
    15ac:	03 c0       	rjmp	.+6      	; 0x15b4 <vfprintf+0x330>
    15ae:	88 e5       	ldi	r24, 0x58	; 88
    15b0:	90 e0       	ldi	r25, 0x00	; 0
    15b2:	02 c0       	rjmp	.+4      	; 0x15b8 <vfprintf+0x334>
    15b4:	88 e7       	ldi	r24, 0x78	; 120
    15b6:	90 e0       	ldi	r25, 0x00	; 0
    15b8:	b7 01       	movw	r22, r14
    15ba:	0c c0       	rjmp	.+24     	; 0x15d4 <vfprintf+0x350>
    15bc:	82 2f       	mov	r24, r18
    15be:	86 78       	andi	r24, 0x86	; 134
    15c0:	59 f0       	breq	.+22     	; 0x15d8 <vfprintf+0x354>
    15c2:	21 fd       	sbrc	r18, 1
    15c4:	02 c0       	rjmp	.+4      	; 0x15ca <vfprintf+0x346>
    15c6:	80 e2       	ldi	r24, 0x20	; 32
    15c8:	01 c0       	rjmp	.+2      	; 0x15cc <vfprintf+0x348>
    15ca:	8b e2       	ldi	r24, 0x2B	; 43
    15cc:	27 fd       	sbrc	r18, 7
    15ce:	8d e2       	ldi	r24, 0x2D	; 45
    15d0:	b7 01       	movw	r22, r14
    15d2:	90 e0       	ldi	r25, 0x00	; 0
    15d4:	0e 94 2a 0b 	call	0x1654	; 0x1654 <fputc>
    15d8:	a5 14       	cp	r10, r5
    15da:	38 f4       	brcc	.+14     	; 0x15ea <vfprintf+0x366>
    15dc:	b7 01       	movw	r22, r14
    15de:	80 e3       	ldi	r24, 0x30	; 48
    15e0:	90 e0       	ldi	r25, 0x00	; 0
    15e2:	0e 94 2a 0b 	call	0x1654	; 0x1654 <fputc>
    15e6:	5a 94       	dec	r5
    15e8:	f7 cf       	rjmp	.-18     	; 0x15d8 <vfprintf+0x354>
    15ea:	aa 94       	dec	r10
    15ec:	f4 01       	movw	r30, r8
    15ee:	ea 0d       	add	r30, r10
    15f0:	f1 1d       	adc	r31, r1
    15f2:	80 81       	ld	r24, Z
    15f4:	b7 01       	movw	r22, r14
    15f6:	90 e0       	ldi	r25, 0x00	; 0
    15f8:	0e 94 2a 0b 	call	0x1654	; 0x1654 <fputc>
    15fc:	a1 10       	cpse	r10, r1
    15fe:	f5 cf       	rjmp	.-22     	; 0x15ea <vfprintf+0x366>
    1600:	33 20       	and	r3, r3
    1602:	09 f4       	brne	.+2      	; 0x1606 <vfprintf+0x382>
    1604:	51 ce       	rjmp	.-862    	; 0x12a8 <vfprintf+0x24>
    1606:	b7 01       	movw	r22, r14
    1608:	80 e2       	ldi	r24, 0x20	; 32
    160a:	90 e0       	ldi	r25, 0x00	; 0
    160c:	0e 94 2a 0b 	call	0x1654	; 0x1654 <fputc>
    1610:	3a 94       	dec	r3
    1612:	f6 cf       	rjmp	.-20     	; 0x1600 <vfprintf+0x37c>
    1614:	f7 01       	movw	r30, r14
    1616:	86 81       	ldd	r24, Z+6	; 0x06
    1618:	97 81       	ldd	r25, Z+7	; 0x07
    161a:	02 c0       	rjmp	.+4      	; 0x1620 <vfprintf+0x39c>
    161c:	8f ef       	ldi	r24, 0xFF	; 255
    161e:	9f ef       	ldi	r25, 0xFF	; 255
    1620:	2c 96       	adiw	r28, 0x0c	; 12
    1622:	e2 e1       	ldi	r30, 0x12	; 18
    1624:	0c 94 d6 0b 	jmp	0x17ac	; 0x17ac <__epilogue_restores__>

00001628 <strnlen_P>:
    1628:	fc 01       	movw	r30, r24
    162a:	05 90       	lpm	r0, Z+
    162c:	61 50       	subi	r22, 0x01	; 1
    162e:	70 40       	sbci	r23, 0x00	; 0
    1630:	01 10       	cpse	r0, r1
    1632:	d8 f7       	brcc	.-10     	; 0x162a <strnlen_P+0x2>
    1634:	80 95       	com	r24
    1636:	90 95       	com	r25
    1638:	8e 0f       	add	r24, r30
    163a:	9f 1f       	adc	r25, r31
    163c:	08 95       	ret

0000163e <strnlen>:
    163e:	fc 01       	movw	r30, r24
    1640:	61 50       	subi	r22, 0x01	; 1
    1642:	70 40       	sbci	r23, 0x00	; 0
    1644:	01 90       	ld	r0, Z+
    1646:	01 10       	cpse	r0, r1
    1648:	d8 f7       	brcc	.-10     	; 0x1640 <strnlen+0x2>
    164a:	80 95       	com	r24
    164c:	90 95       	com	r25
    164e:	8e 0f       	add	r24, r30
    1650:	9f 1f       	adc	r25, r31
    1652:	08 95       	ret

00001654 <fputc>:
    1654:	0f 93       	push	r16
    1656:	1f 93       	push	r17
    1658:	cf 93       	push	r28
    165a:	df 93       	push	r29
    165c:	18 2f       	mov	r17, r24
    165e:	09 2f       	mov	r16, r25
    1660:	eb 01       	movw	r28, r22
    1662:	8b 81       	ldd	r24, Y+3	; 0x03
    1664:	81 fd       	sbrc	r24, 1
    1666:	03 c0       	rjmp	.+6      	; 0x166e <fputc+0x1a>
    1668:	8f ef       	ldi	r24, 0xFF	; 255
    166a:	9f ef       	ldi	r25, 0xFF	; 255
    166c:	20 c0       	rjmp	.+64     	; 0x16ae <fputc+0x5a>
    166e:	82 ff       	sbrs	r24, 2
    1670:	10 c0       	rjmp	.+32     	; 0x1692 <fputc+0x3e>
    1672:	4e 81       	ldd	r20, Y+6	; 0x06
    1674:	5f 81       	ldd	r21, Y+7	; 0x07
    1676:	2c 81       	ldd	r18, Y+4	; 0x04
    1678:	3d 81       	ldd	r19, Y+5	; 0x05
    167a:	42 17       	cp	r20, r18
    167c:	53 07       	cpc	r21, r19
    167e:	7c f4       	brge	.+30     	; 0x169e <fputc+0x4a>
    1680:	e8 81       	ld	r30, Y
    1682:	f9 81       	ldd	r31, Y+1	; 0x01
    1684:	9f 01       	movw	r18, r30
    1686:	2f 5f       	subi	r18, 0xFF	; 255
    1688:	3f 4f       	sbci	r19, 0xFF	; 255
    168a:	39 83       	std	Y+1, r19	; 0x01
    168c:	28 83       	st	Y, r18
    168e:	10 83       	st	Z, r17
    1690:	06 c0       	rjmp	.+12     	; 0x169e <fputc+0x4a>
    1692:	e8 85       	ldd	r30, Y+8	; 0x08
    1694:	f9 85       	ldd	r31, Y+9	; 0x09
    1696:	81 2f       	mov	r24, r17
    1698:	09 95       	icall
    169a:	89 2b       	or	r24, r25
    169c:	29 f7       	brne	.-54     	; 0x1668 <fputc+0x14>
    169e:	2e 81       	ldd	r18, Y+6	; 0x06
    16a0:	3f 81       	ldd	r19, Y+7	; 0x07
    16a2:	2f 5f       	subi	r18, 0xFF	; 255
    16a4:	3f 4f       	sbci	r19, 0xFF	; 255
    16a6:	3f 83       	std	Y+7, r19	; 0x07
    16a8:	2e 83       	std	Y+6, r18	; 0x06
    16aa:	81 2f       	mov	r24, r17
    16ac:	90 2f       	mov	r25, r16
    16ae:	df 91       	pop	r29
    16b0:	cf 91       	pop	r28
    16b2:	1f 91       	pop	r17
    16b4:	0f 91       	pop	r16
    16b6:	08 95       	ret

000016b8 <__ultoa_invert>:
    16b8:	fa 01       	movw	r30, r20
    16ba:	aa 27       	eor	r26, r26
    16bc:	28 30       	cpi	r18, 0x08	; 8
    16be:	51 f1       	breq	.+84     	; 0x1714 <__ultoa_invert+0x5c>
    16c0:	20 31       	cpi	r18, 0x10	; 16
    16c2:	81 f1       	breq	.+96     	; 0x1724 <__ultoa_invert+0x6c>
    16c4:	e8 94       	clt
    16c6:	6f 93       	push	r22
    16c8:	6e 7f       	andi	r22, 0xFE	; 254
    16ca:	6e 5f       	subi	r22, 0xFE	; 254
    16cc:	7f 4f       	sbci	r23, 0xFF	; 255
    16ce:	8f 4f       	sbci	r24, 0xFF	; 255
    16d0:	9f 4f       	sbci	r25, 0xFF	; 255
    16d2:	af 4f       	sbci	r26, 0xFF	; 255
    16d4:	b1 e0       	ldi	r27, 0x01	; 1
    16d6:	3e d0       	rcall	.+124    	; 0x1754 <__ultoa_invert+0x9c>
    16d8:	b4 e0       	ldi	r27, 0x04	; 4
    16da:	3c d0       	rcall	.+120    	; 0x1754 <__ultoa_invert+0x9c>
    16dc:	67 0f       	add	r22, r23
    16de:	78 1f       	adc	r23, r24
    16e0:	89 1f       	adc	r24, r25
    16e2:	9a 1f       	adc	r25, r26
    16e4:	a1 1d       	adc	r26, r1
    16e6:	68 0f       	add	r22, r24
    16e8:	79 1f       	adc	r23, r25
    16ea:	8a 1f       	adc	r24, r26
    16ec:	91 1d       	adc	r25, r1
    16ee:	a1 1d       	adc	r26, r1
    16f0:	6a 0f       	add	r22, r26
    16f2:	71 1d       	adc	r23, r1
    16f4:	81 1d       	adc	r24, r1
    16f6:	91 1d       	adc	r25, r1
    16f8:	a1 1d       	adc	r26, r1
    16fa:	20 d0       	rcall	.+64     	; 0x173c <__ultoa_invert+0x84>
    16fc:	09 f4       	brne	.+2      	; 0x1700 <__ultoa_invert+0x48>
    16fe:	68 94       	set
    1700:	3f 91       	pop	r19
    1702:	2a e0       	ldi	r18, 0x0A	; 10
    1704:	26 9f       	mul	r18, r22
    1706:	11 24       	eor	r1, r1
    1708:	30 19       	sub	r19, r0
    170a:	30 5d       	subi	r19, 0xD0	; 208
    170c:	31 93       	st	Z+, r19
    170e:	de f6       	brtc	.-74     	; 0x16c6 <__ultoa_invert+0xe>
    1710:	cf 01       	movw	r24, r30
    1712:	08 95       	ret
    1714:	46 2f       	mov	r20, r22
    1716:	47 70       	andi	r20, 0x07	; 7
    1718:	40 5d       	subi	r20, 0xD0	; 208
    171a:	41 93       	st	Z+, r20
    171c:	b3 e0       	ldi	r27, 0x03	; 3
    171e:	0f d0       	rcall	.+30     	; 0x173e <__ultoa_invert+0x86>
    1720:	c9 f7       	brne	.-14     	; 0x1714 <__ultoa_invert+0x5c>
    1722:	f6 cf       	rjmp	.-20     	; 0x1710 <__ultoa_invert+0x58>
    1724:	46 2f       	mov	r20, r22
    1726:	4f 70       	andi	r20, 0x0F	; 15
    1728:	40 5d       	subi	r20, 0xD0	; 208
    172a:	4a 33       	cpi	r20, 0x3A	; 58
    172c:	18 f0       	brcs	.+6      	; 0x1734 <__ultoa_invert+0x7c>
    172e:	49 5d       	subi	r20, 0xD9	; 217
    1730:	31 fd       	sbrc	r19, 1
    1732:	40 52       	subi	r20, 0x20	; 32
    1734:	41 93       	st	Z+, r20
    1736:	02 d0       	rcall	.+4      	; 0x173c <__ultoa_invert+0x84>
    1738:	a9 f7       	brne	.-22     	; 0x1724 <__ultoa_invert+0x6c>
    173a:	ea cf       	rjmp	.-44     	; 0x1710 <__ultoa_invert+0x58>
    173c:	b4 e0       	ldi	r27, 0x04	; 4
    173e:	a6 95       	lsr	r26
    1740:	97 95       	ror	r25
    1742:	87 95       	ror	r24
    1744:	77 95       	ror	r23
    1746:	67 95       	ror	r22
    1748:	ba 95       	dec	r27
    174a:	c9 f7       	brne	.-14     	; 0x173e <__ultoa_invert+0x86>
    174c:	00 97       	sbiw	r24, 0x00	; 0
    174e:	61 05       	cpc	r22, r1
    1750:	71 05       	cpc	r23, r1
    1752:	08 95       	ret
    1754:	9b 01       	movw	r18, r22
    1756:	ac 01       	movw	r20, r24
    1758:	0a 2e       	mov	r0, r26
    175a:	06 94       	lsr	r0
    175c:	57 95       	ror	r21
    175e:	47 95       	ror	r20
    1760:	37 95       	ror	r19
    1762:	27 95       	ror	r18
    1764:	ba 95       	dec	r27
    1766:	c9 f7       	brne	.-14     	; 0x175a <__ultoa_invert+0xa2>
    1768:	62 0f       	add	r22, r18
    176a:	73 1f       	adc	r23, r19
    176c:	84 1f       	adc	r24, r20
    176e:	95 1f       	adc	r25, r21
    1770:	a0 1d       	adc	r26, r0
    1772:	08 95       	ret

00001774 <__prologue_saves__>:
    1774:	2f 92       	push	r2
    1776:	3f 92       	push	r3
    1778:	4f 92       	push	r4
    177a:	5f 92       	push	r5
    177c:	6f 92       	push	r6
    177e:	7f 92       	push	r7
    1780:	8f 92       	push	r8
    1782:	9f 92       	push	r9
    1784:	af 92       	push	r10
    1786:	bf 92       	push	r11
    1788:	cf 92       	push	r12
    178a:	df 92       	push	r13
    178c:	ef 92       	push	r14
    178e:	ff 92       	push	r15
    1790:	0f 93       	push	r16
    1792:	1f 93       	push	r17
    1794:	cf 93       	push	r28
    1796:	df 93       	push	r29
    1798:	cd b7       	in	r28, 0x3d	; 61
    179a:	de b7       	in	r29, 0x3e	; 62
    179c:	ca 1b       	sub	r28, r26
    179e:	db 0b       	sbc	r29, r27
    17a0:	0f b6       	in	r0, 0x3f	; 63
    17a2:	f8 94       	cli
    17a4:	de bf       	out	0x3e, r29	; 62
    17a6:	0f be       	out	0x3f, r0	; 63
    17a8:	cd bf       	out	0x3d, r28	; 61
    17aa:	09 94       	ijmp

000017ac <__epilogue_restores__>:
    17ac:	2a 88       	ldd	r2, Y+18	; 0x12
    17ae:	39 88       	ldd	r3, Y+17	; 0x11
    17b0:	48 88       	ldd	r4, Y+16	; 0x10
    17b2:	5f 84       	ldd	r5, Y+15	; 0x0f
    17b4:	6e 84       	ldd	r6, Y+14	; 0x0e
    17b6:	7d 84       	ldd	r7, Y+13	; 0x0d
    17b8:	8c 84       	ldd	r8, Y+12	; 0x0c
    17ba:	9b 84       	ldd	r9, Y+11	; 0x0b
    17bc:	aa 84       	ldd	r10, Y+10	; 0x0a
    17be:	b9 84       	ldd	r11, Y+9	; 0x09
    17c0:	c8 84       	ldd	r12, Y+8	; 0x08
    17c2:	df 80       	ldd	r13, Y+7	; 0x07
    17c4:	ee 80       	ldd	r14, Y+6	; 0x06
    17c6:	fd 80       	ldd	r15, Y+5	; 0x05
    17c8:	0c 81       	ldd	r16, Y+4	; 0x04
    17ca:	1b 81       	ldd	r17, Y+3	; 0x03
    17cc:	aa 81       	ldd	r26, Y+2	; 0x02
    17ce:	b9 81       	ldd	r27, Y+1	; 0x01
    17d0:	ce 0f       	add	r28, r30
    17d2:	d1 1d       	adc	r29, r1
    17d4:	0f b6       	in	r0, 0x3f	; 63
    17d6:	f8 94       	cli
    17d8:	de bf       	out	0x3e, r29	; 62
    17da:	0f be       	out	0x3f, r0	; 63
    17dc:	cd bf       	out	0x3d, r28	; 61
    17de:	ed 01       	movw	r28, r26
    17e0:	08 95       	ret

000017e2 <_exit>:
    17e2:	f8 94       	cli

000017e4 <__stop_program>:
    17e4:	ff cf       	rjmp	.-2      	; 0x17e4 <__stop_program>
