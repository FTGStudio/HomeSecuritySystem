
HomeSecuritySystem.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000a0  00800100  00001572  00001606  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001572  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000045e  008001a0  008001a0  000016a6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000016a6  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 000003a0  00000000  00000000  000016d6  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   0000484c  00000000  00000000  00001a76  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000011cb  00000000  00000000  000062c2  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00001ada  00000000  00000000  0000748d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000a4c  00000000  00000000  00008f68  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000012f0  00000000  00000000  000099b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00003c1c  00000000  00000000  0000aca4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000328  00000000  00000000  0000e8c0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
       4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
       c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      14:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      2c:	0c 94 03 03 	jmp	0x606	; 0x606 <__vector_11>
      30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      38:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      54:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
      64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
      68:	11 24       	eor	r1, r1
      6a:	1f be       	out	0x3f, r1	; 63
      6c:	cf ef       	ldi	r28, 0xFF	; 255
      6e:	d8 e0       	ldi	r29, 0x08	; 8
      70:	de bf       	out	0x3e, r29	; 62
      72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
      74:	11 e0       	ldi	r17, 0x01	; 1
      76:	a0 e0       	ldi	r26, 0x00	; 0
      78:	b1 e0       	ldi	r27, 0x01	; 1
      7a:	e2 e7       	ldi	r30, 0x72	; 114
      7c:	f5 e1       	ldi	r31, 0x15	; 21
      7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
      80:	05 90       	lpm	r0, Z+
      82:	0d 92       	st	X+, r0
      84:	a0 3a       	cpi	r26, 0xA0	; 160
      86:	b1 07       	cpc	r27, r17
      88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
      8a:	25 e0       	ldi	r18, 0x05	; 5
      8c:	a0 ea       	ldi	r26, 0xA0	; 160
      8e:	b1 e0       	ldi	r27, 0x01	; 1
      90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
      92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
      94:	ae 3f       	cpi	r26, 0xFE	; 254
      96:	b2 07       	cpc	r27, r18
      98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
      9a:	0e 94 84 00 	call	0x108	; 0x108 <main>
      9e:	0c 94 b7 0a 	jmp	0x156e	; 0x156e <_exit>

000000a2 <__bad_interrupt>:
      a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <vHallEffectTask>:
#include "../Source/include/queue.h"

xQueueHandle hallEffectMsgQ;

void vHallEffectTask(void *pvParameters)
{
      a6:	cf 93       	push	r28
      a8:	df 93       	push	r29
      aa:	00 d0       	rcall	.+0      	; 0xac <vHallEffectTask+0x6>
      ac:	00 d0       	rcall	.+0      	; 0xae <vHallEffectTask+0x8>
      ae:	cd b7       	in	r28, 0x3d	; 61
      b0:	de b7       	in	r29, 0x3e	; 62
	uint32_t blockTime = portMAX_DELAY;
	HallEffectMsg_t msg;
	while(1)
	{
		if(xQueueReceive(hallEffectMsgQ, &msg, blockTime))
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	4f ef       	ldi	r20, 0xFF	; 255
      b6:	5f ef       	ldi	r21, 0xFF	; 255
      b8:	be 01       	movw	r22, r28
      ba:	6f 5f       	subi	r22, 0xFF	; 255
      bc:	7f 4f       	sbci	r23, 0xFF	; 255
      be:	80 91 f0 05 	lds	r24, 0x05F0
      c2:	90 91 f1 05 	lds	r25, 0x05F1
      c6:	0e 94 fa 04 	call	0x9f4	; 0x9f4 <xQueueGenericReceive>
      ca:	88 23       	and	r24, r24
      cc:	91 f3       	breq	.-28     	; 0xb2 <vHallEffectTask+0xc>
		{
			printf("\nHall Effect Message received\n");
      ce:	8c e1       	ldi	r24, 0x1C	; 28
      d0:	91 e0       	ldi	r25, 0x01	; 1
      d2:	0e 94 8a 0a 	call	0x1514	; 0x1514 <puts>
      d6:	ed cf       	rjmp	.-38     	; 0xb2 <vHallEffectTask+0xc>

000000d8 <vLCDTask>:
#include "LCD.h"

xQueueHandle lcdMsgQ;

void vLCDTask(void *pvParameters)
{
      d8:	cf 93       	push	r28
      da:	df 93       	push	r29
      dc:	00 d0       	rcall	.+0      	; 0xde <vLCDTask+0x6>
      de:	cd b7       	in	r28, 0x3d	; 61
      e0:	de b7       	in	r29, 0x3e	; 62
	uint32_t blockTime = portMAX_DELAY;
	LCDMsg_t msg;
	while(1)
	{
		
		if(xQueueReceive(lcdMsgQ, &msg, blockTime))
      e2:	20 e0       	ldi	r18, 0x00	; 0
      e4:	4f ef       	ldi	r20, 0xFF	; 255
      e6:	5f ef       	ldi	r21, 0xFF	; 255
      e8:	be 01       	movw	r22, r28
      ea:	6f 5f       	subi	r22, 0xFF	; 255
      ec:	7f 4f       	sbci	r23, 0xFF	; 255
      ee:	80 91 f2 05 	lds	r24, 0x05F2
      f2:	90 91 f3 05 	lds	r25, 0x05F3
      f6:	0e 94 fa 04 	call	0x9f4	; 0x9f4 <xQueueGenericReceive>
      fa:	88 23       	and	r24, r24
      fc:	91 f3       	breq	.-28     	; 0xe2 <vLCDTask+0xa>
		{
			printf("\nLCD Message received\n");
      fe:	8a e3       	ldi	r24, 0x3A	; 58
     100:	91 e0       	ldi	r25, 0x01	; 1
     102:	0e 94 8a 0a 	call	0x1514	; 0x1514 <puts>
     106:	ed cf       	rjmp	.-38     	; 0xe2 <vLCDTask+0xa>

00000108 <main>:
#define MYUBRR						F_CPU/8/BAUD-1



int main(void)
{
     108:	af 92       	push	r10
     10a:	bf 92       	push	r11
     10c:	cf 92       	push	r12
     10e:	df 92       	push	r13
     110:	ef 92       	push	r14
     112:	ff 92       	push	r15
     114:	0f 93       	push	r16
	
	USART_Init(MYUBRR);
     116:	87 e6       	ldi	r24, 0x67	; 103
     118:	90 e0       	ldi	r25, 0x00	; 0
     11a:	0e 94 45 0a 	call	0x148a	; 0x148a <USART_Init>
	stdout = &uart_output;
     11e:	8e e0       	ldi	r24, 0x0E	; 14
     120:	91 e0       	ldi	r25, 0x01	; 1
     122:	90 93 fb 05 	sts	0x05FB, r25
     126:	80 93 fa 05 	sts	0x05FA, r24
	stdin = &uart_input;
     12a:	80 e0       	ldi	r24, 0x00	; 0
     12c:	91 e0       	ldi	r25, 0x01	; 1
     12e:	90 93 f9 05 	sts	0x05F9, r25
     132:	80 93 f8 05 	sts	0x05F8, r24
	
	hallEffectMsgQ = xQueueCreate(2, sizeof(HallEffectMsg_t));
     136:	40 e0       	ldi	r20, 0x00	; 0
     138:	64 e0       	ldi	r22, 0x04	; 4
     13a:	82 e0       	ldi	r24, 0x02	; 2
     13c:	0e 94 2a 04 	call	0x854	; 0x854 <xQueueGenericCreate>
     140:	90 93 f1 05 	sts	0x05F1, r25
     144:	80 93 f0 05 	sts	0x05F0, r24
	rtcMsgQ = xQueueCreate(2, sizeof(RTCMsg_t));
     148:	40 e0       	ldi	r20, 0x00	; 0
     14a:	66 e0       	ldi	r22, 0x06	; 6
     14c:	82 e0       	ldi	r24, 0x02	; 2
     14e:	0e 94 2a 04 	call	0x854	; 0x854 <xQueueGenericCreate>
     152:	90 93 f5 05 	sts	0x05F5, r25
     156:	80 93 f4 05 	sts	0x05F4, r24
	lcdMsgQ = xQueueCreate(2, sizeof(LCDMsg_t));
     15a:	40 e0       	ldi	r20, 0x00	; 0
     15c:	62 e0       	ldi	r22, 0x02	; 2
     15e:	82 e0       	ldi	r24, 0x02	; 2
     160:	0e 94 2a 04 	call	0x854	; 0x854 <xQueueGenericCreate>
     164:	90 93 f3 05 	sts	0x05F3, r25
     168:	80 93 f2 05 	sts	0x05F2, r24
	wifiMsgQ = xQueueCreate(2, sizeof(WiFiMsg_t));
     16c:	40 e0       	ldi	r20, 0x00	; 0
     16e:	64 e0       	ldi	r22, 0x04	; 4
     170:	82 e0       	ldi	r24, 0x02	; 2
     172:	0e 94 2a 04 	call	0x854	; 0x854 <xQueueGenericCreate>
     176:	90 93 f7 05 	sts	0x05F7, r25
     17a:	80 93 f6 05 	sts	0x05F6, r24
	
	xTaskCreate( vRTCTask, ( signed char * ) "RTC", configMINIMAL_STACK_SIZE, NULL, 1, NULL );
     17e:	a1 2c       	mov	r10, r1
     180:	b1 2c       	mov	r11, r1
     182:	c1 2c       	mov	r12, r1
     184:	d1 2c       	mov	r13, r1
     186:	e1 2c       	mov	r14, r1
     188:	f1 2c       	mov	r15, r1
     18a:	01 e0       	ldi	r16, 0x01	; 1
     18c:	20 e0       	ldi	r18, 0x00	; 0
     18e:	30 e0       	ldi	r19, 0x00	; 0
     190:	45 e5       	ldi	r20, 0x55	; 85
     192:	50 e0       	ldi	r21, 0x00	; 0
     194:	60 e5       	ldi	r22, 0x50	; 80
     196:	71 e0       	ldi	r23, 0x01	; 1
     198:	84 e0       	ldi	r24, 0x04	; 4
     19a:	91 e0       	ldi	r25, 0x01	; 1
     19c:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <xTaskGenericCreate>
	xTaskCreate( vHallEffectTask, ( signed char * ) "HallEffect", configMINIMAL_STACK_SIZE, NULL, 1, NULL );
     1a0:	20 e0       	ldi	r18, 0x00	; 0
     1a2:	30 e0       	ldi	r19, 0x00	; 0
     1a4:	45 e5       	ldi	r20, 0x55	; 85
     1a6:	50 e0       	ldi	r21, 0x00	; 0
     1a8:	64 e5       	ldi	r22, 0x54	; 84
     1aa:	71 e0       	ldi	r23, 0x01	; 1
     1ac:	83 e5       	ldi	r24, 0x53	; 83
     1ae:	90 e0       	ldi	r25, 0x00	; 0
     1b0:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <xTaskGenericCreate>
	xTaskCreate( vLCDTask, ( signed char * ) "LCD", configMINIMAL_STACK_SIZE, NULL, 1, NULL );
     1b4:	20 e0       	ldi	r18, 0x00	; 0
     1b6:	30 e0       	ldi	r19, 0x00	; 0
     1b8:	45 e5       	ldi	r20, 0x55	; 85
     1ba:	50 e0       	ldi	r21, 0x00	; 0
     1bc:	6f e5       	ldi	r22, 0x5F	; 95
     1be:	71 e0       	ldi	r23, 0x01	; 1
     1c0:	8c e6       	ldi	r24, 0x6C	; 108
     1c2:	90 e0       	ldi	r25, 0x00	; 0
     1c4:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <xTaskGenericCreate>
	xTaskCreate( vWifiTask, ( signed char * ) "WiFi", configMINIMAL_STACK_SIZE, NULL, 1, NULL );
     1c8:	20 e0       	ldi	r18, 0x00	; 0
     1ca:	30 e0       	ldi	r19, 0x00	; 0
     1cc:	45 e5       	ldi	r20, 0x55	; 85
     1ce:	50 e0       	ldi	r21, 0x00	; 0
     1d0:	63 e6       	ldi	r22, 0x63	; 99
     1d2:	71 e0       	ldi	r23, 0x01	; 1
     1d4:	88 e6       	ldi	r24, 0x68	; 104
     1d6:	9a e0       	ldi	r25, 0x0A	; 10
     1d8:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <xTaskGenericCreate>
	xTaskCreate( vTestTask, ( signed char * ) "Test", configMINIMAL_STACK_SIZE, NULL, 1, NULL );
     1dc:	20 e0       	ldi	r18, 0x00	; 0
     1de:	30 e0       	ldi	r19, 0x00	; 0
     1e0:	45 e5       	ldi	r20, 0x55	; 85
     1e2:	50 e0       	ldi	r21, 0x00	; 0
     1e4:	68 e6       	ldi	r22, 0x68	; 104
     1e6:	71 e0       	ldi	r23, 0x01	; 1
     1e8:	8a ef       	ldi	r24, 0xFA	; 250
     1ea:	99 e0       	ldi	r25, 0x09	; 9
     1ec:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <xTaskGenericCreate>

	
	vTaskStartScheduler();
     1f0:	0e 94 0a 07 	call	0xe14	; 0xe14 <vTaskStartScheduler>
     1f4:	80 e0       	ldi	r24, 0x00	; 0
     1f6:	90 e0       	ldi	r25, 0x00	; 0
     1f8:	0f 91       	pop	r16
     1fa:	ff 90       	pop	r15
     1fc:	ef 90       	pop	r14
     1fe:	df 90       	pop	r13
     200:	cf 90       	pop	r12
     202:	bf 90       	pop	r11
     204:	af 90       	pop	r10
     206:	08 95       	ret

00000208 <vRTCTask>:
#include "../Source/include/queue.h"

xQueueHandle rtcMsgQ;

void vRTCTask( void *pvParameters )
{
     208:	cf 93       	push	r28
     20a:	df 93       	push	r29
     20c:	00 d0       	rcall	.+0      	; 0x20e <vRTCTask+0x6>
     20e:	00 d0       	rcall	.+0      	; 0x210 <vRTCTask+0x8>
     210:	00 d0       	rcall	.+0      	; 0x212 <vRTCTask+0xa>
     212:	cd b7       	in	r28, 0x3d	; 61
     214:	de b7       	in	r29, 0x3e	; 62
	uint32_t blockTime = portMAX_DELAY;
	RTCMsg_t msg;
	while(1)
	{
		
		if(xQueueReceive(rtcMsgQ, &msg, blockTime))
     216:	20 e0       	ldi	r18, 0x00	; 0
     218:	4f ef       	ldi	r20, 0xFF	; 255
     21a:	5f ef       	ldi	r21, 0xFF	; 255
     21c:	be 01       	movw	r22, r28
     21e:	6f 5f       	subi	r22, 0xFF	; 255
     220:	7f 4f       	sbci	r23, 0xFF	; 255
     222:	80 91 f4 05 	lds	r24, 0x05F4
     226:	90 91 f5 05 	lds	r25, 0x05F5
     22a:	0e 94 fa 04 	call	0x9f4	; 0x9f4 <xQueueGenericReceive>
     22e:	88 23       	and	r24, r24
     230:	91 f3       	breq	.-28     	; 0x216 <vRTCTask+0xe>
		{
			printf("\nRTC Message received\n");
     232:	8d e6       	ldi	r24, 0x6D	; 109
     234:	91 e0       	ldi	r25, 0x01	; 1
     236:	0e 94 8a 0a 	call	0x1514	; 0x1514 <puts>
     23a:	ed cf       	rjmp	.-38     	; 0x216 <vRTCTask+0xe>

0000023c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
     23c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     23e:	03 96       	adiw	r24, 0x03	; 3
     240:	92 83       	std	Z+2, r25	; 0x02
     242:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     244:	2f ef       	ldi	r18, 0xFF	; 255
     246:	3f ef       	ldi	r19, 0xFF	; 255
     248:	34 83       	std	Z+4, r19	; 0x04
     24a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     24c:	96 83       	std	Z+6, r25	; 0x06
     24e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     250:	90 87       	std	Z+8, r25	; 0x08
     252:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
     254:	10 82       	st	Z, r1
     256:	08 95       	ret

00000258 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     258:	fc 01       	movw	r30, r24
     25a:	11 86       	std	Z+9, r1	; 0x09
     25c:	10 86       	std	Z+8, r1	; 0x08
     25e:	08 95       	ret

00000260 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     260:	cf 93       	push	r28
     262:	df 93       	push	r29
     264:	9c 01       	movw	r18, r24
     266:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
     268:	dc 01       	movw	r26, r24
     26a:	11 96       	adiw	r26, 0x01	; 1
     26c:	cd 91       	ld	r28, X+
     26e:	dc 91       	ld	r29, X
     270:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
     272:	d3 83       	std	Z+3, r29	; 0x03
     274:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
     276:	8c 81       	ldd	r24, Y+4	; 0x04
     278:	9d 81       	ldd	r25, Y+5	; 0x05
     27a:	95 83       	std	Z+5, r25	; 0x05
     27c:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
     27e:	8c 81       	ldd	r24, Y+4	; 0x04
     280:	9d 81       	ldd	r25, Y+5	; 0x05
     282:	dc 01       	movw	r26, r24
     284:	13 96       	adiw	r26, 0x03	; 3
     286:	7c 93       	st	X, r23
     288:	6e 93       	st	-X, r22
     28a:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
     28c:	7d 83       	std	Y+5, r23	; 0x05
     28e:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     290:	31 87       	std	Z+9, r19	; 0x09
     292:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
     294:	f9 01       	movw	r30, r18
     296:	80 81       	ld	r24, Z
     298:	8f 5f       	subi	r24, 0xFF	; 255
     29a:	80 83       	st	Z, r24
}
     29c:	df 91       	pop	r29
     29e:	cf 91       	pop	r28
     2a0:	08 95       	ret

000002a2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
     2a2:	cf 93       	push	r28
     2a4:	df 93       	push	r29
     2a6:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
     2a8:	48 81       	ld	r20, Y
     2aa:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     2ac:	4f 3f       	cpi	r20, 0xFF	; 255
     2ae:	2f ef       	ldi	r18, 0xFF	; 255
     2b0:	52 07       	cpc	r21, r18
     2b2:	21 f4       	brne	.+8      	; 0x2bc <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     2b4:	fc 01       	movw	r30, r24
     2b6:	a7 81       	ldd	r26, Z+7	; 0x07
     2b8:	b0 85       	ldd	r27, Z+8	; 0x08
     2ba:	0d c0       	rjmp	.+26     	; 0x2d6 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
     2bc:	dc 01       	movw	r26, r24
     2be:	13 96       	adiw	r26, 0x03	; 3
     2c0:	12 96       	adiw	r26, 0x02	; 2
     2c2:	ed 91       	ld	r30, X+
     2c4:	fc 91       	ld	r31, X
     2c6:	13 97       	sbiw	r26, 0x03	; 3
     2c8:	20 81       	ld	r18, Z
     2ca:	31 81       	ldd	r19, Z+1	; 0x01
     2cc:	42 17       	cp	r20, r18
     2ce:	53 07       	cpc	r21, r19
     2d0:	10 f0       	brcs	.+4      	; 0x2d6 <vListInsert+0x34>
     2d2:	df 01       	movw	r26, r30
     2d4:	f5 cf       	rjmp	.-22     	; 0x2c0 <vListInsert+0x1e>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     2d6:	12 96       	adiw	r26, 0x02	; 2
     2d8:	ed 91       	ld	r30, X+
     2da:	fc 91       	ld	r31, X
     2dc:	13 97       	sbiw	r26, 0x03	; 3
     2de:	fb 83       	std	Y+3, r31	; 0x03
     2e0:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
     2e2:	d5 83       	std	Z+5, r29	; 0x05
     2e4:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
     2e6:	bd 83       	std	Y+5, r27	; 0x05
     2e8:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
     2ea:	13 96       	adiw	r26, 0x03	; 3
     2ec:	dc 93       	st	X, r29
     2ee:	ce 93       	st	-X, r28
     2f0:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     2f2:	99 87       	std	Y+9, r25	; 0x09
     2f4:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     2f6:	fc 01       	movw	r30, r24
     2f8:	20 81       	ld	r18, Z
     2fa:	2f 5f       	subi	r18, 0xFF	; 255
     2fc:	20 83       	st	Z, r18
}
     2fe:	df 91       	pop	r29
     300:	cf 91       	pop	r28
     302:	08 95       	ret

00000304 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
     304:	cf 93       	push	r28
     306:	df 93       	push	r29
     308:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
     30a:	a0 85       	ldd	r26, Z+8	; 0x08
     30c:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     30e:	c2 81       	ldd	r28, Z+2	; 0x02
     310:	d3 81       	ldd	r29, Z+3	; 0x03
     312:	84 81       	ldd	r24, Z+4	; 0x04
     314:	95 81       	ldd	r25, Z+5	; 0x05
     316:	9d 83       	std	Y+5, r25	; 0x05
     318:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     31a:	c4 81       	ldd	r28, Z+4	; 0x04
     31c:	d5 81       	ldd	r29, Z+5	; 0x05
     31e:	82 81       	ldd	r24, Z+2	; 0x02
     320:	93 81       	ldd	r25, Z+3	; 0x03
     322:	9b 83       	std	Y+3, r25	; 0x03
     324:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     326:	11 96       	adiw	r26, 0x01	; 1
     328:	cd 91       	ld	r28, X+
     32a:	dc 91       	ld	r29, X
     32c:	12 97       	sbiw	r26, 0x02	; 2
     32e:	ce 17       	cp	r28, r30
     330:	df 07       	cpc	r29, r31
     332:	31 f4       	brne	.+12     	; 0x340 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     334:	8c 81       	ldd	r24, Y+4	; 0x04
     336:	9d 81       	ldd	r25, Y+5	; 0x05
     338:	12 96       	adiw	r26, 0x02	; 2
     33a:	9c 93       	st	X, r25
     33c:	8e 93       	st	-X, r24
     33e:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
     340:	11 86       	std	Z+9, r1	; 0x09
     342:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     344:	8c 91       	ld	r24, X
     346:	81 50       	subi	r24, 0x01	; 1
     348:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
     34a:	df 91       	pop	r29
     34c:	cf 91       	pop	r28
     34e:	08 95       	ret

00000350 <pxPortInitialiseStack>:
uint16_t usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
     350:	31 e1       	ldi	r19, 0x11	; 17
     352:	fc 01       	movw	r30, r24
     354:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
     356:	31 97       	sbiw	r30, 0x01	; 1
     358:	22 e2       	ldi	r18, 0x22	; 34
     35a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
     35c:	31 97       	sbiw	r30, 0x01	; 1
     35e:	a3 e3       	ldi	r26, 0x33	; 51
     360:	a0 83       	st	Z, r26
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( uint16_t ) pxCode;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     362:	31 97       	sbiw	r30, 0x01	; 1
     364:	60 83       	st	Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     366:	31 97       	sbiw	r30, 0x01	; 1
     368:	70 83       	st	Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R0 */
     36a:	31 97       	sbiw	r30, 0x01	; 1
     36c:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
     36e:	31 97       	sbiw	r30, 0x01	; 1
     370:	60 e8       	ldi	r22, 0x80	; 128
     372:	60 83       	st	Z, r22
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( StackType_t ) 0x00;	/* R1 */
     374:	31 97       	sbiw	r30, 0x01	; 1
     376:	10 82       	st	Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x02;	/* R2 */
     378:	31 97       	sbiw	r30, 0x01	; 1
     37a:	62 e0       	ldi	r22, 0x02	; 2
     37c:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x03;	/* R3 */
     37e:	31 97       	sbiw	r30, 0x01	; 1
     380:	63 e0       	ldi	r22, 0x03	; 3
     382:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x04;	/* R4 */
     384:	31 97       	sbiw	r30, 0x01	; 1
     386:	64 e0       	ldi	r22, 0x04	; 4
     388:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x05;	/* R5 */
     38a:	31 97       	sbiw	r30, 0x01	; 1
     38c:	65 e0       	ldi	r22, 0x05	; 5
     38e:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x06;	/* R6 */
     390:	31 97       	sbiw	r30, 0x01	; 1
     392:	66 e0       	ldi	r22, 0x06	; 6
     394:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x07;	/* R7 */
     396:	31 97       	sbiw	r30, 0x01	; 1
     398:	67 e0       	ldi	r22, 0x07	; 7
     39a:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x08;	/* R8 */
     39c:	31 97       	sbiw	r30, 0x01	; 1
     39e:	68 e0       	ldi	r22, 0x08	; 8
     3a0:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x09;	/* R9 */
     3a2:	31 97       	sbiw	r30, 0x01	; 1
     3a4:	69 e0       	ldi	r22, 0x09	; 9
     3a6:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x10;	/* R10 */
     3a8:	31 97       	sbiw	r30, 0x01	; 1
     3aa:	60 e1       	ldi	r22, 0x10	; 16
     3ac:	60 83       	st	Z, r22
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x11;	/* R11 */
     3ae:	31 97       	sbiw	r30, 0x01	; 1
     3b0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x12;	/* R12 */
     3b2:	31 97       	sbiw	r30, 0x01	; 1
     3b4:	32 e1       	ldi	r19, 0x12	; 18
     3b6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x13;	/* R13 */
     3b8:	31 97       	sbiw	r30, 0x01	; 1
     3ba:	33 e1       	ldi	r19, 0x13	; 19
     3bc:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x14;	/* R14 */
     3be:	31 97       	sbiw	r30, 0x01	; 1
     3c0:	34 e1       	ldi	r19, 0x14	; 20
     3c2:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x15;	/* R15 */
     3c4:	31 97       	sbiw	r30, 0x01	; 1
     3c6:	35 e1       	ldi	r19, 0x15	; 21
     3c8:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x16;	/* R16 */
     3ca:	31 97       	sbiw	r30, 0x01	; 1
     3cc:	36 e1       	ldi	r19, 0x16	; 22
     3ce:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x17;	/* R17 */
     3d0:	31 97       	sbiw	r30, 0x01	; 1
     3d2:	37 e1       	ldi	r19, 0x17	; 23
     3d4:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x18;	/* R18 */
     3d6:	31 97       	sbiw	r30, 0x01	; 1
     3d8:	38 e1       	ldi	r19, 0x18	; 24
     3da:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x19;	/* R19 */
     3dc:	31 97       	sbiw	r30, 0x01	; 1
     3de:	39 e1       	ldi	r19, 0x19	; 25
     3e0:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x20;	/* R20 */
     3e2:	31 97       	sbiw	r30, 0x01	; 1
     3e4:	30 e2       	ldi	r19, 0x20	; 32
     3e6:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x21;	/* R21 */
     3e8:	31 97       	sbiw	r30, 0x01	; 1
     3ea:	31 e2       	ldi	r19, 0x21	; 33
     3ec:	30 83       	st	Z, r19
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x22;	/* R22 */
     3ee:	31 97       	sbiw	r30, 0x01	; 1
     3f0:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x23;	/* R23 */
     3f2:	31 97       	sbiw	r30, 0x01	; 1
     3f4:	23 e2       	ldi	r18, 0x23	; 35
     3f6:	20 83       	st	Z, r18
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( uint16_t ) pvParameters;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     3f8:	31 97       	sbiw	r30, 0x01	; 1
     3fa:	40 83       	st	Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( StackType_t ) ( usAddress & ( uint16_t ) 0x00ff );
     3fc:	31 97       	sbiw	r30, 0x01	; 1
     3fe:	50 83       	st	Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( StackType_t ) 0x26;	/* R26 X */
     400:	31 97       	sbiw	r30, 0x01	; 1
     402:	26 e2       	ldi	r18, 0x26	; 38
     404:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x27;	/* R27 */
     406:	31 97       	sbiw	r30, 0x01	; 1
     408:	27 e2       	ldi	r18, 0x27	; 39
     40a:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x28;	/* R28 Y */
     40c:	31 97       	sbiw	r30, 0x01	; 1
     40e:	28 e2       	ldi	r18, 0x28	; 40
     410:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x29;	/* R29 */
     412:	31 97       	sbiw	r30, 0x01	; 1
     414:	29 e2       	ldi	r18, 0x29	; 41
     416:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x30;	/* R30 Z */
     418:	31 97       	sbiw	r30, 0x01	; 1
     41a:	20 e3       	ldi	r18, 0x30	; 48
     41c:	20 83       	st	Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( StackType_t ) 0x031;	/* R31 */
     41e:	31 97       	sbiw	r30, 0x01	; 1
     420:	21 e3       	ldi	r18, 0x31	; 49
     422:	20 83       	st	Z, r18
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
     424:	86 97       	sbiw	r24, 0x26	; 38
     426:	08 95       	ret

00000428 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( uint8_t ) ( ulCompareMatch & ( uint32_t ) 0xff );
	OCR1AH = ucHighByte;
     428:	10 92 89 00 	sts	0x0089, r1
	OCR1AL = ucLowByte;
     42c:	8c e7       	ldi	r24, 0x7C	; 124
     42e:	80 93 88 00 	sts	0x0088, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
     432:	8b e0       	ldi	r24, 0x0B	; 11
     434:	80 93 81 00 	sts	0x0081, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK1;
     438:	ef e6       	ldi	r30, 0x6F	; 111
     43a:	f0 e0       	ldi	r31, 0x00	; 0
     43c:	80 81       	ld	r24, Z
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
     43e:	82 60       	ori	r24, 0x02	; 2
	TIMSK1 = ucLowByte;
     440:	80 83       	st	Z, r24
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
     442:	a0 91 ee 05 	lds	r26, 0x05EE
     446:	b0 91 ef 05 	lds	r27, 0x05EF
     44a:	cd 91       	ld	r28, X+
     44c:	cd bf       	out	0x3d, r28	; 61
     44e:	dd 91       	ld	r29, X+
     450:	de bf       	out	0x3e, r29	; 62
     452:	ff 91       	pop	r31
     454:	ef 91       	pop	r30
     456:	df 91       	pop	r29
     458:	cf 91       	pop	r28
     45a:	bf 91       	pop	r27
     45c:	af 91       	pop	r26
     45e:	9f 91       	pop	r25
     460:	8f 91       	pop	r24
     462:	7f 91       	pop	r23
     464:	6f 91       	pop	r22
     466:	5f 91       	pop	r21
     468:	4f 91       	pop	r20
     46a:	3f 91       	pop	r19
     46c:	2f 91       	pop	r18
     46e:	1f 91       	pop	r17
     470:	0f 91       	pop	r16
     472:	ff 90       	pop	r15
     474:	ef 90       	pop	r14
     476:	df 90       	pop	r13
     478:	cf 90       	pop	r12
     47a:	bf 90       	pop	r11
     47c:	af 90       	pop	r10
     47e:	9f 90       	pop	r9
     480:	8f 90       	pop	r8
     482:	7f 90       	pop	r7
     484:	6f 90       	pop	r6
     486:	5f 90       	pop	r5
     488:	4f 90       	pop	r4
     48a:	3f 90       	pop	r3
     48c:	2f 90       	pop	r2
     48e:	1f 90       	pop	r1
     490:	0f 90       	pop	r0
     492:	0f be       	out	0x3f, r0	; 63
     494:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
     496:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
     498:	81 e0       	ldi	r24, 0x01	; 1
     49a:	08 95       	ret

0000049c <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     49c:	0f 92       	push	r0
     49e:	0f b6       	in	r0, 0x3f	; 63
     4a0:	f8 94       	cli
     4a2:	0f 92       	push	r0
     4a4:	1f 92       	push	r1
     4a6:	11 24       	eor	r1, r1
     4a8:	2f 92       	push	r2
     4aa:	3f 92       	push	r3
     4ac:	4f 92       	push	r4
     4ae:	5f 92       	push	r5
     4b0:	6f 92       	push	r6
     4b2:	7f 92       	push	r7
     4b4:	8f 92       	push	r8
     4b6:	9f 92       	push	r9
     4b8:	af 92       	push	r10
     4ba:	bf 92       	push	r11
     4bc:	cf 92       	push	r12
     4be:	df 92       	push	r13
     4c0:	ef 92       	push	r14
     4c2:	ff 92       	push	r15
     4c4:	0f 93       	push	r16
     4c6:	1f 93       	push	r17
     4c8:	2f 93       	push	r18
     4ca:	3f 93       	push	r19
     4cc:	4f 93       	push	r20
     4ce:	5f 93       	push	r21
     4d0:	6f 93       	push	r22
     4d2:	7f 93       	push	r23
     4d4:	8f 93       	push	r24
     4d6:	9f 93       	push	r25
     4d8:	af 93       	push	r26
     4da:	bf 93       	push	r27
     4dc:	cf 93       	push	r28
     4de:	df 93       	push	r29
     4e0:	ef 93       	push	r30
     4e2:	ff 93       	push	r31
     4e4:	a0 91 ee 05 	lds	r26, 0x05EE
     4e8:	b0 91 ef 05 	lds	r27, 0x05EF
     4ec:	0d b6       	in	r0, 0x3d	; 61
     4ee:	0d 92       	st	X+, r0
     4f0:	0e b6       	in	r0, 0x3e	; 62
     4f2:	0d 92       	st	X+, r0
	vTaskSwitchContext();
     4f4:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
     4f8:	a0 91 ee 05 	lds	r26, 0x05EE
     4fc:	b0 91 ef 05 	lds	r27, 0x05EF
     500:	cd 91       	ld	r28, X+
     502:	cd bf       	out	0x3d, r28	; 61
     504:	dd 91       	ld	r29, X+
     506:	de bf       	out	0x3e, r29	; 62
     508:	ff 91       	pop	r31
     50a:	ef 91       	pop	r30
     50c:	df 91       	pop	r29
     50e:	cf 91       	pop	r28
     510:	bf 91       	pop	r27
     512:	af 91       	pop	r26
     514:	9f 91       	pop	r25
     516:	8f 91       	pop	r24
     518:	7f 91       	pop	r23
     51a:	6f 91       	pop	r22
     51c:	5f 91       	pop	r21
     51e:	4f 91       	pop	r20
     520:	3f 91       	pop	r19
     522:	2f 91       	pop	r18
     524:	1f 91       	pop	r17
     526:	0f 91       	pop	r16
     528:	ff 90       	pop	r15
     52a:	ef 90       	pop	r14
     52c:	df 90       	pop	r13
     52e:	cf 90       	pop	r12
     530:	bf 90       	pop	r11
     532:	af 90       	pop	r10
     534:	9f 90       	pop	r9
     536:	8f 90       	pop	r8
     538:	7f 90       	pop	r7
     53a:	6f 90       	pop	r6
     53c:	5f 90       	pop	r5
     53e:	4f 90       	pop	r4
     540:	3f 90       	pop	r3
     542:	2f 90       	pop	r2
     544:	1f 90       	pop	r1
     546:	0f 90       	pop	r0
     548:	0f be       	out	0x3f, r0	; 63
     54a:	0f 90       	pop	r0

	asm volatile ( "ret" );
     54c:	08 95       	ret

0000054e <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     54e:	0f 92       	push	r0
     550:	0f b6       	in	r0, 0x3f	; 63
     552:	f8 94       	cli
     554:	0f 92       	push	r0
     556:	1f 92       	push	r1
     558:	11 24       	eor	r1, r1
     55a:	2f 92       	push	r2
     55c:	3f 92       	push	r3
     55e:	4f 92       	push	r4
     560:	5f 92       	push	r5
     562:	6f 92       	push	r6
     564:	7f 92       	push	r7
     566:	8f 92       	push	r8
     568:	9f 92       	push	r9
     56a:	af 92       	push	r10
     56c:	bf 92       	push	r11
     56e:	cf 92       	push	r12
     570:	df 92       	push	r13
     572:	ef 92       	push	r14
     574:	ff 92       	push	r15
     576:	0f 93       	push	r16
     578:	1f 93       	push	r17
     57a:	2f 93       	push	r18
     57c:	3f 93       	push	r19
     57e:	4f 93       	push	r20
     580:	5f 93       	push	r21
     582:	6f 93       	push	r22
     584:	7f 93       	push	r23
     586:	8f 93       	push	r24
     588:	9f 93       	push	r25
     58a:	af 93       	push	r26
     58c:	bf 93       	push	r27
     58e:	cf 93       	push	r28
     590:	df 93       	push	r29
     592:	ef 93       	push	r30
     594:	ff 93       	push	r31
     596:	a0 91 ee 05 	lds	r26, 0x05EE
     59a:	b0 91 ef 05 	lds	r27, 0x05EF
     59e:	0d b6       	in	r0, 0x3d	; 61
     5a0:	0d 92       	st	X+, r0
     5a2:	0e b6       	in	r0, 0x3e	; 62
     5a4:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
     5a6:	0e 94 42 07 	call	0xe84	; 0xe84 <xTaskIncrementTick>
     5aa:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
     5ac:	0e 94 e0 08 	call	0x11c0	; 0x11c0 <vTaskSwitchContext>
	}
	portRESTORE_CONTEXT();
     5b0:	a0 91 ee 05 	lds	r26, 0x05EE
     5b4:	b0 91 ef 05 	lds	r27, 0x05EF
     5b8:	cd 91       	ld	r28, X+
     5ba:	cd bf       	out	0x3d, r28	; 61
     5bc:	dd 91       	ld	r29, X+
     5be:	de bf       	out	0x3e, r29	; 62
     5c0:	ff 91       	pop	r31
     5c2:	ef 91       	pop	r30
     5c4:	df 91       	pop	r29
     5c6:	cf 91       	pop	r28
     5c8:	bf 91       	pop	r27
     5ca:	af 91       	pop	r26
     5cc:	9f 91       	pop	r25
     5ce:	8f 91       	pop	r24
     5d0:	7f 91       	pop	r23
     5d2:	6f 91       	pop	r22
     5d4:	5f 91       	pop	r21
     5d6:	4f 91       	pop	r20
     5d8:	3f 91       	pop	r19
     5da:	2f 91       	pop	r18
     5dc:	1f 91       	pop	r17
     5de:	0f 91       	pop	r16
     5e0:	ff 90       	pop	r15
     5e2:	ef 90       	pop	r14
     5e4:	df 90       	pop	r13
     5e6:	cf 90       	pop	r12
     5e8:	bf 90       	pop	r11
     5ea:	af 90       	pop	r10
     5ec:	9f 90       	pop	r9
     5ee:	8f 90       	pop	r8
     5f0:	7f 90       	pop	r7
     5f2:	6f 90       	pop	r6
     5f4:	5f 90       	pop	r5
     5f6:	4f 90       	pop	r4
     5f8:	3f 90       	pop	r3
     5fa:	2f 90       	pop	r2
     5fc:	1f 90       	pop	r1
     5fe:	0f 90       	pop	r0
     600:	0f be       	out	0x3f, r0	; 63
     602:	0f 90       	pop	r0

	asm volatile ( "ret" );
     604:	08 95       	ret

00000606 <__vector_11>:
	 * count is incremented after the context is saved.
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
     606:	0e 94 a7 02 	call	0x54e	; 0x54e <vPortYieldFromTick>
		asm volatile ( "reti" );
     60a:	18 95       	reti

0000060c <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     60c:	cf 93       	push	r28
     60e:	df 93       	push	r29
     610:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
     612:	0e 94 3c 07 	call	0xe78	; 0xe78 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
     616:	80 91 a0 01 	lds	r24, 0x01A0
     61a:	90 91 a1 01 	lds	r25, 0x01A1
     61e:	89 2b       	or	r24, r25
     620:	31 f4       	brne	.+12     	; 0x62e <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( uint8_t * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) );
     622:	85 ea       	ldi	r24, 0xA5	; 165
     624:	91 e0       	ldi	r25, 0x01	; 1
     626:	90 93 a1 01 	sts	0x01A1, r25
     62a:	80 93 a0 01 	sts	0x01A0, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
     62e:	40 91 a2 01 	lds	r20, 0x01A2
     632:	50 91 a3 01 	lds	r21, 0x01A3
     636:	9e 01       	movw	r18, r28
     638:	24 0f       	add	r18, r20
     63a:	35 1f       	adc	r19, r21
     63c:	27 3e       	cpi	r18, 0xE7	; 231
     63e:	83 e0       	ldi	r24, 0x03	; 3
     640:	38 07       	cpc	r19, r24
     642:	70 f4       	brcc	.+28     	; 0x660 <pvPortMalloc+0x54>
     644:	42 17       	cp	r20, r18
     646:	53 07       	cpc	r21, r19
     648:	70 f4       	brcc	.+28     	; 0x666 <pvPortMalloc+0x5a>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
     64a:	c0 91 a0 01 	lds	r28, 0x01A0
     64e:	d0 91 a1 01 	lds	r29, 0x01A1
     652:	c4 0f       	add	r28, r20
     654:	d5 1f       	adc	r29, r21
			xNextFreeByte += xWantedSize;
     656:	30 93 a3 01 	sts	0x01A3, r19
     65a:	20 93 a2 01 	sts	0x01A2, r18
     65e:	05 c0       	rjmp	.+10     	; 0x66a <pvPortMalloc+0x5e>

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL;
     660:	c0 e0       	ldi	r28, 0x00	; 0
     662:	d0 e0       	ldi	r29, 0x00	; 0
     664:	02 c0       	rjmp	.+4      	; 0x66a <pvPortMalloc+0x5e>
     666:	c0 e0       	ldi	r28, 0x00	; 0
     668:	d0 e0       	ldi	r29, 0x00	; 0
			xNextFreeByte += xWantedSize;
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     66a:	0e 94 01 08 	call	0x1002	; 0x1002 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
     66e:	ce 01       	movw	r24, r28
     670:	df 91       	pop	r29
     672:	cf 91       	pop	r28
     674:	08 95       	ret

00000676 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     676:	08 95       	ret

00000678 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
{
     678:	1f 93       	push	r17
     67a:	cf 93       	push	r28
     67c:	df 93       	push	r29
     67e:	ec 01       	movw	r28, r24
     680:	14 2f       	mov	r17, r20
BaseType_t xReturn = pdFALSE;

	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
     682:	8c 8d       	ldd	r24, Y+28	; 0x1c
     684:	88 23       	and	r24, r24
     686:	e9 f1       	breq	.+122    	; 0x702 <prvCopyDataToQueue+0x8a>
				mtCOVERAGE_TEST_MARKER();
			}
		}
		#endif /* configUSE_MUTEXES */
	}
	else if( xPosition == queueSEND_TO_BACK )
     688:	41 11       	cpse	r20, r1
     68a:	17 c0       	rjmp	.+46     	; 0x6ba <prvCopyDataToQueue+0x42>
	{
		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
     68c:	48 2f       	mov	r20, r24
     68e:	50 e0       	ldi	r21, 0x00	; 0
     690:	8c 81       	ldd	r24, Y+4	; 0x04
     692:	9d 81       	ldd	r25, Y+5	; 0x05
     694:	0e 94 81 0a 	call	0x1502	; 0x1502 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
     698:	2c 8d       	ldd	r18, Y+28	; 0x1c
     69a:	8c 81       	ldd	r24, Y+4	; 0x04
     69c:	9d 81       	ldd	r25, Y+5	; 0x05
     69e:	82 0f       	add	r24, r18
     6a0:	91 1d       	adc	r25, r1
     6a2:	9d 83       	std	Y+5, r25	; 0x05
     6a4:	8c 83       	std	Y+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     6a6:	2a 81       	ldd	r18, Y+2	; 0x02
     6a8:	3b 81       	ldd	r19, Y+3	; 0x03
     6aa:	82 17       	cp	r24, r18
     6ac:	93 07       	cpc	r25, r19
     6ae:	48 f1       	brcs	.+82     	; 0x702 <prvCopyDataToQueue+0x8a>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
     6b0:	88 81       	ld	r24, Y
     6b2:	99 81       	ldd	r25, Y+1	; 0x01
     6b4:	9d 83       	std	Y+5, r25	; 0x05
     6b6:	8c 83       	std	Y+4, r24	; 0x04
     6b8:	24 c0       	rjmp	.+72     	; 0x702 <prvCopyDataToQueue+0x8a>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     6ba:	48 2f       	mov	r20, r24
     6bc:	50 e0       	ldi	r21, 0x00	; 0
     6be:	8e 81       	ldd	r24, Y+6	; 0x06
     6c0:	9f 81       	ldd	r25, Y+7	; 0x07
     6c2:	0e 94 81 0a 	call	0x1502	; 0x1502 <memcpy>
		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
     6c6:	2c 8d       	ldd	r18, Y+28	; 0x1c
     6c8:	30 e0       	ldi	r19, 0x00	; 0
     6ca:	31 95       	neg	r19
     6cc:	21 95       	neg	r18
     6ce:	31 09       	sbc	r19, r1
     6d0:	8e 81       	ldd	r24, Y+6	; 0x06
     6d2:	9f 81       	ldd	r25, Y+7	; 0x07
     6d4:	82 0f       	add	r24, r18
     6d6:	93 1f       	adc	r25, r19
     6d8:	9f 83       	std	Y+7, r25	; 0x07
     6da:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
     6dc:	68 81       	ld	r22, Y
     6de:	79 81       	ldd	r23, Y+1	; 0x01
     6e0:	86 17       	cp	r24, r22
     6e2:	97 07       	cpc	r25, r23
     6e4:	30 f4       	brcc	.+12     	; 0x6f2 <prvCopyDataToQueue+0x7a>
		{
			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
     6e6:	8a 81       	ldd	r24, Y+2	; 0x02
     6e8:	9b 81       	ldd	r25, Y+3	; 0x03
     6ea:	28 0f       	add	r18, r24
     6ec:	39 1f       	adc	r19, r25
     6ee:	3f 83       	std	Y+7, r19	; 0x07
     6f0:	2e 83       	std	Y+6, r18	; 0x06
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}

		if( xPosition == queueOVERWRITE )
     6f2:	12 30       	cpi	r17, 0x02	; 2
     6f4:	31 f4       	brne	.+12     	; 0x702 <prvCopyDataToQueue+0x8a>
		{
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     6f6:	8a 8d       	ldd	r24, Y+26	; 0x1a
     6f8:	88 23       	and	r24, r24
     6fa:	19 f0       	breq	.+6      	; 0x702 <prvCopyDataToQueue+0x8a>
			{
				/* An item is not being added but overwritten, so subtract
				one from the recorded number of items in the queue so when
				one is added again below the number of recorded items remains
				correct. */
				--( pxQueue->uxMessagesWaiting );
     6fc:	8a 8d       	ldd	r24, Y+26	; 0x1a
     6fe:	81 50       	subi	r24, 0x01	; 1
     700:	8a 8f       	std	Y+26, r24	; 0x1a
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}

	++( pxQueue->uxMessagesWaiting );
     702:	8a 8d       	ldd	r24, Y+26	; 0x1a
     704:	8f 5f       	subi	r24, 0xFF	; 255
     706:	8a 8f       	std	Y+26, r24	; 0x1a

	return xReturn;
}
     708:	80 e0       	ldi	r24, 0x00	; 0
     70a:	df 91       	pop	r29
     70c:	cf 91       	pop	r28
     70e:	1f 91       	pop	r17
     710:	08 95       	ret

00000712 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
     712:	fc 01       	movw	r30, r24
     714:	cb 01       	movw	r24, r22
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
     716:	44 8d       	ldd	r20, Z+28	; 0x1c
     718:	44 23       	and	r20, r20
     71a:	a1 f0       	breq	.+40     	; 0x744 <prvCopyDataFromQueue+0x32>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
     71c:	50 e0       	ldi	r21, 0x00	; 0
     71e:	26 81       	ldd	r18, Z+6	; 0x06
     720:	37 81       	ldd	r19, Z+7	; 0x07
     722:	24 0f       	add	r18, r20
     724:	35 1f       	adc	r19, r21
     726:	37 83       	std	Z+7, r19	; 0x07
     728:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
     72a:	62 81       	ldd	r22, Z+2	; 0x02
     72c:	73 81       	ldd	r23, Z+3	; 0x03
     72e:	26 17       	cp	r18, r22
     730:	37 07       	cpc	r19, r23
     732:	20 f0       	brcs	.+8      	; 0x73c <prvCopyDataFromQueue+0x2a>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
     734:	20 81       	ld	r18, Z
     736:	31 81       	ldd	r19, Z+1	; 0x01
     738:	37 83       	std	Z+7, r19	; 0x07
     73a:	26 83       	std	Z+6, r18	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
     73c:	66 81       	ldd	r22, Z+6	; 0x06
     73e:	77 81       	ldd	r23, Z+7	; 0x07
     740:	0e 94 81 0a 	call	0x1502	; 0x1502 <memcpy>
     744:	08 95       	ret

00000746 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( Queue_t * const pxQueue )
{
     746:	0f 93       	push	r16
     748:	1f 93       	push	r17
     74a:	cf 93       	push	r28
     74c:	df 93       	push	r29
     74e:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
     750:	0f b6       	in	r0, 0x3f	; 63
     752:	f8 94       	cli
     754:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     756:	8e 8d       	ldd	r24, Y+30	; 0x1e
     758:	18 16       	cp	r1, r24
     75a:	b4 f4       	brge	.+44     	; 0x788 <prvUnlockQueue+0x42>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     75c:	89 89       	ldd	r24, Y+17	; 0x11
     75e:	88 23       	and	r24, r24
     760:	99 f0       	breq	.+38     	; 0x788 <prvUnlockQueue+0x42>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     762:	8e 01       	movw	r16, r28
     764:	0f 5e       	subi	r16, 0xEF	; 239
     766:	1f 4f       	sbci	r17, 0xFF	; 255
     768:	03 c0       	rjmp	.+6      	; 0x770 <prvUnlockQueue+0x2a>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     76a:	89 89       	ldd	r24, Y+17	; 0x11
     76c:	88 23       	and	r24, r24
     76e:	61 f0       	breq	.+24     	; 0x788 <prvUnlockQueue+0x42>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     770:	c8 01       	movw	r24, r16
     772:	0e 94 6a 09 	call	0x12d4	; 0x12d4 <xTaskRemoveFromEventList>
     776:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
     778:	0e 94 f6 09 	call	0x13ec	; 0x13ec <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
     77c:	8e 8d       	ldd	r24, Y+30	; 0x1e
     77e:	81 50       	subi	r24, 0x01	; 1
     780:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
     782:	8e 8d       	ldd	r24, Y+30	; 0x1e
     784:	18 16       	cp	r1, r24
     786:	8c f3       	brlt	.-30     	; 0x76a <prvUnlockQueue+0x24>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
     788:	8f ef       	ldi	r24, 0xFF	; 255
     78a:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
     78c:	0f 90       	pop	r0
     78e:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
     790:	0f b6       	in	r0, 0x3f	; 63
     792:	f8 94       	cli
     794:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     796:	8d 8d       	ldd	r24, Y+29	; 0x1d
     798:	18 16       	cp	r1, r24
     79a:	b4 f4       	brge	.+44     	; 0x7c8 <prvUnlockQueue+0x82>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     79c:	88 85       	ldd	r24, Y+8	; 0x08
     79e:	88 23       	and	r24, r24
     7a0:	99 f0       	breq	.+38     	; 0x7c8 <prvUnlockQueue+0x82>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     7a2:	8e 01       	movw	r16, r28
     7a4:	08 5f       	subi	r16, 0xF8	; 248
     7a6:	1f 4f       	sbci	r17, 0xFF	; 255
     7a8:	03 c0       	rjmp	.+6      	; 0x7b0 <prvUnlockQueue+0x6a>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     7aa:	88 85       	ldd	r24, Y+8	; 0x08
     7ac:	88 23       	and	r24, r24
     7ae:	61 f0       	breq	.+24     	; 0x7c8 <prvUnlockQueue+0x82>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
     7b0:	c8 01       	movw	r24, r16
     7b2:	0e 94 6a 09 	call	0x12d4	; 0x12d4 <xTaskRemoveFromEventList>
     7b6:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
     7b8:	0e 94 f6 09 	call	0x13ec	; 0x13ec <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
     7bc:	8d 8d       	ldd	r24, Y+29	; 0x1d
     7be:	81 50       	subi	r24, 0x01	; 1
     7c0:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
     7c2:	8d 8d       	ldd	r24, Y+29	; 0x1d
     7c4:	18 16       	cp	r1, r24
     7c6:	8c f3       	brlt	.-30     	; 0x7aa <prvUnlockQueue+0x64>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
     7c8:	8f ef       	ldi	r24, 0xFF	; 255
     7ca:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
     7cc:	0f 90       	pop	r0
     7ce:	0f be       	out	0x3f, r0	; 63
}
     7d0:	df 91       	pop	r29
     7d2:	cf 91       	pop	r28
     7d4:	1f 91       	pop	r17
     7d6:	0f 91       	pop	r16
     7d8:	08 95       	ret

000007da <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
{
     7da:	cf 93       	push	r28
     7dc:	df 93       	push	r29
     7de:	ec 01       	movw	r28, r24
Queue_t * const pxQueue = ( Queue_t * ) xQueue;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
     7e0:	0f b6       	in	r0, 0x3f	; 63
     7e2:	f8 94       	cli
     7e4:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
     7e6:	88 81       	ld	r24, Y
     7e8:	99 81       	ldd	r25, Y+1	; 0x01
     7ea:	2c 8d       	ldd	r18, Y+28	; 0x1c
     7ec:	30 e0       	ldi	r19, 0x00	; 0
     7ee:	7b 8d       	ldd	r23, Y+27	; 0x1b
     7f0:	72 9f       	mul	r23, r18
     7f2:	a0 01       	movw	r20, r0
     7f4:	73 9f       	mul	r23, r19
     7f6:	50 0d       	add	r21, r0
     7f8:	11 24       	eor	r1, r1
     7fa:	fc 01       	movw	r30, r24
     7fc:	e4 0f       	add	r30, r20
     7fe:	f5 1f       	adc	r31, r21
     800:	fb 83       	std	Y+3, r31	; 0x03
     802:	ea 83       	std	Y+2, r30	; 0x02
		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
     804:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
     806:	9d 83       	std	Y+5, r25	; 0x05
     808:	8c 83       	std	Y+4, r24	; 0x04
		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
     80a:	42 1b       	sub	r20, r18
     80c:	53 0b       	sbc	r21, r19
     80e:	84 0f       	add	r24, r20
     810:	95 1f       	adc	r25, r21
     812:	9f 83       	std	Y+7, r25	; 0x07
     814:	8e 83       	std	Y+6, r24	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
     816:	8f ef       	ldi	r24, 0xFF	; 255
     818:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
     81a:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
     81c:	61 11       	cpse	r22, r1
     81e:	0c c0       	rjmp	.+24     	; 0x838 <xQueueGenericReset+0x5e>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     820:	88 85       	ldd	r24, Y+8	; 0x08
     822:	88 23       	and	r24, r24
     824:	89 f0       	breq	.+34     	; 0x848 <xQueueGenericReset+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     826:	ce 01       	movw	r24, r28
     828:	08 96       	adiw	r24, 0x08	; 8
     82a:	0e 94 6a 09 	call	0x12d4	; 0x12d4 <xTaskRemoveFromEventList>
     82e:	81 30       	cpi	r24, 0x01	; 1
     830:	59 f4       	brne	.+22     	; 0x848 <xQueueGenericReset+0x6e>
				{
					queueYIELD_IF_USING_PREEMPTION();
     832:	0e 94 4e 02 	call	0x49c	; 0x49c <vPortYield>
     836:	08 c0       	rjmp	.+16     	; 0x848 <xQueueGenericReset+0x6e>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
     838:	ce 01       	movw	r24, r28
     83a:	08 96       	adiw	r24, 0x08	; 8
     83c:	0e 94 1e 01 	call	0x23c	; 0x23c <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
     840:	ce 01       	movw	r24, r28
     842:	41 96       	adiw	r24, 0x11	; 17
     844:	0e 94 1e 01 	call	0x23c	; 0x23c <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
     848:	0f 90       	pop	r0
     84a:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
     84c:	81 e0       	ldi	r24, 0x01	; 1
     84e:	df 91       	pop	r29
     850:	cf 91       	pop	r28
     852:	08 95       	ret

00000854 <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
{
     854:	0f 93       	push	r16
     856:	1f 93       	push	r17
     858:	cf 93       	push	r28
     85a:	df 93       	push	r29
     85c:	08 2f       	mov	r16, r24
     85e:	16 2f       	mov	r17, r22
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	configASSERT( uxQueueLength > ( UBaseType_t ) 0 );

	if( uxItemSize == ( UBaseType_t ) 0 )
     860:	66 23       	and	r22, r22
     862:	c9 f0       	breq	.+50     	; 0x896 <xQueueGenericCreate+0x42>
	}
	else
	{
		/* The queue is one byte longer than asked for to make wrap checking
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     864:	86 9f       	mul	r24, r22
     866:	c0 01       	movw	r24, r0
     868:	11 24       	eor	r1, r1
	}

	/* Allocate the new queue structure and storage area. */
	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     86a:	80 96       	adiw	r24, 0x20	; 32
     86c:	0e 94 06 03 	call	0x60c	; 0x60c <pvPortMalloc>
     870:	ec 01       	movw	r28, r24

	if( pxNewQueue != NULL )
     872:	00 97       	sbiw	r24, 0x00	; 0
     874:	21 f4       	brne	.+8      	; 0x87e <xQueueGenericCreate+0x2a>
     876:	16 c0       	rjmp	.+44     	; 0x8a4 <xQueueGenericCreate+0x50>
		{
			/* No RAM was allocated for the queue storage area, but PC head
			cannot be set to NULL because NULL is used as a key to say the queue
			is used as a mutex.  Therefore just set pcHead to point to the queue
			as a benign value that is known to be within the memory map. */
			pxNewQueue->pcHead = ( int8_t * ) pxNewQueue;
     878:	d9 83       	std	Y+1, r29	; 0x01
     87a:	c8 83       	st	Y, r28
     87c:	05 c0       	rjmp	.+10     	; 0x888 <xQueueGenericCreate+0x34>
		}
		else
		{
			/* Jump past the queue structure to find the location of the queue
			storage area. */
			pxNewQueue->pcHead = ( ( int8_t * ) pxNewQueue ) + sizeof( Queue_t );
     87e:	9c 01       	movw	r18, r24
     880:	21 5e       	subi	r18, 0xE1	; 225
     882:	3f 4f       	sbci	r19, 0xFF	; 255
     884:	39 83       	std	Y+1, r19	; 0x01
     886:	28 83       	st	Y, r18
		}

		/* Initialise the queue members as described above where the queue type
		is defined. */
		pxNewQueue->uxLength = uxQueueLength;
     888:	0b 8f       	std	Y+27, r16	; 0x1b
		pxNewQueue->uxItemSize = uxItemSize;
     88a:	1c 8f       	std	Y+28, r17	; 0x1c
		( void ) xQueueGenericReset( pxNewQueue, pdTRUE );
     88c:	61 e0       	ldi	r22, 0x01	; 1
     88e:	ce 01       	movw	r24, r28
     890:	0e 94 ed 03 	call	0x7da	; 0x7da <xQueueGenericReset>
     894:	07 c0       	rjmp	.+14     	; 0x8a4 <xQueueGenericCreate+0x50>
		easier/faster. */
		xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
	}

	/* Allocate the new queue structure and storage area. */
	pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
     896:	8f e1       	ldi	r24, 0x1F	; 31
     898:	90 e0       	ldi	r25, 0x00	; 0
     89a:	0e 94 06 03 	call	0x60c	; 0x60c <pvPortMalloc>
     89e:	ec 01       	movw	r28, r24

	if( pxNewQueue != NULL )
     8a0:	00 97       	sbiw	r24, 0x00	; 0
     8a2:	51 f7       	brne	.-44     	; 0x878 <xQueueGenericCreate+0x24>
	}

	configASSERT( xReturn );

	return xReturn;
}
     8a4:	ce 01       	movw	r24, r28
     8a6:	df 91       	pop	r29
     8a8:	cf 91       	pop	r28
     8aa:	1f 91       	pop	r17
     8ac:	0f 91       	pop	r16
     8ae:	08 95       	ret

000008b0 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
{
     8b0:	9f 92       	push	r9
     8b2:	af 92       	push	r10
     8b4:	bf 92       	push	r11
     8b6:	cf 92       	push	r12
     8b8:	df 92       	push	r13
     8ba:	ef 92       	push	r14
     8bc:	ff 92       	push	r15
     8be:	0f 93       	push	r16
     8c0:	1f 93       	push	r17
     8c2:	cf 93       	push	r28
     8c4:	df 93       	push	r29
     8c6:	00 d0       	rcall	.+0      	; 0x8c8 <xQueueGenericSend+0x18>
     8c8:	00 d0       	rcall	.+0      	; 0x8ca <xQueueGenericSend+0x1a>
     8ca:	1f 92       	push	r1
     8cc:	cd b7       	in	r28, 0x3d	; 61
     8ce:	de b7       	in	r29, 0x3e	; 62
     8d0:	8c 01       	movw	r16, r24
     8d2:	6b 01       	movw	r12, r22
     8d4:	5d 83       	std	Y+5, r21	; 0x05
     8d6:	4c 83       	std	Y+4, r20	; 0x04
     8d8:	a2 2e       	mov	r10, r18
BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
     8da:	b1 2c       	mov	r11, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     8dc:	99 24       	eor	r9, r9
     8de:	93 94       	inc	r9
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     8e0:	7c 01       	movw	r14, r24
     8e2:	88 e0       	ldi	r24, 0x08	; 8
     8e4:	e8 0e       	add	r14, r24
     8e6:	f1 1c       	adc	r15, r1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
     8e8:	0f b6       	in	r0, 0x3f	; 63
     8ea:	f8 94       	cli
     8ec:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  The running task must be the
			highest priority task wanting to access the queue.  If the head item
			in the queue is to be overwritten then it does not matter if the
			queue is full. */
			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
     8ee:	f8 01       	movw	r30, r16
     8f0:	92 8d       	ldd	r25, Z+26	; 0x1a
     8f2:	83 8d       	ldd	r24, Z+27	; 0x1b
     8f4:	98 17       	cp	r25, r24
     8f6:	18 f0       	brcs	.+6      	; 0x8fe <xQueueGenericSend+0x4e>
     8f8:	f2 e0       	ldi	r31, 0x02	; 2
     8fa:	af 12       	cpse	r10, r31
     8fc:	19 c0       	rjmp	.+50     	; 0x930 <__stack+0x31>
			{
				traceQUEUE_SEND( pxQueue );
				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
     8fe:	4a 2d       	mov	r20, r10
     900:	b6 01       	movw	r22, r12
     902:	c8 01       	movw	r24, r16
     904:	0e 94 3c 03 	call	0x678	; 0x678 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     908:	f8 01       	movw	r30, r16
     90a:	91 89       	ldd	r25, Z+17	; 0x11
     90c:	99 23       	and	r25, r25
     90e:	49 f0       	breq	.+18     	; 0x922 <__stack+0x23>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
     910:	c8 01       	movw	r24, r16
     912:	41 96       	adiw	r24, 0x11	; 17
     914:	0e 94 6a 09 	call	0x12d4	; 0x12d4 <xTaskRemoveFromEventList>
     918:	81 30       	cpi	r24, 0x01	; 1
     91a:	31 f4       	brne	.+12     	; 0x928 <__stack+0x29>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							queueYIELD_IF_USING_PREEMPTION();
     91c:	0e 94 4e 02 	call	0x49c	; 0x49c <vPortYield>
     920:	03 c0       	rjmp	.+6      	; 0x928 <__stack+0x29>
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
					}
					else if( xYieldRequired != pdFALSE )
     922:	81 11       	cpse	r24, r1
					{
						/* This path is a special case that will only get
						executed if the task was holding multiple mutexes and
						the mutexes were given back in an order that is
						different to that in which they were taken. */
						queueYIELD_IF_USING_PREEMPTION();
     924:	0e 94 4e 02 	call	0x49c	; 0x49c <vPortYield>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
     928:	0f 90       	pop	r0
     92a:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     92c:	81 e0       	ldi	r24, 0x01	; 1
     92e:	51 c0       	rjmp	.+162    	; 0x9d2 <__stack+0xd3>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     930:	ec 81       	ldd	r30, Y+4	; 0x04
     932:	fd 81       	ldd	r31, Y+5	; 0x05
     934:	ef 2b       	or	r30, r31
     936:	21 f4       	brne	.+8      	; 0x940 <__stack+0x41>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     938:	0f 90       	pop	r0
     93a:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
     93c:	80 e0       	ldi	r24, 0x00	; 0
     93e:	49 c0       	rjmp	.+146    	; 0x9d2 <__stack+0xd3>
				}
				else if( xEntryTimeSet == pdFALSE )
     940:	b1 10       	cpse	r11, r1
     942:	05 c0       	rjmp	.+10     	; 0x94e <__stack+0x4f>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     944:	ce 01       	movw	r24, r28
     946:	01 96       	adiw	r24, 0x01	; 1
     948:	0e 94 b2 09 	call	0x1364	; 0x1364 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     94c:	b9 2c       	mov	r11, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     94e:	0f 90       	pop	r0
     950:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     952:	0e 94 3c 07 	call	0xe78	; 0xe78 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     956:	0f b6       	in	r0, 0x3f	; 63
     958:	f8 94       	cli
     95a:	0f 92       	push	r0
     95c:	f8 01       	movw	r30, r16
     95e:	85 8d       	ldd	r24, Z+29	; 0x1d
     960:	8f 3f       	cpi	r24, 0xFF	; 255
     962:	09 f4       	brne	.+2      	; 0x966 <__stack+0x67>
     964:	15 8e       	std	Z+29, r1	; 0x1d
     966:	f8 01       	movw	r30, r16
     968:	86 8d       	ldd	r24, Z+30	; 0x1e
     96a:	8f 3f       	cpi	r24, 0xFF	; 255
     96c:	09 f4       	brne	.+2      	; 0x970 <__stack+0x71>
     96e:	16 8e       	std	Z+30, r1	; 0x1e
     970:	0f 90       	pop	r0
     972:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     974:	be 01       	movw	r22, r28
     976:	6c 5f       	subi	r22, 0xFC	; 252
     978:	7f 4f       	sbci	r23, 0xFF	; 255
     97a:	ce 01       	movw	r24, r28
     97c:	01 96       	adiw	r24, 0x01	; 1
     97e:	0e 94 bd 09 	call	0x137a	; 0x137a <xTaskCheckForTimeOut>
     982:	81 11       	cpse	r24, r1
     984:	20 c0       	rjmp	.+64     	; 0x9c6 <__stack+0xc7>

static BaseType_t prvIsQueueFull( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     986:	0f b6       	in	r0, 0x3f	; 63
     988:	f8 94       	cli
     98a:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
     98c:	f8 01       	movw	r30, r16
     98e:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     990:	0f 90       	pop	r0
     992:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
     994:	f8 01       	movw	r30, r16
     996:	83 8d       	ldd	r24, Z+27	; 0x1b
     998:	98 13       	cpse	r25, r24
     99a:	0f c0       	rjmp	.+30     	; 0x9ba <__stack+0xbb>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
     99c:	6c 81       	ldd	r22, Y+4	; 0x04
     99e:	7d 81       	ldd	r23, Y+5	; 0x05
     9a0:	c7 01       	movw	r24, r14
     9a2:	0e 94 3e 09 	call	0x127c	; 0x127c <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
     9a6:	c8 01       	movw	r24, r16
     9a8:	0e 94 a3 03 	call	0x746	; 0x746 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
     9ac:	0e 94 01 08 	call	0x1002	; 0x1002 <xTaskResumeAll>
     9b0:	81 11       	cpse	r24, r1
     9b2:	9a cf       	rjmp	.-204    	; 0x8e8 <xQueueGenericSend+0x38>
				{
					portYIELD_WITHIN_API();
     9b4:	0e 94 4e 02 	call	0x49c	; 0x49c <vPortYield>
     9b8:	97 cf       	rjmp	.-210    	; 0x8e8 <xQueueGenericSend+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     9ba:	c8 01       	movw	r24, r16
     9bc:	0e 94 a3 03 	call	0x746	; 0x746 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     9c0:	0e 94 01 08 	call	0x1002	; 0x1002 <xTaskResumeAll>
     9c4:	91 cf       	rjmp	.-222    	; 0x8e8 <xQueueGenericSend+0x38>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
     9c6:	c8 01       	movw	r24, r16
     9c8:	0e 94 a3 03 	call	0x746	; 0x746 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     9cc:	0e 94 01 08 	call	0x1002	; 0x1002 <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
     9d0:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     9d2:	0f 90       	pop	r0
     9d4:	0f 90       	pop	r0
     9d6:	0f 90       	pop	r0
     9d8:	0f 90       	pop	r0
     9da:	0f 90       	pop	r0
     9dc:	df 91       	pop	r29
     9de:	cf 91       	pop	r28
     9e0:	1f 91       	pop	r17
     9e2:	0f 91       	pop	r16
     9e4:	ff 90       	pop	r15
     9e6:	ef 90       	pop	r14
     9e8:	df 90       	pop	r13
     9ea:	cf 90       	pop	r12
     9ec:	bf 90       	pop	r11
     9ee:	af 90       	pop	r10
     9f0:	9f 90       	pop	r9
     9f2:	08 95       	ret

000009f4 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
     9f4:	9f 92       	push	r9
     9f6:	af 92       	push	r10
     9f8:	bf 92       	push	r11
     9fa:	cf 92       	push	r12
     9fc:	df 92       	push	r13
     9fe:	ef 92       	push	r14
     a00:	ff 92       	push	r15
     a02:	0f 93       	push	r16
     a04:	1f 93       	push	r17
     a06:	cf 93       	push	r28
     a08:	df 93       	push	r29
     a0a:	00 d0       	rcall	.+0      	; 0xa0c <xQueueGenericReceive+0x18>
     a0c:	00 d0       	rcall	.+0      	; 0xa0e <xQueueGenericReceive+0x1a>
     a0e:	1f 92       	push	r1
     a10:	cd b7       	in	r28, 0x3d	; 61
     a12:	de b7       	in	r29, 0x3e	; 62
     a14:	8c 01       	movw	r16, r24
     a16:	6b 01       	movw	r12, r22
     a18:	5d 83       	std	Y+5, r21	; 0x05
     a1a:	4c 83       	std	Y+4, r20	; 0x04
     a1c:	b2 2e       	mov	r11, r18
BaseType_t xEntryTimeSet = pdFALSE;
     a1e:	a1 2c       	mov	r10, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
     a20:	99 24       	eor	r9, r9
     a22:	93 94       	inc	r9
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     a24:	7c 01       	movw	r14, r24
     a26:	81 e1       	ldi	r24, 0x11	; 17
     a28:	e8 0e       	add	r14, r24
     a2a:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
     a2c:	0f b6       	in	r0, 0x3f	; 63
     a2e:	f8 94       	cli
     a30:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
     a32:	f8 01       	movw	r30, r16
     a34:	82 8d       	ldd	r24, Z+26	; 0x1a
     a36:	88 23       	and	r24, r24
     a38:	49 f1       	breq	.+82     	; 0xa8c <xQueueGenericReceive+0x98>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
     a3a:	e6 80       	ldd	r14, Z+6	; 0x06
     a3c:	f7 80       	ldd	r15, Z+7	; 0x07

				prvCopyDataFromQueue( pxQueue, pvBuffer );
     a3e:	b6 01       	movw	r22, r12
     a40:	c8 01       	movw	r24, r16
     a42:	0e 94 89 03 	call	0x712	; 0x712 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
     a46:	b1 10       	cpse	r11, r1
     a48:	10 c0       	rjmp	.+32     	; 0xa6a <xQueueGenericReceive+0x76>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
     a4a:	f8 01       	movw	r30, r16
     a4c:	82 8d       	ldd	r24, Z+26	; 0x1a
     a4e:	81 50       	subi	r24, 0x01	; 1
     a50:	82 8f       	std	Z+26, r24	; 0x1a
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
     a52:	80 85       	ldd	r24, Z+8	; 0x08
     a54:	88 23       	and	r24, r24
     a56:	b1 f0       	breq	.+44     	; 0xa84 <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
     a58:	c8 01       	movw	r24, r16
     a5a:	08 96       	adiw	r24, 0x08	; 8
     a5c:	0e 94 6a 09 	call	0x12d4	; 0x12d4 <xTaskRemoveFromEventList>
     a60:	81 30       	cpi	r24, 0x01	; 1
     a62:	81 f4       	brne	.+32     	; 0xa84 <xQueueGenericReceive+0x90>
						{
							queueYIELD_IF_USING_PREEMPTION();
     a64:	0e 94 4e 02 	call	0x49c	; 0x49c <vPortYield>
     a68:	0d c0       	rjmp	.+26     	; 0xa84 <xQueueGenericReceive+0x90>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
     a6a:	f8 01       	movw	r30, r16
     a6c:	f7 82       	std	Z+7, r15	; 0x07
     a6e:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
     a70:	81 89       	ldd	r24, Z+17	; 0x11
     a72:	88 23       	and	r24, r24
     a74:	39 f0       	breq	.+14     	; 0xa84 <xQueueGenericReceive+0x90>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
     a76:	c8 01       	movw	r24, r16
     a78:	41 96       	adiw	r24, 0x11	; 17
     a7a:	0e 94 6a 09 	call	0x12d4	; 0x12d4 <xTaskRemoveFromEventList>
     a7e:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
     a80:	0e 94 4e 02 	call	0x49c	; 0x49c <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
     a84:	0f 90       	pop	r0
     a86:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
     a88:	81 e0       	ldi	r24, 0x01	; 1
     a8a:	4f c0       	rjmp	.+158    	; 0xb2a <xQueueGenericReceive+0x136>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
     a8c:	4c 81       	ldd	r20, Y+4	; 0x04
     a8e:	5d 81       	ldd	r21, Y+5	; 0x05
     a90:	45 2b       	or	r20, r21
     a92:	21 f4       	brne	.+8      	; 0xa9c <xQueueGenericReceive+0xa8>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
     a94:	0f 90       	pop	r0
     a96:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
     a98:	80 e0       	ldi	r24, 0x00	; 0
     a9a:	47 c0       	rjmp	.+142    	; 0xb2a <xQueueGenericReceive+0x136>
				}
				else if( xEntryTimeSet == pdFALSE )
     a9c:	a1 10       	cpse	r10, r1
     a9e:	05 c0       	rjmp	.+10     	; 0xaaa <xQueueGenericReceive+0xb6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
     aa0:	ce 01       	movw	r24, r28
     aa2:	01 96       	adiw	r24, 0x01	; 1
     aa4:	0e 94 b2 09 	call	0x1364	; 0x1364 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
     aa8:	a9 2c       	mov	r10, r9
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
     aaa:	0f 90       	pop	r0
     aac:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
     aae:	0e 94 3c 07 	call	0xe78	; 0xe78 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
     ab2:	0f b6       	in	r0, 0x3f	; 63
     ab4:	f8 94       	cli
     ab6:	0f 92       	push	r0
     ab8:	f8 01       	movw	r30, r16
     aba:	85 8d       	ldd	r24, Z+29	; 0x1d
     abc:	8f 3f       	cpi	r24, 0xFF	; 255
     abe:	09 f4       	brne	.+2      	; 0xac2 <xQueueGenericReceive+0xce>
     ac0:	15 8e       	std	Z+29, r1	; 0x1d
     ac2:	f8 01       	movw	r30, r16
     ac4:	86 8d       	ldd	r24, Z+30	; 0x1e
     ac6:	8f 3f       	cpi	r24, 0xFF	; 255
     ac8:	09 f4       	brne	.+2      	; 0xacc <xQueueGenericReceive+0xd8>
     aca:	16 8e       	std	Z+30, r1	; 0x1e
     acc:	0f 90       	pop	r0
     ace:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
     ad0:	be 01       	movw	r22, r28
     ad2:	6c 5f       	subi	r22, 0xFC	; 252
     ad4:	7f 4f       	sbci	r23, 0xFF	; 255
     ad6:	ce 01       	movw	r24, r28
     ad8:	01 96       	adiw	r24, 0x01	; 1
     ada:	0e 94 bd 09 	call	0x137a	; 0x137a <xTaskCheckForTimeOut>
     ade:	81 11       	cpse	r24, r1
     ae0:	1e c0       	rjmp	.+60     	; 0xb1e <xQueueGenericReceive+0x12a>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
     ae2:	0f b6       	in	r0, 0x3f	; 63
     ae4:	f8 94       	cli
     ae6:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
     ae8:	f8 01       	movw	r30, r16
     aea:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
     aec:	0f 90       	pop	r0
     aee:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
     af0:	81 11       	cpse	r24, r1
     af2:	0f c0       	rjmp	.+30     	; 0xb12 <xQueueGenericReceive+0x11e>
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
     af4:	6c 81       	ldd	r22, Y+4	; 0x04
     af6:	7d 81       	ldd	r23, Y+5	; 0x05
     af8:	c7 01       	movw	r24, r14
     afa:	0e 94 3e 09 	call	0x127c	; 0x127c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
     afe:	c8 01       	movw	r24, r16
     b00:	0e 94 a3 03 	call	0x746	; 0x746 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
     b04:	0e 94 01 08 	call	0x1002	; 0x1002 <xTaskResumeAll>
     b08:	81 11       	cpse	r24, r1
     b0a:	90 cf       	rjmp	.-224    	; 0xa2c <xQueueGenericReceive+0x38>
				{
					portYIELD_WITHIN_API();
     b0c:	0e 94 4e 02 	call	0x49c	; 0x49c <vPortYield>
     b10:	8d cf       	rjmp	.-230    	; 0xa2c <xQueueGenericReceive+0x38>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
     b12:	c8 01       	movw	r24, r16
     b14:	0e 94 a3 03 	call	0x746	; 0x746 <prvUnlockQueue>
				( void ) xTaskResumeAll();
     b18:	0e 94 01 08 	call	0x1002	; 0x1002 <xTaskResumeAll>
     b1c:	87 cf       	rjmp	.-242    	; 0xa2c <xQueueGenericReceive+0x38>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
     b1e:	c8 01       	movw	r24, r16
     b20:	0e 94 a3 03 	call	0x746	; 0x746 <prvUnlockQueue>
			( void ) xTaskResumeAll();
     b24:	0e 94 01 08 	call	0x1002	; 0x1002 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
     b28:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
     b2a:	0f 90       	pop	r0
     b2c:	0f 90       	pop	r0
     b2e:	0f 90       	pop	r0
     b30:	0f 90       	pop	r0
     b32:	0f 90       	pop	r0
     b34:	df 91       	pop	r29
     b36:	cf 91       	pop	r28
     b38:	1f 91       	pop	r17
     b3a:	0f 91       	pop	r16
     b3c:	ff 90       	pop	r15
     b3e:	ef 90       	pop	r14
     b40:	df 90       	pop	r13
     b42:	cf 90       	pop	r12
     b44:	bf 90       	pop	r11
     b46:	af 90       	pop	r10
     b48:	9f 90       	pop	r9
     b4a:	08 95       	ret

00000b4c <prvResetNextTaskUnblockTime>:

static void prvResetNextTaskUnblockTime( void )
{
TCB_t *pxTCB;

	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     b4c:	e0 91 b6 05 	lds	r30, 0x05B6
     b50:	f0 91 b7 05 	lds	r31, 0x05B7
     b54:	80 81       	ld	r24, Z
     b56:	81 11       	cpse	r24, r1
     b58:	07 c0       	rjmp	.+14     	; 0xb68 <prvResetNextTaskUnblockTime+0x1c>
	{
		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
		the maximum possible value so it is	extremely unlikely that the
		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
		there is an item in the delayed list. */
		xNextTaskUnblockTime = portMAX_DELAY;
     b5a:	8f ef       	ldi	r24, 0xFF	; 255
     b5c:	9f ef       	ldi	r25, 0xFF	; 255
     b5e:	90 93 8e 05 	sts	0x058E, r25
     b62:	80 93 8d 05 	sts	0x058D, r24
     b66:	08 95       	ret
	{
		/* The new current delayed list is not empty, get the value of
		the item at the head of the delayed list.  This is the time at
		which the task at the head of the delayed list should be removed
		from the Blocked state. */
		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     b68:	e0 91 b6 05 	lds	r30, 0x05B6
     b6c:	f0 91 b7 05 	lds	r31, 0x05B7
     b70:	05 80       	ldd	r0, Z+5	; 0x05
     b72:	f6 81       	ldd	r31, Z+6	; 0x06
     b74:	e0 2d       	mov	r30, r0
		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xGenericListItem ) );
     b76:	06 80       	ldd	r0, Z+6	; 0x06
     b78:	f7 81       	ldd	r31, Z+7	; 0x07
     b7a:	e0 2d       	mov	r30, r0
     b7c:	82 81       	ldd	r24, Z+2	; 0x02
     b7e:	93 81       	ldd	r25, Z+3	; 0x03
     b80:	90 93 8e 05 	sts	0x058E, r25
     b84:	80 93 8d 05 	sts	0x058D, r24
     b88:	08 95       	ret

00000b8a <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
     b8a:	cf 93       	push	r28
     b8c:	df 93       	push	r29
     b8e:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
     b90:	e0 91 ee 05 	lds	r30, 0x05EE
     b94:	f0 91 ef 05 	lds	r31, 0x05EF
     b98:	93 83       	std	Z+3, r25	; 0x03
     b9a:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
     b9c:	80 91 95 05 	lds	r24, 0x0595
     ba0:	90 91 96 05 	lds	r25, 0x0596
     ba4:	c8 17       	cp	r28, r24
     ba6:	d9 07       	cpc	r29, r25
     ba8:	68 f4       	brcc	.+26     	; 0xbc4 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     baa:	60 91 ee 05 	lds	r22, 0x05EE
     bae:	70 91 ef 05 	lds	r23, 0x05EF
     bb2:	80 91 b4 05 	lds	r24, 0x05B4
     bb6:	90 91 b5 05 	lds	r25, 0x05B5
     bba:	6e 5f       	subi	r22, 0xFE	; 254
     bbc:	7f 4f       	sbci	r23, 0xFF	; 255
     bbe:	0e 94 51 01 	call	0x2a2	; 0x2a2 <vListInsert>
     bc2:	17 c0       	rjmp	.+46     	; 0xbf2 <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
     bc4:	60 91 ee 05 	lds	r22, 0x05EE
     bc8:	70 91 ef 05 	lds	r23, 0x05EF
     bcc:	80 91 b6 05 	lds	r24, 0x05B6
     bd0:	90 91 b7 05 	lds	r25, 0x05B7
     bd4:	6e 5f       	subi	r22, 0xFE	; 254
     bd6:	7f 4f       	sbci	r23, 0xFF	; 255
     bd8:	0e 94 51 01 	call	0x2a2	; 0x2a2 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
     bdc:	80 91 8d 05 	lds	r24, 0x058D
     be0:	90 91 8e 05 	lds	r25, 0x058E
     be4:	c8 17       	cp	r28, r24
     be6:	d9 07       	cpc	r29, r25
     be8:	20 f4       	brcc	.+8      	; 0xbf2 <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
     bea:	d0 93 8e 05 	sts	0x058E, r29
     bee:	c0 93 8d 05 	sts	0x058D, r28
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     bf2:	df 91       	pop	r29
     bf4:	cf 91       	pop	r28
     bf6:	08 95       	ret

00000bf8 <xTaskGenericCreate>:

#endif
/*-----------------------------------------------------------*/

BaseType_t xTaskGenericCreate( TaskFunction_t pxTaskCode, const char * const pcName, const uint16_t usStackDepth, void * const pvParameters, UBaseType_t uxPriority, TaskHandle_t * const pxCreatedTask, StackType_t * const puxStackBuffer, const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
     bf8:	4f 92       	push	r4
     bfa:	5f 92       	push	r5
     bfc:	6f 92       	push	r6
     bfe:	7f 92       	push	r7
     c00:	8f 92       	push	r8
     c02:	9f 92       	push	r9
     c04:	af 92       	push	r10
     c06:	bf 92       	push	r11
     c08:	cf 92       	push	r12
     c0a:	df 92       	push	r13
     c0c:	ef 92       	push	r14
     c0e:	ff 92       	push	r15
     c10:	0f 93       	push	r16
     c12:	1f 93       	push	r17
     c14:	cf 93       	push	r28
     c16:	df 93       	push	r29
     c18:	4c 01       	movw	r8, r24
     c1a:	5b 01       	movw	r10, r22
     c1c:	2a 01       	movw	r4, r20
     c1e:	39 01       	movw	r6, r18
	#else /* portSTACK_GROWTH */
	{
	StackType_t *pxStack;

		/* Allocate space for the stack used by the task being created. */
		pxStack = ( StackType_t * ) pvPortMallocAligned( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ), puxStackBuffer ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     c20:	c1 14       	cp	r12, r1
     c22:	d1 04       	cpc	r13, r1
     c24:	39 f4       	brne	.+14     	; 0xc34 <xTaskGenericCreate+0x3c>
     c26:	ca 01       	movw	r24, r20
     c28:	0e 94 06 03 	call	0x60c	; 0x60c <pvPortMalloc>
     c2c:	6c 01       	movw	r12, r24

		if( pxStack != NULL )
     c2e:	00 97       	sbiw	r24, 0x00	; 0
     c30:	09 f4       	brne	.+2      	; 0xc34 <xTaskGenericCreate+0x3c>
     c32:	de c0       	rjmp	.+444    	; 0xdf0 <xTaskGenericCreate+0x1f8>
		{
			/* Allocate space for the TCB.  Where the memory comes from depends
			on the implementation of the port malloc function. */
			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
     c34:	86 e2       	ldi	r24, 0x26	; 38
     c36:	90 e0       	ldi	r25, 0x00	; 0
     c38:	0e 94 06 03 	call	0x60c	; 0x60c <pvPortMalloc>
     c3c:	ec 01       	movw	r28, r24

			if( pxNewTCB != NULL )
     c3e:	00 97       	sbiw	r24, 0x00	; 0
     c40:	71 f0       	breq	.+28     	; 0xc5e <xTaskGenericCreate+0x66>
			{
				/* Store the stack location in the TCB. */
				pxNewTCB->pxStack = pxStack;
     c42:	d8 8e       	std	Y+24, r13	; 0x18
     c44:	cf 8a       	std	Y+23, r12	; 0x17
		stack grows from high memory to low (as per the 80x86) or vice versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( uint16_t ) 1 );
     c46:	81 e0       	ldi	r24, 0x01	; 1
     c48:	48 1a       	sub	r4, r24
     c4a:	51 08       	sbc	r5, r1
     c4c:	c4 0c       	add	r12, r4
     c4e:	d5 1c       	adc	r13, r5
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
     c50:	d5 01       	movw	r26, r10
     c52:	8c 91       	ld	r24, X
     c54:	89 8f       	std	Y+25, r24	; 0x19

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     c56:	8c 91       	ld	r24, X
     c58:	81 11       	cpse	r24, r1
     c5a:	05 c0       	rjmp	.+10     	; 0xc66 <xTaskGenericCreate+0x6e>
     c5c:	15 c0       	rjmp	.+42     	; 0xc88 <xTaskGenericCreate+0x90>
			}
			else
			{
				/* The stack cannot be used as the TCB was not created.  Free it
				again. */
				vPortFree( pxStack );
     c5e:	c6 01       	movw	r24, r12
     c60:	0e 94 3b 03 	call	0x676	; 0x676 <vPortFree>
     c64:	c5 c0       	rjmp	.+394    	; 0xdf0 <xTaskGenericCreate+0x1f8>
     c66:	ae 01       	movw	r20, r28
     c68:	46 5e       	subi	r20, 0xE6	; 230
     c6a:	5f 4f       	sbci	r21, 0xFF	; 255
     c6c:	f5 01       	movw	r30, r10
     c6e:	31 96       	adiw	r30, 0x01	; 1
		pxTCB->pcTaskName[ x ] = pcName[ x ];

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     c70:	27 e0       	ldi	r18, 0x07	; 7
     c72:	cf 01       	movw	r24, r30
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
	{
		pxTCB->pcTaskName[ x ] = pcName[ x ];
     c74:	31 91       	ld	r19, Z+
     c76:	da 01       	movw	r26, r20
     c78:	3d 93       	st	X+, r19
     c7a:	ad 01       	movw	r20, r26

		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
		configMAX_TASK_NAME_LEN characters just in case the memory after the
		string is not accessible (extremely unlikely). */
		if( pcName[ x ] == 0x00 )
     c7c:	dc 01       	movw	r26, r24
     c7e:	8c 91       	ld	r24, X
     c80:	88 23       	and	r24, r24
     c82:	11 f0       	breq	.+4      	; 0xc88 <xTaskGenericCreate+0x90>
     c84:	21 50       	subi	r18, 0x01	; 1
static void prvInitialiseTCBVariables( TCB_t * const pxTCB, const char * const pcName, UBaseType_t uxPriority, const MemoryRegion_t * const xRegions, const uint16_t usStackDepth ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
{
UBaseType_t x;

	/* Store the task name in the TCB. */
	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
     c86:	a9 f7       	brne	.-22     	; 0xc72 <xTaskGenericCreate+0x7a>
		}
	}

	/* Ensure the name string is terminated in the case that the string length
	was greater or equal to configMAX_TASK_NAME_LEN. */
	pxTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
     c88:	18 a2       	std	Y+32, r1	; 0x20
     c8a:	10 2f       	mov	r17, r16
     c8c:	04 30       	cpi	r16, 0x04	; 4
     c8e:	08 f0       	brcs	.+2      	; 0xc92 <xTaskGenericCreate+0x9a>
     c90:	13 e0       	ldi	r17, 0x03	; 3
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxTCB->uxPriority = uxPriority;
     c92:	1e 8b       	std	Y+22, r17	; 0x16
		pxTCB->uxBasePriority = uxPriority;
		pxTCB->uxMutexesHeld = 0;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
     c94:	5e 01       	movw	r10, r28
     c96:	b2 e0       	ldi	r27, 0x02	; 2
     c98:	ab 0e       	add	r10, r27
     c9a:	b1 1c       	adc	r11, r1
     c9c:	c5 01       	movw	r24, r10
     c9e:	0e 94 2c 01 	call	0x258	; 0x258 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
     ca2:	ce 01       	movw	r24, r28
     ca4:	0c 96       	adiw	r24, 0x0c	; 12
     ca6:	0e 94 2c 01 	call	0x258	; 0x258 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the ListItem_t.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
     caa:	d9 87       	std	Y+9, r29	; 0x09
     cac:	c8 87       	std	Y+8, r28	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
     cae:	84 e0       	ldi	r24, 0x04	; 4
     cb0:	90 e0       	ldi	r25, 0x00	; 0
     cb2:	81 1b       	sub	r24, r17
     cb4:	91 09       	sbc	r25, r1
     cb6:	9d 87       	std	Y+13, r25	; 0x0d
     cb8:	8c 87       	std	Y+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
     cba:	db 8b       	std	Y+19, r29	; 0x13
     cbc:	ca 8b       	std	Y+18, r28	; 0x12
	}
	#endif

	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
	{
		pxTCB->ulNotifiedValue = 0;
     cbe:	19 a2       	std	Y+33, r1	; 0x21
     cc0:	1a a2       	std	Y+34, r1	; 0x22
     cc2:	1b a2       	std	Y+35, r1	; 0x23
     cc4:	1c a2       	std	Y+36, r1	; 0x24
		pxTCB->eNotifyState = eNotWaitingNotification;
     cc6:	1d a2       	std	Y+37, r1	; 0x25
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     cc8:	a3 01       	movw	r20, r6
     cca:	b4 01       	movw	r22, r8
     ccc:	c6 01       	movw	r24, r12
     cce:	0e 94 a8 01 	call	0x350	; 0x350 <pxPortInitialiseStack>
     cd2:	99 83       	std	Y+1, r25	; 0x01
     cd4:	88 83       	st	Y, r24
		}
		#endif /* portUSING_MPU_WRAPPERS */

		if( ( void * ) pxCreatedTask != NULL )
     cd6:	e1 14       	cp	r14, r1
     cd8:	f1 04       	cpc	r15, r1
     cda:	19 f0       	breq	.+6      	; 0xce2 <xTaskGenericCreate+0xea>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
     cdc:	f7 01       	movw	r30, r14
     cde:	d1 83       	std	Z+1, r29	; 0x01
     ce0:	c0 83       	st	Z, r28
			mtCOVERAGE_TEST_MARKER();
		}

		/* Ensure interrupts don't access the task lists while they are being
		updated. */
		taskENTER_CRITICAL();
     ce2:	0f b6       	in	r0, 0x3f	; 63
     ce4:	f8 94       	cli
     ce6:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
     ce8:	80 91 97 05 	lds	r24, 0x0597
     cec:	8f 5f       	subi	r24, 0xFF	; 255
     cee:	80 93 97 05 	sts	0x0597, r24
			if( pxCurrentTCB == NULL )
     cf2:	80 91 ee 05 	lds	r24, 0x05EE
     cf6:	90 91 ef 05 	lds	r25, 0x05EF
     cfa:	89 2b       	or	r24, r25
     cfc:	d1 f5       	brne	.+116    	; 0xd72 <xTaskGenericCreate+0x17a>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
     cfe:	d0 93 ef 05 	sts	0x05EF, r29
     d02:	c0 93 ee 05 	sts	0x05EE, r28

				if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
     d06:	80 91 97 05 	lds	r24, 0x0597
     d0a:	81 30       	cpi	r24, 0x01	; 1
     d0c:	09 f0       	breq	.+2      	; 0xd10 <xTaskGenericCreate+0x118>
     d0e:	40 c0       	rjmp	.+128    	; 0xd90 <xTaskGenericCreate+0x198>
{
UBaseType_t uxPriority;

	for( uxPriority = ( UBaseType_t ) 0U; uxPriority < ( UBaseType_t ) configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( &( pxReadyTasksLists[ uxPriority ] ) );
     d10:	8a ec       	ldi	r24, 0xCA	; 202
     d12:	95 e0       	ldi	r25, 0x05	; 5
     d14:	0e 94 1e 01 	call	0x23c	; 0x23c <vListInitialise>
     d18:	83 ed       	ldi	r24, 0xD3	; 211
     d1a:	95 e0       	ldi	r25, 0x05	; 5
     d1c:	0e 94 1e 01 	call	0x23c	; 0x23c <vListInitialise>
     d20:	8c ed       	ldi	r24, 0xDC	; 220
     d22:	95 e0       	ldi	r25, 0x05	; 5
     d24:	0e 94 1e 01 	call	0x23c	; 0x23c <vListInitialise>
     d28:	85 ee       	ldi	r24, 0xE5	; 229
     d2a:	95 e0       	ldi	r25, 0x05	; 5
     d2c:	0e 94 1e 01 	call	0x23c	; 0x23c <vListInitialise>
	}

	vListInitialise( &xDelayedTaskList1 );
     d30:	81 ec       	ldi	r24, 0xC1	; 193
     d32:	95 e0       	ldi	r25, 0x05	; 5
     d34:	0e 94 1e 01 	call	0x23c	; 0x23c <vListInitialise>
	vListInitialise( &xDelayedTaskList2 );
     d38:	88 eb       	ldi	r24, 0xB8	; 184
     d3a:	95 e0       	ldi	r25, 0x05	; 5
     d3c:	0e 94 1e 01 	call	0x23c	; 0x23c <vListInitialise>
	vListInitialise( &xPendingReadyList );
     d40:	8b ea       	ldi	r24, 0xAB	; 171
     d42:	95 e0       	ldi	r25, 0x05	; 5
     d44:	0e 94 1e 01 	call	0x23c	; 0x23c <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( &xTasksWaitingTermination );
     d48:	82 ea       	ldi	r24, 0xA2	; 162
     d4a:	95 e0       	ldi	r25, 0x05	; 5
     d4c:	0e 94 1e 01 	call	0x23c	; 0x23c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskDelete */

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( &xSuspendedTaskList );
     d50:	88 e9       	ldi	r24, 0x98	; 152
     d52:	95 e0       	ldi	r25, 0x05	; 5
     d54:	0e 94 1e 01 	call	0x23c	; 0x23c <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     d58:	81 ec       	ldi	r24, 0xC1	; 193
     d5a:	95 e0       	ldi	r25, 0x05	; 5
     d5c:	90 93 b7 05 	sts	0x05B7, r25
     d60:	80 93 b6 05 	sts	0x05B6, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     d64:	88 eb       	ldi	r24, 0xB8	; 184
     d66:	95 e0       	ldi	r25, 0x05	; 5
     d68:	90 93 b5 05 	sts	0x05B5, r25
     d6c:	80 93 b4 05 	sts	0x05B4, r24
     d70:	0f c0       	rjmp	.+30     	; 0xd90 <xTaskGenericCreate+0x198>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
     d72:	80 91 93 05 	lds	r24, 0x0593
     d76:	81 11       	cpse	r24, r1
     d78:	0b c0       	rjmp	.+22     	; 0xd90 <xTaskGenericCreate+0x198>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
     d7a:	e0 91 ee 05 	lds	r30, 0x05EE
     d7e:	f0 91 ef 05 	lds	r31, 0x05EF
     d82:	86 89       	ldd	r24, Z+22	; 0x16
     d84:	08 17       	cp	r16, r24
     d86:	20 f0       	brcs	.+8      	; 0xd90 <xTaskGenericCreate+0x198>
					{
						pxCurrentTCB = pxNewTCB;
     d88:	d0 93 ef 05 	sts	0x05EF, r29
     d8c:	c0 93 ee 05 	sts	0x05EE, r28
				{
					mtCOVERAGE_TEST_MARKER();
				}
			}

			uxTaskNumber++;
     d90:	80 91 8f 05 	lds	r24, 0x058F
     d94:	8f 5f       	subi	r24, 0xFF	; 255
     d96:	80 93 8f 05 	sts	0x058F, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );
     d9a:	8e 89       	ldd	r24, Y+22	; 0x16
     d9c:	90 91 94 05 	lds	r25, 0x0594
     da0:	98 17       	cp	r25, r24
     da2:	10 f4       	brcc	.+4      	; 0xda8 <xTaskGenericCreate+0x1b0>
     da4:	80 93 94 05 	sts	0x0594, r24
     da8:	90 e0       	ldi	r25, 0x00	; 0
     daa:	9c 01       	movw	r18, r24
     dac:	22 0f       	add	r18, r18
     dae:	33 1f       	adc	r19, r19
     db0:	22 0f       	add	r18, r18
     db2:	33 1f       	adc	r19, r19
     db4:	22 0f       	add	r18, r18
     db6:	33 1f       	adc	r19, r19
     db8:	82 0f       	add	r24, r18
     dba:	93 1f       	adc	r25, r19
     dbc:	b5 01       	movw	r22, r10
     dbe:	86 53       	subi	r24, 0x36	; 54
     dc0:	9a 4f       	sbci	r25, 0xFA	; 250
     dc2:	0e 94 30 01 	call	0x260	; 0x260 <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
     dc6:	0f 90       	pop	r0
     dc8:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
     dca:	80 91 93 05 	lds	r24, 0x0593
     dce:	88 23       	and	r24, r24
     dd0:	59 f0       	breq	.+22     	; 0xde8 <xTaskGenericCreate+0x1f0>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
     dd2:	e0 91 ee 05 	lds	r30, 0x05EE
     dd6:	f0 91 ef 05 	lds	r31, 0x05EF
     dda:	86 89       	ldd	r24, Z+22	; 0x16
     ddc:	80 17       	cp	r24, r16
     dde:	30 f4       	brcc	.+12     	; 0xdec <xTaskGenericCreate+0x1f4>
			{
				taskYIELD_IF_USING_PREEMPTION();
     de0:	0e 94 4e 02 	call	0x49c	; 0x49c <vPortYield>
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyList( pxNewTCB );

			xReturn = pdPASS;
     de4:	81 e0       	ldi	r24, 0x01	; 1
     de6:	05 c0       	rjmp	.+10     	; 0xdf2 <xTaskGenericCreate+0x1fa>
     de8:	81 e0       	ldi	r24, 0x01	; 1
     dea:	03 c0       	rjmp	.+6      	; 0xdf2 <xTaskGenericCreate+0x1fa>
     dec:	81 e0       	ldi	r24, 0x01	; 1
     dee:	01 c0       	rjmp	.+2      	; 0xdf2 <xTaskGenericCreate+0x1fa>
		}
		taskEXIT_CRITICAL();
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     df0:	8f ef       	ldi	r24, 0xFF	; 255
			mtCOVERAGE_TEST_MARKER();
		}
	}

	return xReturn;
}
     df2:	df 91       	pop	r29
     df4:	cf 91       	pop	r28
     df6:	1f 91       	pop	r17
     df8:	0f 91       	pop	r16
     dfa:	ff 90       	pop	r15
     dfc:	ef 90       	pop	r14
     dfe:	df 90       	pop	r13
     e00:	cf 90       	pop	r12
     e02:	bf 90       	pop	r11
     e04:	af 90       	pop	r10
     e06:	9f 90       	pop	r9
     e08:	8f 90       	pop	r8
     e0a:	7f 90       	pop	r7
     e0c:	6f 90       	pop	r6
     e0e:	5f 90       	pop	r5
     e10:	4f 90       	pop	r4
     e12:	08 95       	ret

00000e14 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     e14:	af 92       	push	r10
     e16:	bf 92       	push	r11
     e18:	cf 92       	push	r12
     e1a:	df 92       	push	r13
     e1c:	ef 92       	push	r14
     e1e:	ff 92       	push	r15
     e20:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );  /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
     e22:	a1 2c       	mov	r10, r1
     e24:	b1 2c       	mov	r11, r1
     e26:	c1 2c       	mov	r12, r1
     e28:	d1 2c       	mov	r13, r1
     e2a:	e1 2c       	mov	r14, r1
     e2c:	f1 2c       	mov	r15, r1
     e2e:	00 e0       	ldi	r16, 0x00	; 0
     e30:	20 e0       	ldi	r18, 0x00	; 0
     e32:	30 e0       	ldi	r19, 0x00	; 0
     e34:	45 e5       	ldi	r20, 0x55	; 85
     e36:	50 e0       	ldi	r21, 0x00	; 0
     e38:	63 e8       	ldi	r22, 0x83	; 131
     e3a:	71 e0       	ldi	r23, 0x01	; 1
     e3c:	84 ea       	ldi	r24, 0xA4	; 164
     e3e:	98 e0       	ldi	r25, 0x08	; 8
     e40:	0e 94 fc 05 	call	0xbf8	; 0xbf8 <xTaskGenericCreate>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
     e44:	81 30       	cpi	r24, 0x01	; 1
     e46:	81 f4       	brne	.+32     	; 0xe68 <vTaskStartScheduler+0x54>
		/* Interrupts are turned off here, to ensure a tick does not occur
		before or during the call to xPortStartScheduler().  The stacks of
		the created tasks contain a status word with interrupts switched on
		so interrupts will automatically get re-enabled when the first task
		starts to run. */
		portDISABLE_INTERRUPTS();
     e48:	f8 94       	cli
			structure specific to the task that will run first. */
			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
		}
		#endif /* configUSE_NEWLIB_REENTRANT */

		xNextTaskUnblockTime = portMAX_DELAY;
     e4a:	8f ef       	ldi	r24, 0xFF	; 255
     e4c:	9f ef       	ldi	r25, 0xFF	; 255
     e4e:	90 93 8e 05 	sts	0x058E, r25
     e52:	80 93 8d 05 	sts	0x058D, r24
		xSchedulerRunning = pdTRUE;
     e56:	81 e0       	ldi	r24, 0x01	; 1
     e58:	80 93 93 05 	sts	0x0593, r24
		xTickCount = ( TickType_t ) 0U;
     e5c:	10 92 96 05 	sts	0x0596, r1
     e60:	10 92 95 05 	sts	0x0595, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
     e64:	0e 94 14 02 	call	0x428	; 0x428 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
     e68:	0f 91       	pop	r16
     e6a:	ff 90       	pop	r15
     e6c:	ef 90       	pop	r14
     e6e:	df 90       	pop	r13
     e70:	cf 90       	pop	r12
     e72:	bf 90       	pop	r11
     e74:	af 90       	pop	r10
     e76:	08 95       	ret

00000e78 <vTaskSuspendAll>:
{
	/* A critical section is not required as the variable is of type
	BaseType_t.  Please read Richard Barry's reply in the following link to a
	post in the FreeRTOS support forum before reporting this as a bug! -
	http://goo.gl/wu4acr */
	++uxSchedulerSuspended;
     e78:	80 91 8c 05 	lds	r24, 0x058C
     e7c:	8f 5f       	subi	r24, 0xFF	; 255
     e7e:	80 93 8c 05 	sts	0x058C, r24
     e82:	08 95       	ret

00000e84 <xTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskIncrementTick( void )
{
     e84:	cf 92       	push	r12
     e86:	df 92       	push	r13
     e88:	ef 92       	push	r14
     e8a:	ff 92       	push	r15
     e8c:	0f 93       	push	r16
     e8e:	1f 93       	push	r17
     e90:	cf 93       	push	r28
     e92:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
     e94:	80 91 8c 05 	lds	r24, 0x058C
     e98:	81 11       	cpse	r24, r1
     e9a:	9a c0       	rjmp	.+308    	; 0xfd0 <xTaskIncrementTick+0x14c>
	{
		/* Increment the RTOS tick, switching the delayed and overflowed
		delayed lists if it wraps to 0. */
		++xTickCount;
     e9c:	80 91 95 05 	lds	r24, 0x0595
     ea0:	90 91 96 05 	lds	r25, 0x0596
     ea4:	01 96       	adiw	r24, 0x01	; 1
     ea6:	90 93 96 05 	sts	0x0596, r25
     eaa:	80 93 95 05 	sts	0x0595, r24

		{
			/* Minor optimisation.  The tick count cannot change in this
			block. */
			const TickType_t xConstTickCount = xTickCount;
     eae:	e0 90 95 05 	lds	r14, 0x0595
     eb2:	f0 90 96 05 	lds	r15, 0x0596

			if( xConstTickCount == ( TickType_t ) 0U )
     eb6:	e1 14       	cp	r14, r1
     eb8:	f1 04       	cpc	r15, r1
     eba:	b9 f4       	brne	.+46     	; 0xeea <xTaskIncrementTick+0x66>
			{
				taskSWITCH_DELAYED_LISTS();
     ebc:	80 91 b6 05 	lds	r24, 0x05B6
     ec0:	90 91 b7 05 	lds	r25, 0x05B7
     ec4:	20 91 b4 05 	lds	r18, 0x05B4
     ec8:	30 91 b5 05 	lds	r19, 0x05B5
     ecc:	30 93 b7 05 	sts	0x05B7, r19
     ed0:	20 93 b6 05 	sts	0x05B6, r18
     ed4:	90 93 b5 05 	sts	0x05B5, r25
     ed8:	80 93 b4 05 	sts	0x05B4, r24
     edc:	80 91 90 05 	lds	r24, 0x0590
     ee0:	8f 5f       	subi	r24, 0xFF	; 255
     ee2:	80 93 90 05 	sts	0x0590, r24
     ee6:	0e 94 a6 05 	call	0xb4c	; 0xb4c <prvResetNextTaskUnblockTime>

			/* See if this tick has made a timeout expire.  Tasks are stored in
			the	queue in the order of their wake time - meaning once one task
			has been found whose block time has not expired there is no need to
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
     eea:	80 91 8d 05 	lds	r24, 0x058D
     eee:	90 91 8e 05 	lds	r25, 0x058E
     ef2:	e8 16       	cp	r14, r24
     ef4:	f9 06       	cpc	r15, r25
     ef6:	08 f4       	brcc	.+2      	; 0xefa <xTaskIncrementTick+0x76>
     ef8:	54 c0       	rjmp	.+168    	; 0xfa2 <xTaskIncrementTick+0x11e>
     efa:	d1 2c       	mov	r13, r1
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
							{
								xSwitchRequired = pdTRUE;
     efc:	cc 24       	eor	r12, r12
     efe:	c3 94       	inc	r12
     f00:	01 c0       	rjmp	.+2      	; 0xf04 <xTaskIncrementTick+0x80>
     f02:	dc 2c       	mov	r13, r12
			look any further down the list. */
			if( xConstTickCount >= xNextTaskUnblockTime )
			{
				for( ;; )
				{
					if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     f04:	e0 91 b6 05 	lds	r30, 0x05B6
     f08:	f0 91 b7 05 	lds	r31, 0x05B7
     f0c:	80 81       	ld	r24, Z
     f0e:	81 11       	cpse	r24, r1
     f10:	07 c0       	rjmp	.+14     	; 0xf20 <xTaskIncrementTick+0x9c>
						/* The delayed list is empty.  Set xNextTaskUnblockTime
						to the maximum possible value so it is extremely
						unlikely that the
						if( xTickCount >= xNextTaskUnblockTime ) test will pass
						next time through. */
						xNextTaskUnblockTime = portMAX_DELAY;
     f12:	8f ef       	ldi	r24, 0xFF	; 255
     f14:	9f ef       	ldi	r25, 0xFF	; 255
     f16:	90 93 8e 05 	sts	0x058E, r25
     f1a:	80 93 8d 05 	sts	0x058D, r24
						break;
     f1e:	42 c0       	rjmp	.+132    	; 0xfa4 <xTaskIncrementTick+0x120>
					{
						/* The delayed list is not empty, get the value of the
						item at the head of the delayed list.  This is the time
						at which the task at the head of the delayed list must
						be removed from the Blocked state. */
						pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     f20:	e0 91 b6 05 	lds	r30, 0x05B6
     f24:	f0 91 b7 05 	lds	r31, 0x05B7
     f28:	05 80       	ldd	r0, Z+5	; 0x05
     f2a:	f6 81       	ldd	r31, Z+6	; 0x06
     f2c:	e0 2d       	mov	r30, r0
     f2e:	c6 81       	ldd	r28, Z+6	; 0x06
     f30:	d7 81       	ldd	r29, Z+7	; 0x07
						xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
     f32:	2a 81       	ldd	r18, Y+2	; 0x02
     f34:	3b 81       	ldd	r19, Y+3	; 0x03

						if( xConstTickCount < xItemValue )
     f36:	e2 16       	cp	r14, r18
     f38:	f3 06       	cpc	r15, r19
     f3a:	28 f4       	brcc	.+10     	; 0xf46 <xTaskIncrementTick+0xc2>
							/* It is not time to unblock this item yet, but the
							item value is the time at which the task at the head
							of the blocked list must be removed from the Blocked
							state -	so record the item value in
							xNextTaskUnblockTime. */
							xNextTaskUnblockTime = xItemValue;
     f3c:	30 93 8e 05 	sts	0x058E, r19
     f40:	20 93 8d 05 	sts	0x058D, r18
							break;
     f44:	2f c0       	rjmp	.+94     	; 0xfa4 <xTaskIncrementTick+0x120>
						{
							mtCOVERAGE_TEST_MARKER();
						}

						/* It is time to remove the item from the Blocked state. */
						( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
     f46:	8e 01       	movw	r16, r28
     f48:	0e 5f       	subi	r16, 0xFE	; 254
     f4a:	1f 4f       	sbci	r17, 0xFF	; 255
     f4c:	c8 01       	movw	r24, r16
     f4e:	0e 94 82 01 	call	0x304	; 0x304 <uxListRemove>

						/* Is the task waiting on an event also?  If so remove
						it from the event list. */
						if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
     f52:	8c 89       	ldd	r24, Y+20	; 0x14
     f54:	9d 89       	ldd	r25, Y+21	; 0x15
     f56:	89 2b       	or	r24, r25
     f58:	21 f0       	breq	.+8      	; 0xf62 <xTaskIncrementTick+0xde>
						{
							( void ) uxListRemove( &( pxTCB->xEventListItem ) );
     f5a:	ce 01       	movw	r24, r28
     f5c:	0c 96       	adiw	r24, 0x0c	; 12
     f5e:	0e 94 82 01 	call	0x304	; 0x304 <uxListRemove>
							mtCOVERAGE_TEST_MARKER();
						}

						/* Place the unblocked task into the appropriate ready
						list. */
						prvAddTaskToReadyList( pxTCB );
     f62:	2e 89       	ldd	r18, Y+22	; 0x16
     f64:	80 91 94 05 	lds	r24, 0x0594
     f68:	82 17       	cp	r24, r18
     f6a:	10 f4       	brcc	.+4      	; 0xf70 <xTaskIncrementTick+0xec>
     f6c:	20 93 94 05 	sts	0x0594, r18
     f70:	30 e0       	ldi	r19, 0x00	; 0
     f72:	c9 01       	movw	r24, r18
     f74:	88 0f       	add	r24, r24
     f76:	99 1f       	adc	r25, r25
     f78:	88 0f       	add	r24, r24
     f7a:	99 1f       	adc	r25, r25
     f7c:	88 0f       	add	r24, r24
     f7e:	99 1f       	adc	r25, r25
     f80:	82 0f       	add	r24, r18
     f82:	93 1f       	adc	r25, r19
     f84:	b8 01       	movw	r22, r16
     f86:	86 53       	subi	r24, 0x36	; 54
     f88:	9a 4f       	sbci	r25, 0xFA	; 250
     f8a:	0e 94 30 01 	call	0x260	; 0x260 <vListInsertEnd>
						{
							/* Preemption is on, but a context switch should
							only be performed if the unblocked task has a
							priority that is equal to or higher than the
							currently executing task. */
							if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     f8e:	e0 91 ee 05 	lds	r30, 0x05EE
     f92:	f0 91 ef 05 	lds	r31, 0x05EF
     f96:	9e 89       	ldd	r25, Y+22	; 0x16
     f98:	86 89       	ldd	r24, Z+22	; 0x16
     f9a:	98 17       	cp	r25, r24
     f9c:	08 f0       	brcs	.+2      	; 0xfa0 <xTaskIncrementTick+0x11c>
     f9e:	b1 cf       	rjmp	.-158    	; 0xf02 <xTaskIncrementTick+0x7e>
     fa0:	b1 cf       	rjmp	.-158    	; 0xf04 <xTaskIncrementTick+0x80>

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     fa2:	d1 2c       	mov	r13, r1
		/* Tasks of equal priority to the currently running task will share
		processing time (time slice) if preemption is on, and the application
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
     fa4:	e0 91 ee 05 	lds	r30, 0x05EE
     fa8:	f0 91 ef 05 	lds	r31, 0x05EF
     fac:	86 89       	ldd	r24, Z+22	; 0x16
     fae:	90 e0       	ldi	r25, 0x00	; 0
     fb0:	fc 01       	movw	r30, r24
     fb2:	ee 0f       	add	r30, r30
     fb4:	ff 1f       	adc	r31, r31
     fb6:	ee 0f       	add	r30, r30
     fb8:	ff 1f       	adc	r31, r31
     fba:	ee 0f       	add	r30, r30
     fbc:	ff 1f       	adc	r31, r31
     fbe:	8e 0f       	add	r24, r30
     fc0:	9f 1f       	adc	r25, r31
     fc2:	fc 01       	movw	r30, r24
     fc4:	e6 53       	subi	r30, 0x36	; 54
     fc6:	fa 4f       	sbci	r31, 0xFA	; 250
     fc8:	80 81       	ld	r24, Z
     fca:	82 30       	cpi	r24, 0x02	; 2
     fcc:	40 f4       	brcc	.+16     	; 0xfde <xTaskIncrementTick+0x15a>
     fce:	09 c0       	rjmp	.+18     	; 0xfe2 <xTaskIncrementTick+0x15e>
		}
		#endif /* configUSE_TICK_HOOK */
	}
	else
	{
		++uxPendedTicks;
     fd0:	80 91 92 05 	lds	r24, 0x0592
     fd4:	8f 5f       	subi	r24, 0xFF	; 255
     fd6:	80 93 92 05 	sts	0x0592, r24

BaseType_t xTaskIncrementTick( void )
{
TCB_t * pxTCB;
TickType_t xItemValue;
BaseType_t xSwitchRequired = pdFALSE;
     fda:	d1 2c       	mov	r13, r1
     fdc:	02 c0       	rjmp	.+4      	; 0xfe2 <xTaskIncrementTick+0x15e>
		writer has not explicitly turned time slicing off. */
		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
		{
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
			{
				xSwitchRequired = pdTRUE;
     fde:	dd 24       	eor	r13, r13
     fe0:	d3 94       	inc	r13
		#endif
	}

	#if ( configUSE_PREEMPTION == 1 )
	{
		if( xYieldPending != pdFALSE )
     fe2:	80 91 91 05 	lds	r24, 0x0591
     fe6:	88 23       	and	r24, r24
     fe8:	11 f0       	breq	.+4      	; 0xfee <xTaskIncrementTick+0x16a>
		{
			xSwitchRequired = pdTRUE;
     fea:	dd 24       	eor	r13, r13
     fec:	d3 94       	inc	r13
		}
	}
	#endif /* configUSE_PREEMPTION */

	return xSwitchRequired;
}
     fee:	8d 2d       	mov	r24, r13
     ff0:	df 91       	pop	r29
     ff2:	cf 91       	pop	r28
     ff4:	1f 91       	pop	r17
     ff6:	0f 91       	pop	r16
     ff8:	ff 90       	pop	r15
     ffa:	ef 90       	pop	r14
     ffc:	df 90       	pop	r13
     ffe:	cf 90       	pop	r12
    1000:	08 95       	ret

00001002 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
    1002:	df 92       	push	r13
    1004:	ef 92       	push	r14
    1006:	ff 92       	push	r15
    1008:	0f 93       	push	r16
    100a:	1f 93       	push	r17
    100c:	cf 93       	push	r28
    100e:	df 93       	push	r29
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    1010:	0f b6       	in	r0, 0x3f	; 63
    1012:	f8 94       	cli
    1014:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    1016:	80 91 8c 05 	lds	r24, 0x058C
    101a:	81 50       	subi	r24, 0x01	; 1
    101c:	80 93 8c 05 	sts	0x058C, r24

		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    1020:	80 91 8c 05 	lds	r24, 0x058C
    1024:	81 11       	cpse	r24, r1
    1026:	61 c0       	rjmp	.+194    	; 0x10ea <xTaskResumeAll+0xe8>
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
    1028:	80 91 97 05 	lds	r24, 0x0597
    102c:	88 23       	and	r24, r24
    102e:	09 f4       	brne	.+2      	; 0x1032 <xTaskResumeAll+0x30>
    1030:	5e c0       	rjmp	.+188    	; 0x10ee <xTaskResumeAll+0xec>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    1032:	0f 2e       	mov	r0, r31
    1034:	fb ea       	ldi	r31, 0xAB	; 171
    1036:	ef 2e       	mov	r14, r31
    1038:	f5 e0       	ldi	r31, 0x05	; 5
    103a:	ff 2e       	mov	r15, r31
    103c:	f0 2d       	mov	r31, r0

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
					{
						xYieldPending = pdTRUE;
    103e:	dd 24       	eor	r13, r13
    1040:	d3 94       	inc	r13
    1042:	30 c0       	rjmp	.+96     	; 0x10a4 <xTaskResumeAll+0xa2>
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
    1044:	e0 91 b0 05 	lds	r30, 0x05B0
    1048:	f0 91 b1 05 	lds	r31, 0x05B1
    104c:	c6 81       	ldd	r28, Z+6	; 0x06
    104e:	d7 81       	ldd	r29, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
    1050:	ce 01       	movw	r24, r28
    1052:	0c 96       	adiw	r24, 0x0c	; 12
    1054:	0e 94 82 01 	call	0x304	; 0x304 <uxListRemove>
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    1058:	8e 01       	movw	r16, r28
    105a:	0e 5f       	subi	r16, 0xFE	; 254
    105c:	1f 4f       	sbci	r17, 0xFF	; 255
    105e:	c8 01       	movw	r24, r16
    1060:	0e 94 82 01 	call	0x304	; 0x304 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    1064:	8e 89       	ldd	r24, Y+22	; 0x16
    1066:	90 91 94 05 	lds	r25, 0x0594
    106a:	98 17       	cp	r25, r24
    106c:	10 f4       	brcc	.+4      	; 0x1072 <xTaskResumeAll+0x70>
    106e:	80 93 94 05 	sts	0x0594, r24
    1072:	90 e0       	ldi	r25, 0x00	; 0
    1074:	9c 01       	movw	r18, r24
    1076:	22 0f       	add	r18, r18
    1078:	33 1f       	adc	r19, r19
    107a:	22 0f       	add	r18, r18
    107c:	33 1f       	adc	r19, r19
    107e:	22 0f       	add	r18, r18
    1080:	33 1f       	adc	r19, r19
    1082:	82 0f       	add	r24, r18
    1084:	93 1f       	adc	r25, r19
    1086:	b8 01       	movw	r22, r16
    1088:	86 53       	subi	r24, 0x36	; 54
    108a:	9a 4f       	sbci	r25, 0xFA	; 250
    108c:	0e 94 30 01 	call	0x260	; 0x260 <vListInsertEnd>

					/* If the moved task has a priority higher than the current
					task then a yield must be performed. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    1090:	e0 91 ee 05 	lds	r30, 0x05EE
    1094:	f0 91 ef 05 	lds	r31, 0x05EF
    1098:	9e 89       	ldd	r25, Y+22	; 0x16
    109a:	86 89       	ldd	r24, Z+22	; 0x16
    109c:	98 17       	cp	r25, r24
    109e:	10 f0       	brcs	.+4      	; 0x10a4 <xTaskResumeAll+0xa2>
					{
						xYieldPending = pdTRUE;
    10a0:	d0 92 91 05 	sts	0x0591, r13
		{
			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
			{
				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
    10a4:	f7 01       	movw	r30, r14
    10a6:	80 81       	ld	r24, Z
    10a8:	81 11       	cpse	r24, r1
    10aa:	cc cf       	rjmp	.-104    	; 0x1044 <xTaskResumeAll+0x42>

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
    10ac:	80 91 92 05 	lds	r24, 0x0592
    10b0:	88 23       	and	r24, r24
    10b2:	99 f0       	breq	.+38     	; 0x10da <xTaskResumeAll+0xd8>
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    10b4:	80 91 92 05 	lds	r24, 0x0592
    10b8:	88 23       	and	r24, r24
    10ba:	79 f0       	breq	.+30     	; 0x10da <xTaskResumeAll+0xd8>
					{
						if( xTaskIncrementTick() != pdFALSE )
						{
							xYieldPending = pdTRUE;
    10bc:	c1 e0       	ldi	r28, 0x01	; 1
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
					{
						if( xTaskIncrementTick() != pdFALSE )
    10be:	0e 94 42 07 	call	0xe84	; 0xe84 <xTaskIncrementTick>
    10c2:	81 11       	cpse	r24, r1
						{
							xYieldPending = pdTRUE;
    10c4:	c0 93 91 05 	sts	0x0591, r28
						}
						else
						{
							mtCOVERAGE_TEST_MARKER();
						}
						--uxPendedTicks;
    10c8:	80 91 92 05 	lds	r24, 0x0592
    10cc:	81 50       	subi	r24, 0x01	; 1
    10ce:	80 93 92 05 	sts	0x0592, r24
				they should be processed now.  This ensures the tick count does
				not	slip, and that any delayed tasks are resumed at the correct
				time. */
				if( uxPendedTicks > ( UBaseType_t ) 0U )
				{
					while( uxPendedTicks > ( UBaseType_t ) 0U )
    10d2:	80 91 92 05 	lds	r24, 0x0592
    10d6:	81 11       	cpse	r24, r1
    10d8:	f2 cf       	rjmp	.-28     	; 0x10be <xTaskResumeAll+0xbc>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				if( xYieldPending == pdTRUE )
    10da:	80 91 91 05 	lds	r24, 0x0591
    10de:	81 30       	cpi	r24, 0x01	; 1
    10e0:	41 f4       	brne	.+16     	; 0x10f2 <xTaskResumeAll+0xf0>
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
					}
					#endif
					taskYIELD_IF_USING_PREEMPTION();
    10e2:	0e 94 4e 02 	call	0x49c	; 0x49c <vPortYield>

				if( xYieldPending == pdTRUE )
				{
					#if( configUSE_PREEMPTION != 0 )
					{
						xAlreadyYielded = pdTRUE;
    10e6:	81 e0       	ldi	r24, 0x01	; 1
    10e8:	05 c0       	rjmp	.+10     	; 0x10f4 <xTaskResumeAll+0xf2>
/*----------------------------------------------------------*/

BaseType_t xTaskResumeAll( void )
{
TCB_t *pxTCB;
BaseType_t xAlreadyYielded = pdFALSE;
    10ea:	80 e0       	ldi	r24, 0x00	; 0
    10ec:	03 c0       	rjmp	.+6      	; 0x10f4 <xTaskResumeAll+0xf2>
    10ee:	80 e0       	ldi	r24, 0x00	; 0
    10f0:	01 c0       	rjmp	.+2      	; 0x10f4 <xTaskResumeAll+0xf2>
    10f2:	80 e0       	ldi	r24, 0x00	; 0
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    10f4:	0f 90       	pop	r0
    10f6:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
    10f8:	df 91       	pop	r29
    10fa:	cf 91       	pop	r28
    10fc:	1f 91       	pop	r17
    10fe:	0f 91       	pop	r16
    1100:	ff 90       	pop	r15
    1102:	ef 90       	pop	r14
    1104:	df 90       	pop	r13
    1106:	08 95       	ret

00001108 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( const TickType_t xTicksToDelay )
	{
    1108:	cf 93       	push	r28
    110a:	df 93       	push	r29
    110c:	ec 01       	movw	r28, r24
	TickType_t xTimeToWake;
	BaseType_t xAlreadyYielded = pdFALSE;


		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( TickType_t ) 0U )
    110e:	00 97       	sbiw	r24, 0x00	; 0
    1110:	b1 f0       	breq	.+44     	; 0x113e <vTaskDelay+0x36>
		{
			configASSERT( uxSchedulerSuspended == 0 );
			vTaskSuspendAll();
    1112:	0e 94 3c 07 	call	0xe78	; 0xe78 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    1116:	80 91 95 05 	lds	r24, 0x0595
    111a:	90 91 96 05 	lds	r25, 0x0596
    111e:	c8 0f       	add	r28, r24
    1120:	d9 1f       	adc	r29, r25

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1122:	80 91 ee 05 	lds	r24, 0x05EE
    1126:	90 91 ef 05 	lds	r25, 0x05EF
    112a:	02 96       	adiw	r24, 0x02	; 2
    112c:	0e 94 82 01 	call	0x304	; 0x304 <uxListRemove>
				}
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    1130:	ce 01       	movw	r24, r28
    1132:	0e 94 c5 05 	call	0xb8a	; 0xb8a <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    1136:	0e 94 01 08 	call	0x1002	; 0x1002 <xTaskResumeAll>
			mtCOVERAGE_TEST_MARKER();
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    113a:	81 11       	cpse	r24, r1
    113c:	02 c0       	rjmp	.+4      	; 0x1142 <vTaskDelay+0x3a>
		{
			portYIELD_WITHIN_API();
    113e:	0e 94 4e 02 	call	0x49c	; 0x49c <vPortYield>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
    1142:	df 91       	pop	r29
    1144:	cf 91       	pop	r28
    1146:	08 95       	ret

00001148 <prvIdleTask>:

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    1148:	0f 2e       	mov	r0, r31
    114a:	fa ec       	ldi	r31, 0xCA	; 202
    114c:	ef 2e       	mov	r14, r31
    114e:	f5 e0       	ldi	r31, 0x05	; 5
    1150:	ff 2e       	mov	r15, r31
    1152:	f0 2d       	mov	r31, r0
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    1154:	c2 ea       	ldi	r28, 0xA2	; 162
    1156:	d5 e0       	ldi	r29, 0x05	; 5
    1158:	28 c0       	rjmp	.+80     	; 0x11aa <prvIdleTask+0x62>

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
		{
			vTaskSuspendAll();
    115a:	0e 94 3c 07 	call	0xe78	; 0xe78 <vTaskSuspendAll>
			{
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    115e:	18 81       	ld	r17, Y
			}
			( void ) xTaskResumeAll();
    1160:	0e 94 01 08 	call	0x1002	; 0x1002 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
    1164:	11 23       	and	r17, r17
    1166:	09 f1       	breq	.+66     	; 0x11aa <prvIdleTask+0x62>
			{
				TCB_t *pxTCB;

				taskENTER_CRITICAL();
    1168:	0f b6       	in	r0, 0x3f	; 63
    116a:	f8 94       	cli
    116c:	0f 92       	push	r0
				{
					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
    116e:	e0 91 a7 05 	lds	r30, 0x05A7
    1172:	f0 91 a8 05 	lds	r31, 0x05A8
    1176:	06 81       	ldd	r16, Z+6	; 0x06
    1178:	17 81       	ldd	r17, Z+7	; 0x07
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    117a:	c8 01       	movw	r24, r16
    117c:	02 96       	adiw	r24, 0x02	; 2
    117e:	0e 94 82 01 	call	0x304	; 0x304 <uxListRemove>
					--uxCurrentNumberOfTasks;
    1182:	80 91 97 05 	lds	r24, 0x0597
    1186:	81 50       	subi	r24, 0x01	; 1
    1188:	80 93 97 05 	sts	0x0597, r24
					--uxTasksDeleted;
    118c:	80 91 a1 05 	lds	r24, 0x05A1
    1190:	81 50       	subi	r24, 0x01	; 1
    1192:	80 93 a1 05 	sts	0x05A1, r24
				}
				taskEXIT_CRITICAL();
    1196:	0f 90       	pop	r0
    1198:	0f be       	out	0x3f, r0	; 63
				vPortFreeAligned( pxTCB->pxStack );
			}
		}
		#else
		{
			vPortFreeAligned( pxTCB->pxStack );
    119a:	f8 01       	movw	r30, r16
    119c:	87 89       	ldd	r24, Z+23	; 0x17
    119e:	90 8d       	ldd	r25, Z+24	; 0x18
    11a0:	0e 94 3b 03 	call	0x676	; 0x676 <vPortFree>
		}
		#endif

		vPortFree( pxTCB );
    11a4:	c8 01       	movw	r24, r16
    11a6:	0e 94 3b 03 	call	0x676	; 0x676 <vPortFree>
	{
		BaseType_t xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( UBaseType_t ) 0U )
    11aa:	80 91 a1 05 	lds	r24, 0x05A1
    11ae:	81 11       	cpse	r24, r1
    11b0:	d4 cf       	rjmp	.-88     	; 0x115a <prvIdleTask+0x12>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
    11b2:	f7 01       	movw	r30, r14
    11b4:	80 81       	ld	r24, Z
    11b6:	82 30       	cpi	r24, 0x02	; 2
    11b8:	c0 f3       	brcs	.-16     	; 0x11aa <prvIdleTask+0x62>
			{
				taskYIELD();
    11ba:	0e 94 4e 02 	call	0x49c	; 0x49c <vPortYield>
    11be:	f5 cf       	rjmp	.-22     	; 0x11aa <prvIdleTask+0x62>

000011c0 <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
    11c0:	80 91 8c 05 	lds	r24, 0x058C
    11c4:	88 23       	and	r24, r24
    11c6:	21 f0       	breq	.+8      	; 0x11d0 <vTaskSwitchContext+0x10>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xYieldPending = pdTRUE;
    11c8:	81 e0       	ldi	r24, 0x01	; 1
    11ca:	80 93 91 05 	sts	0x0591, r24
    11ce:	08 95       	ret
	}
	else
	{
		xYieldPending = pdFALSE;
    11d0:	10 92 91 05 	sts	0x0591, r1
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		/* Select a new task to run using either the generic C or port
		optimised asm code. */
		taskSELECT_HIGHEST_PRIORITY_TASK();
    11d4:	80 91 94 05 	lds	r24, 0x0594
    11d8:	90 e0       	ldi	r25, 0x00	; 0
    11da:	fc 01       	movw	r30, r24
    11dc:	ee 0f       	add	r30, r30
    11de:	ff 1f       	adc	r31, r31
    11e0:	ee 0f       	add	r30, r30
    11e2:	ff 1f       	adc	r31, r31
    11e4:	ee 0f       	add	r30, r30
    11e6:	ff 1f       	adc	r31, r31
    11e8:	8e 0f       	add	r24, r30
    11ea:	9f 1f       	adc	r25, r31
    11ec:	fc 01       	movw	r30, r24
    11ee:	e6 53       	subi	r30, 0x36	; 54
    11f0:	fa 4f       	sbci	r31, 0xFA	; 250
    11f2:	80 81       	ld	r24, Z
    11f4:	81 11       	cpse	r24, r1
    11f6:	17 c0       	rjmp	.+46     	; 0x1226 <vTaskSwitchContext+0x66>
    11f8:	80 91 94 05 	lds	r24, 0x0594
    11fc:	81 50       	subi	r24, 0x01	; 1
    11fe:	80 93 94 05 	sts	0x0594, r24
    1202:	80 91 94 05 	lds	r24, 0x0594
    1206:	90 e0       	ldi	r25, 0x00	; 0
    1208:	fc 01       	movw	r30, r24
    120a:	ee 0f       	add	r30, r30
    120c:	ff 1f       	adc	r31, r31
    120e:	ee 0f       	add	r30, r30
    1210:	ff 1f       	adc	r31, r31
    1212:	ee 0f       	add	r30, r30
    1214:	ff 1f       	adc	r31, r31
    1216:	8e 0f       	add	r24, r30
    1218:	9f 1f       	adc	r25, r31
    121a:	fc 01       	movw	r30, r24
    121c:	e6 53       	subi	r30, 0x36	; 54
    121e:	fa 4f       	sbci	r31, 0xFA	; 250
    1220:	80 81       	ld	r24, Z
    1222:	88 23       	and	r24, r24
    1224:	49 f3       	breq	.-46     	; 0x11f8 <vTaskSwitchContext+0x38>
    1226:	e0 91 94 05 	lds	r30, 0x0594
    122a:	f0 e0       	ldi	r31, 0x00	; 0
    122c:	cf 01       	movw	r24, r30
    122e:	88 0f       	add	r24, r24
    1230:	99 1f       	adc	r25, r25
    1232:	88 0f       	add	r24, r24
    1234:	99 1f       	adc	r25, r25
    1236:	88 0f       	add	r24, r24
    1238:	99 1f       	adc	r25, r25
    123a:	e8 0f       	add	r30, r24
    123c:	f9 1f       	adc	r31, r25
    123e:	e6 53       	subi	r30, 0x36	; 54
    1240:	fa 4f       	sbci	r31, 0xFA	; 250
    1242:	a1 81       	ldd	r26, Z+1	; 0x01
    1244:	b2 81       	ldd	r27, Z+2	; 0x02
    1246:	12 96       	adiw	r26, 0x02	; 2
    1248:	0d 90       	ld	r0, X+
    124a:	bc 91       	ld	r27, X
    124c:	a0 2d       	mov	r26, r0
    124e:	b2 83       	std	Z+2, r27	; 0x02
    1250:	a1 83       	std	Z+1, r26	; 0x01
    1252:	cf 01       	movw	r24, r30
    1254:	03 96       	adiw	r24, 0x03	; 3
    1256:	a8 17       	cp	r26, r24
    1258:	b9 07       	cpc	r27, r25
    125a:	31 f4       	brne	.+12     	; 0x1268 <vTaskSwitchContext+0xa8>
    125c:	12 96       	adiw	r26, 0x02	; 2
    125e:	8d 91       	ld	r24, X+
    1260:	9c 91       	ld	r25, X
    1262:	13 97       	sbiw	r26, 0x03	; 3
    1264:	92 83       	std	Z+2, r25	; 0x02
    1266:	81 83       	std	Z+1, r24	; 0x01
    1268:	01 80       	ldd	r0, Z+1	; 0x01
    126a:	f2 81       	ldd	r31, Z+2	; 0x02
    126c:	e0 2d       	mov	r30, r0
    126e:	86 81       	ldd	r24, Z+6	; 0x06
    1270:	97 81       	ldd	r25, Z+7	; 0x07
    1272:	90 93 ef 05 	sts	0x05EF, r25
    1276:	80 93 ee 05 	sts	0x05EE, r24
    127a:	08 95       	ret

0000127c <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
{
    127c:	cf 93       	push	r28
    127e:	df 93       	push	r29
    1280:	eb 01       	movw	r28, r22

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event.  The queue that contains the event
	list is locked, preventing simultaneous access from interrupts. */
	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
    1282:	60 91 ee 05 	lds	r22, 0x05EE
    1286:	70 91 ef 05 	lds	r23, 0x05EF
    128a:	64 5f       	subi	r22, 0xF4	; 244
    128c:	7f 4f       	sbci	r23, 0xFF	; 255
    128e:	0e 94 51 01 	call	0x2a2	; 0x2a2 <vListInsert>

	/* The task must be removed from from the ready list before it is added to
	the blocked list as the same list item is used for both lists.  Exclusive
	access to the ready lists guaranteed because the scheduler is locked. */
	if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    1292:	80 91 ee 05 	lds	r24, 0x05EE
    1296:	90 91 ef 05 	lds	r25, 0x05EF
    129a:	02 96       	adiw	r24, 0x02	; 2
    129c:	0e 94 82 01 	call	0x304	; 0x304 <uxListRemove>
		mtCOVERAGE_TEST_MARKER();
	}

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    12a0:	cf 3f       	cpi	r28, 0xFF	; 255
    12a2:	8f ef       	ldi	r24, 0xFF	; 255
    12a4:	d8 07       	cpc	r29, r24
    12a6:	59 f4       	brne	.+22     	; 0x12be <vTaskPlaceOnEventList+0x42>
		{
			/* Add the task to the suspended task list instead of a delayed task
			list to ensure the task is not woken by a timing event.  It will
			block indefinitely. */
			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    12a8:	60 91 ee 05 	lds	r22, 0x05EE
    12ac:	70 91 ef 05 	lds	r23, 0x05EF
    12b0:	6e 5f       	subi	r22, 0xFE	; 254
    12b2:	7f 4f       	sbci	r23, 0xFF	; 255
    12b4:	88 e9       	ldi	r24, 0x98	; 152
    12b6:	95 e0       	ldi	r25, 0x05	; 5
    12b8:	0e 94 30 01 	call	0x260	; 0x260 <vListInsertEnd>
    12bc:	08 c0       	rjmp	.+16     	; 0x12ce <vTaskPlaceOnEventList+0x52>
		else
		{
			/* Calculate the time at which the task should be woken if the event
			does not occur.  This may overflow but this doesn't matter, the
			scheduler will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
    12be:	80 91 95 05 	lds	r24, 0x0595
    12c2:	90 91 96 05 	lds	r25, 0x0596
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    12c6:	8c 0f       	add	r24, r28
    12c8:	9d 1f       	adc	r25, r29
    12ca:	0e 94 c5 05 	call	0xb8a	; 0xb8a <prvAddCurrentTaskToDelayedList>
			will handle it. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif /* INCLUDE_vTaskSuspend */
}
    12ce:	df 91       	pop	r29
    12d0:	cf 91       	pop	r28
    12d2:	08 95       	ret

000012d4 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
{
    12d4:	0f 93       	push	r16
    12d6:	1f 93       	push	r17
    12d8:	cf 93       	push	r28
    12da:	df 93       	push	r29
	get called - the lock count on the queue will get modified instead.  This
	means exclusive access to the event list is guaranteed here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    12dc:	dc 01       	movw	r26, r24
    12de:	15 96       	adiw	r26, 0x05	; 5
    12e0:	ed 91       	ld	r30, X+
    12e2:	fc 91       	ld	r31, X
    12e4:	16 97       	sbiw	r26, 0x06	; 6
    12e6:	c6 81       	ldd	r28, Z+6	; 0x06
    12e8:	d7 81       	ldd	r29, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
    12ea:	8e 01       	movw	r16, r28
    12ec:	04 5f       	subi	r16, 0xF4	; 244
    12ee:	1f 4f       	sbci	r17, 0xFF	; 255
    12f0:	c8 01       	movw	r24, r16
    12f2:	0e 94 82 01 	call	0x304	; 0x304 <uxListRemove>

	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    12f6:	80 91 8c 05 	lds	r24, 0x058C
    12fa:	81 11       	cpse	r24, r1
    12fc:	1c c0       	rjmp	.+56     	; 0x1336 <xTaskRemoveFromEventList+0x62>
	{
		( void ) uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    12fe:	0a 50       	subi	r16, 0x0A	; 10
    1300:	11 09       	sbc	r17, r1
    1302:	c8 01       	movw	r24, r16
    1304:	0e 94 82 01 	call	0x304	; 0x304 <uxListRemove>
		prvAddTaskToReadyList( pxUnblockedTCB );
    1308:	8e 89       	ldd	r24, Y+22	; 0x16
    130a:	90 91 94 05 	lds	r25, 0x0594
    130e:	98 17       	cp	r25, r24
    1310:	10 f4       	brcc	.+4      	; 0x1316 <xTaskRemoveFromEventList+0x42>
    1312:	80 93 94 05 	sts	0x0594, r24
    1316:	90 e0       	ldi	r25, 0x00	; 0
    1318:	9c 01       	movw	r18, r24
    131a:	22 0f       	add	r18, r18
    131c:	33 1f       	adc	r19, r19
    131e:	22 0f       	add	r18, r18
    1320:	33 1f       	adc	r19, r19
    1322:	22 0f       	add	r18, r18
    1324:	33 1f       	adc	r19, r19
    1326:	82 0f       	add	r24, r18
    1328:	93 1f       	adc	r25, r19
    132a:	b8 01       	movw	r22, r16
    132c:	86 53       	subi	r24, 0x36	; 54
    132e:	9a 4f       	sbci	r25, 0xFA	; 250
    1330:	0e 94 30 01 	call	0x260	; 0x260 <vListInsertEnd>
    1334:	05 c0       	rjmp	.+10     	; 0x1340 <xTaskRemoveFromEventList+0x6c>
	}
	else
	{
		/* The delayed and ready lists cannot be accessed, so hold this task
		pending until the scheduler is resumed. */
		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    1336:	b8 01       	movw	r22, r16
    1338:	8b ea       	ldi	r24, 0xAB	; 171
    133a:	95 e0       	ldi	r25, 0x05	; 5
    133c:	0e 94 30 01 	call	0x260	; 0x260 <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
    1340:	e0 91 ee 05 	lds	r30, 0x05EE
    1344:	f0 91 ef 05 	lds	r31, 0x05EF
    1348:	9e 89       	ldd	r25, Y+22	; 0x16
    134a:	86 89       	ldd	r24, Z+22	; 0x16
    134c:	89 17       	cp	r24, r25
    134e:	20 f4       	brcc	.+8      	; 0x1358 <xTaskRemoveFromEventList+0x84>
		it should force a context switch now. */
		xReturn = pdTRUE;

		/* Mark that a yield is pending in case the user is not using the
		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
		xYieldPending = pdTRUE;
    1350:	81 e0       	ldi	r24, 0x01	; 1
    1352:	80 93 91 05 	sts	0x0591, r24
    1356:	01 c0       	rjmp	.+2      	; 0x135a <xTaskRemoveFromEventList+0x86>
	}
	else
	{
		xReturn = pdFALSE;
    1358:	80 e0       	ldi	r24, 0x00	; 0
		prvResetNextTaskUnblockTime();
	}
	#endif

	return xReturn;
}
    135a:	df 91       	pop	r29
    135c:	cf 91       	pop	r28
    135e:	1f 91       	pop	r17
    1360:	0f 91       	pop	r16
    1362:	08 95       	ret

00001364 <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    1364:	20 91 90 05 	lds	r18, 0x0590
    1368:	fc 01       	movw	r30, r24
    136a:	20 83       	st	Z, r18
	pxTimeOut->xTimeOnEntering = xTickCount;
    136c:	20 91 95 05 	lds	r18, 0x0595
    1370:	30 91 96 05 	lds	r19, 0x0596
    1374:	32 83       	std	Z+2, r19	; 0x02
    1376:	21 83       	std	Z+1, r18	; 0x01
    1378:	08 95       	ret

0000137a <xTaskCheckForTimeOut>:
BaseType_t xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    137a:	0f b6       	in	r0, 0x3f	; 63
    137c:	f8 94       	cli
    137e:	0f 92       	push	r0
	{
		/* Minor optimisation.  The tick count cannot change in this block. */
		const TickType_t xConstTickCount = xTickCount;
    1380:	40 91 95 05 	lds	r20, 0x0595
    1384:	50 91 96 05 	lds	r21, 0x0596

		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    1388:	db 01       	movw	r26, r22
    138a:	2d 91       	ld	r18, X+
    138c:	3c 91       	ld	r19, X
    138e:	2f 3f       	cpi	r18, 0xFF	; 255
    1390:	bf ef       	ldi	r27, 0xFF	; 255
    1392:	3b 07       	cpc	r19, r27
    1394:	19 f1       	breq	.+70     	; 0x13dc <xTaskCheckForTimeOut+0x62>
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
    1396:	e0 91 90 05 	lds	r30, 0x0590
    139a:	dc 01       	movw	r26, r24
    139c:	fc 91       	ld	r31, X
    139e:	fe 17       	cp	r31, r30
    13a0:	39 f0       	breq	.+14     	; 0x13b0 <xTaskCheckForTimeOut+0x36>
    13a2:	11 96       	adiw	r26, 0x01	; 1
    13a4:	ed 91       	ld	r30, X+
    13a6:	fc 91       	ld	r31, X
    13a8:	12 97       	sbiw	r26, 0x02	; 2
    13aa:	4e 17       	cp	r20, r30
    13ac:	5f 07       	cpc	r21, r31
    13ae:	c0 f4       	brcc	.+48     	; 0x13e0 <xTaskCheckForTimeOut+0x66>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( xConstTickCount - pxTimeOut->xTimeOnEntering ) < *pxTicksToWait )
    13b0:	dc 01       	movw	r26, r24
    13b2:	11 96       	adiw	r26, 0x01	; 1
    13b4:	ed 91       	ld	r30, X+
    13b6:	fc 91       	ld	r31, X
    13b8:	12 97       	sbiw	r26, 0x02	; 2
    13ba:	da 01       	movw	r26, r20
    13bc:	ae 1b       	sub	r26, r30
    13be:	bf 0b       	sbc	r27, r31
    13c0:	a2 17       	cp	r26, r18
    13c2:	b3 07       	cpc	r27, r19
    13c4:	78 f4       	brcc	.+30     	; 0x13e4 <xTaskCheckForTimeOut+0x6a>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( xConstTickCount -  pxTimeOut->xTimeOnEntering );
    13c6:	e4 1b       	sub	r30, r20
    13c8:	f5 0b       	sbc	r31, r21
    13ca:	2e 0f       	add	r18, r30
    13cc:	3f 1f       	adc	r19, r31
    13ce:	fb 01       	movw	r30, r22
    13d0:	31 83       	std	Z+1, r19	; 0x01
    13d2:	20 83       	st	Z, r18
			vTaskSetTimeOutState( pxTimeOut );
    13d4:	0e 94 b2 09 	call	0x1364	; 0x1364 <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    13d8:	80 e0       	ldi	r24, 0x00	; 0
    13da:	05 c0       	rjmp	.+10     	; 0x13e6 <xTaskCheckForTimeOut+0x6c>
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
			{
				xReturn = pdFALSE;
    13dc:	80 e0       	ldi	r24, 0x00	; 0
    13de:	03 c0       	rjmp	.+6      	; 0x13e6 <xTaskCheckForTimeOut+0x6c>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    13e0:	81 e0       	ldi	r24, 0x01	; 1
    13e2:	01 c0       	rjmp	.+2      	; 0x13e6 <xTaskCheckForTimeOut+0x6c>
			vTaskSetTimeOutState( pxTimeOut );
			xReturn = pdFALSE;
		}
		else
		{
			xReturn = pdTRUE;
    13e4:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	taskEXIT_CRITICAL();
    13e6:	0f 90       	pop	r0
    13e8:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
    13ea:	08 95       	ret

000013ec <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xYieldPending = pdTRUE;
    13ec:	81 e0       	ldi	r24, 0x01	; 1
    13ee:	80 93 91 05 	sts	0x0591, r24
    13f2:	08 95       	ret

000013f4 <vTestTask>:
#include "LCD/LCD.h"
#include "RTC/RTC.h"
#include "WiFi/WiFi.h"

void vTestTask(void *pvParameters)
{
    13f4:	cf 93       	push	r28
    13f6:	df 93       	push	r29
    13f8:	cd b7       	in	r28, 0x3d	; 61
    13fa:	de b7       	in	r29, 0x3e	; 62
    13fc:	60 97       	sbiw	r28, 0x10	; 16
    13fe:	0f b6       	in	r0, 0x3f	; 63
    1400:	f8 94       	cli
    1402:	de bf       	out	0x3e, r29	; 62
    1404:	0f be       	out	0x3f, r0	; 63
    1406:	cd bf       	out	0x3d, r28	; 61
	RTCMsg_t RTCMessage;
	WiFiMsg_t WifiMessage;
	
	while(1)
	{
		xQueueSend(hallEffectMsgQ, &hallEffectMessage, 10);
    1408:	20 e0       	ldi	r18, 0x00	; 0
    140a:	4a e0       	ldi	r20, 0x0A	; 10
    140c:	50 e0       	ldi	r21, 0x00	; 0
    140e:	be 01       	movw	r22, r28
    1410:	6f 5f       	subi	r22, 0xFF	; 255
    1412:	7f 4f       	sbci	r23, 0xFF	; 255
    1414:	80 91 f0 05 	lds	r24, 0x05F0
    1418:	90 91 f1 05 	lds	r25, 0x05F1
    141c:	0e 94 58 04 	call	0x8b0	; 0x8b0 <xQueueGenericSend>
		vTaskDelay(1000);
    1420:	88 ee       	ldi	r24, 0xE8	; 232
    1422:	93 e0       	ldi	r25, 0x03	; 3
    1424:	0e 94 84 08 	call	0x1108	; 0x1108 <vTaskDelay>
		xQueueSend(lcdMsgQ, &LCDMessage, 10);
    1428:	20 e0       	ldi	r18, 0x00	; 0
    142a:	4a e0       	ldi	r20, 0x0A	; 10
    142c:	50 e0       	ldi	r21, 0x00	; 0
    142e:	be 01       	movw	r22, r28
    1430:	6b 5f       	subi	r22, 0xFB	; 251
    1432:	7f 4f       	sbci	r23, 0xFF	; 255
    1434:	80 91 f2 05 	lds	r24, 0x05F2
    1438:	90 91 f3 05 	lds	r25, 0x05F3
    143c:	0e 94 58 04 	call	0x8b0	; 0x8b0 <xQueueGenericSend>
		vTaskDelay(1000);
    1440:	88 ee       	ldi	r24, 0xE8	; 232
    1442:	93 e0       	ldi	r25, 0x03	; 3
    1444:	0e 94 84 08 	call	0x1108	; 0x1108 <vTaskDelay>
		xQueueSend(rtcMsgQ, &RTCMessage, 10);
    1448:	20 e0       	ldi	r18, 0x00	; 0
    144a:	4a e0       	ldi	r20, 0x0A	; 10
    144c:	50 e0       	ldi	r21, 0x00	; 0
    144e:	be 01       	movw	r22, r28
    1450:	69 5f       	subi	r22, 0xF9	; 249
    1452:	7f 4f       	sbci	r23, 0xFF	; 255
    1454:	80 91 f4 05 	lds	r24, 0x05F4
    1458:	90 91 f5 05 	lds	r25, 0x05F5
    145c:	0e 94 58 04 	call	0x8b0	; 0x8b0 <xQueueGenericSend>
		vTaskDelay(1000);
    1460:	88 ee       	ldi	r24, 0xE8	; 232
    1462:	93 e0       	ldi	r25, 0x03	; 3
    1464:	0e 94 84 08 	call	0x1108	; 0x1108 <vTaskDelay>
		xQueueSend(wifiMsgQ, &WifiMessage, 10);
    1468:	20 e0       	ldi	r18, 0x00	; 0
    146a:	4a e0       	ldi	r20, 0x0A	; 10
    146c:	50 e0       	ldi	r21, 0x00	; 0
    146e:	be 01       	movw	r22, r28
    1470:	63 5f       	subi	r22, 0xF3	; 243
    1472:	7f 4f       	sbci	r23, 0xFF	; 255
    1474:	80 91 f6 05 	lds	r24, 0x05F6
    1478:	90 91 f7 05 	lds	r25, 0x05F7
    147c:	0e 94 58 04 	call	0x8b0	; 0x8b0 <xQueueGenericSend>
		vTaskDelay(1000);	
    1480:	88 ee       	ldi	r24, 0xE8	; 232
    1482:	93 e0       	ldi	r25, 0x03	; 3
    1484:	0e 94 84 08 	call	0x1108	; 0x1108 <vTaskDelay>
    1488:	bf cf       	rjmp	.-130    	; 0x1408 <vTestTask+0x14>

0000148a <USART_Init>:
#include <avr/io.h>
#include <stdio.h>

void USART_Init(unsigned int ubrr) {
	/* set baud rate */
	UBRR0H = (unsigned char)(ubrr>>8);
    148a:	90 93 c5 00 	sts	0x00C5, r25
	UBRR0L = (unsigned char)ubrr;
    148e:	80 93 c4 00 	sts	0x00C4, r24

    UCSR0C = _BV(USBS0) | _BV(UCSZ01) | _BV(UCSZ00); /* 8-bit data, 2 stop bits */ 
    1492:	8e e0       	ldi	r24, 0x0E	; 14
    1494:	80 93 c2 00 	sts	0x00C2, r24
    UCSR0B = _BV(RXEN0) | _BV(TXEN0);   /* Enable RX and TX */    
    1498:	88 e1       	ldi	r24, 0x18	; 24
    149a:	80 93 c1 00 	sts	0x00C1, r24
    149e:	08 95       	ret

000014a0 <USART_Transmit>:
}

void USART_Transmit(char c, FILE *stream) {
    14a0:	cf 93       	push	r28
    14a2:	c8 2f       	mov	r28, r24
    if (c == '\n') {
    14a4:	8a 30       	cpi	r24, 0x0A	; 10
    14a6:	19 f4       	brne	.+6      	; 0x14ae <USART_Transmit+0xe>
        USART_Transmit('\r', stream); /* transmit carriage return with new line */
    14a8:	8d e0       	ldi	r24, 0x0D	; 13
    14aa:	0e 94 50 0a 	call	0x14a0	; 0x14a0 <USART_Transmit>
    }
    /* Wait for empty transmit buffer */
    while ( !( UCSR0A & (1<<UDRE0)) )
    14ae:	e0 ec       	ldi	r30, 0xC0	; 192
    14b0:	f0 e0       	ldi	r31, 0x00	; 0
    14b2:	90 81       	ld	r25, Z
    14b4:	95 ff       	sbrs	r25, 5
    14b6:	fd cf       	rjmp	.-6      	; 0x14b2 <USART_Transmit+0x12>
    ;
    /* Put data into buffer, sends the data */
    UDR0 = c;
    14b8:	c0 93 c6 00 	sts	0x00C6, r28
}
    14bc:	cf 91       	pop	r28
    14be:	08 95       	ret

000014c0 <USART_Receive>:

char USART_Receive(FILE *stream) {
    /* Wait for data to be received */
    while ( !(UCSR0A & (1<<RXC0)) )
    14c0:	e0 ec       	ldi	r30, 0xC0	; 192
    14c2:	f0 e0       	ldi	r31, 0x00	; 0
    14c4:	80 81       	ld	r24, Z
    14c6:	88 23       	and	r24, r24
    14c8:	ec f7       	brge	.-6      	; 0x14c4 <USART_Receive+0x4>
    ;
    /* Get and return received data from buffer */
    return UDR0;
    14ca:	80 91 c6 00 	lds	r24, 0x00C6
}
    14ce:	08 95       	ret

000014d0 <vWifiTask>:
#include "WiFi.h"

xQueueHandle wifiMsgQ;

void vWifiTask(void *pvParameters)
{
    14d0:	cf 93       	push	r28
    14d2:	df 93       	push	r29
    14d4:	00 d0       	rcall	.+0      	; 0x14d6 <vWifiTask+0x6>
    14d6:	00 d0       	rcall	.+0      	; 0x14d8 <vWifiTask+0x8>
    14d8:	cd b7       	in	r28, 0x3d	; 61
    14da:	de b7       	in	r29, 0x3e	; 62
	uint32_t blockTime = portMAX_DELAY;
	WiFiMsg_t msg;
	while(1)
	{
		if(xQueueReceive(wifiMsgQ, &msg, blockTime))
    14dc:	20 e0       	ldi	r18, 0x00	; 0
    14de:	4f ef       	ldi	r20, 0xFF	; 255
    14e0:	5f ef       	ldi	r21, 0xFF	; 255
    14e2:	be 01       	movw	r22, r28
    14e4:	6f 5f       	subi	r22, 0xFF	; 255
    14e6:	7f 4f       	sbci	r23, 0xFF	; 255
    14e8:	80 91 f6 05 	lds	r24, 0x05F6
    14ec:	90 91 f7 05 	lds	r25, 0x05F7
    14f0:	0e 94 fa 04 	call	0x9f4	; 0x9f4 <xQueueGenericReceive>
    14f4:	88 23       	and	r24, r24
    14f6:	91 f3       	breq	.-28     	; 0x14dc <vWifiTask+0xc>
		{
			printf("\n WiFi Message received\n");
    14f8:	88 e8       	ldi	r24, 0x88	; 136
    14fa:	91 e0       	ldi	r25, 0x01	; 1
    14fc:	0e 94 8a 0a 	call	0x1514	; 0x1514 <puts>
    1500:	ed cf       	rjmp	.-38     	; 0x14dc <vWifiTask+0xc>

00001502 <memcpy>:
    1502:	fb 01       	movw	r30, r22
    1504:	dc 01       	movw	r26, r24
    1506:	02 c0       	rjmp	.+4      	; 0x150c <memcpy+0xa>
    1508:	01 90       	ld	r0, Z+
    150a:	0d 92       	st	X+, r0
    150c:	41 50       	subi	r20, 0x01	; 1
    150e:	50 40       	sbci	r21, 0x00	; 0
    1510:	d8 f7       	brcc	.-10     	; 0x1508 <memcpy+0x6>
    1512:	08 95       	ret

00001514 <puts>:
    1514:	0f 93       	push	r16
    1516:	1f 93       	push	r17
    1518:	cf 93       	push	r28
    151a:	df 93       	push	r29
    151c:	e0 91 fa 05 	lds	r30, 0x05FA
    1520:	f0 91 fb 05 	lds	r31, 0x05FB
    1524:	23 81       	ldd	r18, Z+3	; 0x03
    1526:	21 ff       	sbrs	r18, 1
    1528:	1b c0       	rjmp	.+54     	; 0x1560 <puts+0x4c>
    152a:	ec 01       	movw	r28, r24
    152c:	00 e0       	ldi	r16, 0x00	; 0
    152e:	10 e0       	ldi	r17, 0x00	; 0
    1530:	89 91       	ld	r24, Y+
    1532:	60 91 fa 05 	lds	r22, 0x05FA
    1536:	70 91 fb 05 	lds	r23, 0x05FB
    153a:	db 01       	movw	r26, r22
    153c:	18 96       	adiw	r26, 0x08	; 8
    153e:	ed 91       	ld	r30, X+
    1540:	fc 91       	ld	r31, X
    1542:	19 97       	sbiw	r26, 0x09	; 9
    1544:	88 23       	and	r24, r24
    1546:	31 f0       	breq	.+12     	; 0x1554 <puts+0x40>
    1548:	09 95       	icall
    154a:	89 2b       	or	r24, r25
    154c:	89 f3       	breq	.-30     	; 0x1530 <puts+0x1c>
    154e:	0f ef       	ldi	r16, 0xFF	; 255
    1550:	1f ef       	ldi	r17, 0xFF	; 255
    1552:	ee cf       	rjmp	.-36     	; 0x1530 <puts+0x1c>
    1554:	8a e0       	ldi	r24, 0x0A	; 10
    1556:	09 95       	icall
    1558:	89 2b       	or	r24, r25
    155a:	11 f4       	brne	.+4      	; 0x1560 <puts+0x4c>
    155c:	c8 01       	movw	r24, r16
    155e:	02 c0       	rjmp	.+4      	; 0x1564 <puts+0x50>
    1560:	8f ef       	ldi	r24, 0xFF	; 255
    1562:	9f ef       	ldi	r25, 0xFF	; 255
    1564:	df 91       	pop	r29
    1566:	cf 91       	pop	r28
    1568:	1f 91       	pop	r17
    156a:	0f 91       	pop	r16
    156c:	08 95       	ret

0000156e <_exit>:
    156e:	f8 94       	cli

00001570 <__stop_program>:
    1570:	ff cf       	rjmp	.-2      	; 0x1570 <__stop_program>
